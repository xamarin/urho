// WARNING - AUTOGENERATED - DO NOT EDIT
// 
// Generated using `sharpie urho`
// 
// Connection.cs
// 
// Copyright 2015 Xamarin Inc. All rights reserved.

using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using Urho.Urho2D;
using Urho.Gui;
using Urho.Resources;
using Urho.IO;
using Urho.Navigation;
using Urho.Network;

namespace Urho.Network
{
	/// <summary>
	/// %Connection to a remote network host.
	/// </summary>
	public unsafe partial class Connection : UrhoObject
	{
		unsafe partial void OnConnectionCreated ();

		[Preserve]
		public Connection (IntPtr handle) : base (handle)
		{
			OnConnectionCreated ();
		}

		[Preserve]
		protected Connection (UrhoObjectFlag emptyFlag) : base (emptyFlag)
		{
			OnConnectionCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Connection_GetType (IntPtr handle);

		private StringHash UrhoGetType ()
		{
			Runtime.ValidateRefCounted (this);
			return new StringHash (Connection_GetType (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Connection_GetTypeName (IntPtr handle);

		private string GetTypeName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (Connection_GetTypeName (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Connection_GetTypeStatic ();

		private static StringHash GetTypeStatic ()
		{
			Runtime.Validate (typeof(Connection));
			return new StringHash (Connection_GetTypeStatic ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Connection_GetTypeNameStatic ();

		private static string GetTypeNameStatic ()
		{
			Runtime.Validate (typeof(Connection));
			return Marshal.PtrToStringAnsi (Connection_GetTypeNameStatic ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_SendMessage (IntPtr handle, int msgID, bool reliable, bool inOrder, byte* data, uint numBytes, uint contentID);

		/// <summary>
		/// Send a message.
		/// </summary>
		public void SendMessage (int msgID, bool reliable, bool inOrder, byte* data, uint numBytes, uint contentID)
		{
			Runtime.ValidateRefCounted (this);
			Connection_SendMessage (handle, msgID, reliable, inOrder, data, numBytes, contentID);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_SetScene (IntPtr handle, IntPtr newScene);

		/// <summary>
		/// Assign scene. On the server, this will cause the client to load it.
		/// </summary>
		private void SetScene (Scene newScene)
		{
			Runtime.ValidateRefCounted (this);
			Connection_SetScene (handle, (object)newScene == null ? IntPtr.Zero : newScene.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_SetPosition (IntPtr handle, ref Urho.Vector3 position);

		/// <summary>
		/// Set the observer position for interest management, to be sent to the server.
		/// </summary>
		private void SetPosition (Urho.Vector3 position)
		{
			Runtime.ValidateRefCounted (this);
			Connection_SetPosition (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_SetRotation (IntPtr handle, ref Urho.Quaternion rotation);

		/// <summary>
		/// Set the observer rotation for interest management, to be sent to the server. Note: not used by the NetworkPriority component.
		/// </summary>
		private void SetRotation (Urho.Quaternion rotation)
		{
			Runtime.ValidateRefCounted (this);
			Connection_SetRotation (handle, ref rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_SetConnectPending (IntPtr handle, bool connectPending);

		/// <summary>
		/// Set the connection pending status. Called by Network.
		/// </summary>
		private void SetConnectPending (bool connectPending)
		{
			Runtime.ValidateRefCounted (this);
			Connection_SetConnectPending (handle, connectPending);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_SetLogStatistics (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether to log data in/out statistics.
		/// </summary>
		private void SetLogStatistics (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			Connection_SetLogStatistics (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_Disconnect (IntPtr handle, int waitMSec);

		/// <summary>
		/// Disconnect. If wait time is non-zero, will block while waiting for disconnect to finish.
		/// </summary>
		public void Disconnect (int waitMSec)
		{
			Runtime.ValidateRefCounted (this);
			Connection_Disconnect (handle, waitMSec);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_SendServerUpdate (IntPtr handle);

		/// <summary>
		/// Send scene update messages. Called by Network.
		/// </summary>
		public void SendServerUpdate ()
		{
			Runtime.ValidateRefCounted (this);
			Connection_SendServerUpdate (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_SendClientUpdate (IntPtr handle);

		/// <summary>
		/// Send latest controls from the client. Called by Network.
		/// </summary>
		public void SendClientUpdate ()
		{
			Runtime.ValidateRefCounted (this);
			Connection_SendClientUpdate (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_SendRemoteEvents (IntPtr handle);

		/// <summary>
		/// Send queued remote events. Called by Network.
		/// </summary>
		public void SendRemoteEvents ()
		{
			Runtime.ValidateRefCounted (this);
			Connection_SendRemoteEvents (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_SendPackages (IntPtr handle);

		/// <summary>
		/// Send package files to client. Called by network.
		/// </summary>
		public void SendPackages ()
		{
			Runtime.ValidateRefCounted (this);
			Connection_SendPackages (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_ProcessPendingLatestData (IntPtr handle);

		/// <summary>
		/// Process pending latest data for nodes and components.
		/// </summary>
		public void ProcessPendingLatestData ()
		{
			Runtime.ValidateRefCounted (this);
			Connection_ProcessPendingLatestData (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Connection_GetScene (IntPtr handle);

		/// <summary>
		/// Return the scene used by this connection.
		/// </summary>
		private Scene GetScene ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Scene> (Connection_GetScene (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern byte Connection_GetTimeStamp (IntPtr handle);

		/// <summary>
		/// Return the controls timestamp, sent from client to server along each control update.
		/// </summary>
		private byte GetTimeStamp ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetTimeStamp (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Vector3 Connection_GetPosition (IntPtr handle);

		/// <summary>
		/// Return the observer position sent by the client for interest management.
		/// </summary>
		private Urho.Vector3 GetPosition ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetPosition (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Quaternion Connection_GetRotation (IntPtr handle);

		/// <summary>
		/// Return the observer rotation sent by the client for interest management.
		/// </summary>
		private Urho.Quaternion GetRotation ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetRotation (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Connection_IsClient (IntPtr handle);

		/// <summary>
		/// Return whether is a client connection.
		/// </summary>
		private bool IsClient ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_IsClient (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Connection_IsConnected (IntPtr handle);

		/// <summary>
		/// Return whether is fully connected.
		/// </summary>
		private bool IsConnected ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_IsConnected (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Connection_IsConnectPending (IntPtr handle);

		/// <summary>
		/// Return whether connection is pending.
		/// </summary>
		private bool IsConnectPending ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_IsConnectPending (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Connection_IsSceneLoaded (IntPtr handle);

		/// <summary>
		/// Return whether the scene is loaded and ready to receive server updates.
		/// </summary>
		private bool IsSceneLoaded ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_IsSceneLoaded (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Connection_GetLogStatistics (IntPtr handle);

		/// <summary>
		/// Return whether to log data in/out statistics.
		/// </summary>
		private bool GetLogStatistics ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetLogStatistics (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Connection_GetAddress (IntPtr handle);

		/// <summary>
		/// Return remote address.
		/// </summary>
		private string GetAddress ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (Connection_GetAddress (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern ushort Connection_GetPort (IntPtr handle);

		/// <summary>
		/// Return remote port.
		/// </summary>
		private ushort GetPort ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetPort (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Connection_GetRoundTripTime (IntPtr handle);

		/// <summary>
		/// Return the connection's round trip time in milliseconds.
		/// </summary>
		private float GetRoundTripTime ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetRoundTripTime (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Connection_GetLastHeardTime (IntPtr handle);

		/// <summary>
		/// Return the time since last received data from the remote host in milliseconds.
		/// </summary>
		private float GetLastHeardTime ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetLastHeardTime (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Connection_GetBytesInPerSec (IntPtr handle);

		/// <summary>
		/// Return bytes received per second.
		/// </summary>
		private float GetBytesInPerSec ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetBytesInPerSec (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Connection_GetBytesOutPerSec (IntPtr handle);

		/// <summary>
		/// Return bytes sent per second.
		/// </summary>
		private float GetBytesOutPerSec ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetBytesOutPerSec (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Connection_GetPacketsInPerSec (IntPtr handle);

		/// <summary>
		/// Return packets received per second.
		/// </summary>
		private float GetPacketsInPerSec ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetPacketsInPerSec (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Connection_GetPacketsOutPerSec (IntPtr handle);

		/// <summary>
		/// Return packets sent per second.
		/// </summary>
		private float GetPacketsOutPerSec ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetPacketsOutPerSec (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Connection_ToString (IntPtr handle);

		/// <summary>
		/// Return an address:port string.
		/// </summary>
		public string ToDebugString ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (Connection_ToString (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Connection_GetNumDownloads (IntPtr handle);

		/// <summary>
		/// Return number of package downloads remaining.
		/// </summary>
		private uint GetNumDownloads ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetNumDownloads (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Connection_GetDownloadName (IntPtr handle);

		/// <summary>
		/// Return name of current package download, or empty if no downloads.
		/// </summary>
		private string GetDownloadName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (Connection_GetDownloadName (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Connection_GetDownloadProgress (IntPtr handle);

		/// <summary>
		/// Return progress of current package download, or 1.0 if no downloads.
		/// </summary>
		private float GetDownloadProgress ()
		{
			Runtime.ValidateRefCounted (this);
			return Connection_GetDownloadProgress (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_SendPackageToClient (IntPtr handle, IntPtr package);

		/// <summary>
		/// Trigger client connection to download a package file from the server. Can be used to download additional resource packages when client is already joined in a scene. The package must have been added as a requirement to the scene the client is joined in, or else the eventual download will fail.
		/// </summary>
		public void SendPackageToClient (PackageFile package)
		{
			Runtime.ValidateRefCounted (this);
			Connection_SendPackageToClient (handle, (object)package == null ? IntPtr.Zero : package.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Connection_ConfigureNetworkSimulator (IntPtr handle, int latencyMs, float packetLoss);

		/// <summary>
		/// Set network simulation parameters. Called by Network.
		/// </summary>
		public void ConfigureNetworkSimulator (int latencyMs, float packetLoss)
		{
			Runtime.ValidateRefCounted (this);
			Connection_ConfigureNetworkSimulator (handle, latencyMs, packetLoss);
		}

		public override StringHash Type {
			get {
				return UrhoGetType ();
			}
		}

		public override string TypeName {
			get {
				return GetTypeName ();
			}
		}

		[Preserve]
		public static StringHash TypeStatic {
			get {
				return GetTypeStatic ();
			}
		}

		public static string TypeNameStatic {
			get {
				return GetTypeNameStatic ();
			}
		}

		/// <summary>
		/// Return the scene used by this connection.
		/// Or
		/// Assign scene. On the server, this will cause the client to load it.
		/// </summary>
		public Scene Scene {
			get {
				return GetScene ();
			}
			set {
				SetScene (value);
			}
		}

		/// <summary>
		/// Return the observer position sent by the client for interest management.
		/// Or
		/// Set the observer position for interest management, to be sent to the server.
		/// </summary>
		public Urho.Vector3 Position {
			get {
				return GetPosition ();
			}
			set {
				SetPosition (value);
			}
		}

		/// <summary>
		/// Return the observer rotation sent by the client for interest management.
		/// Or
		/// Set the observer rotation for interest management, to be sent to the server. Note: not used by the NetworkPriority component.
		/// </summary>
		public Urho.Quaternion Rotation {
			get {
				return GetRotation ();
			}
			set {
				SetRotation (value);
			}
		}

		/// <summary>
		/// Return whether connection is pending.
		/// Or
		/// Set the connection pending status. Called by Network.
		/// </summary>
		public bool ConnectPending {
			get {
				return IsConnectPending ();
			}
			set {
				SetConnectPending (value);
			}
		}

		/// <summary>
		/// Return whether to log data in/out statistics.
		/// Or
		/// Set whether to log data in/out statistics.
		/// </summary>
		public bool LogStatistics {
			get {
				return GetLogStatistics ();
			}
			set {
				SetLogStatistics (value);
			}
		}

		/// <summary>
		/// Return the controls timestamp, sent from client to server along each control update.
		/// </summary>
		public byte TimeStamp {
			get {
				return GetTimeStamp ();
			}
		}

		/// <summary>
		/// Return whether is a client connection.
		/// </summary>
		public bool Client {
			get {
				return IsClient ();
			}
		}

		/// <summary>
		/// Return whether is fully connected.
		/// </summary>
		public bool Connected {
			get {
				return IsConnected ();
			}
		}

		/// <summary>
		/// Return whether the scene is loaded and ready to receive server updates.
		/// </summary>
		public bool SceneLoaded {
			get {
				return IsSceneLoaded ();
			}
		}

		/// <summary>
		/// Return remote address.
		/// </summary>
		public string Address {
			get {
				return GetAddress ();
			}
		}

		/// <summary>
		/// Return remote port.
		/// </summary>
		public ushort Port {
			get {
				return GetPort ();
			}
		}

		/// <summary>
		/// Return the connection's round trip time in milliseconds.
		/// </summary>
		public float RoundTripTime {
			get {
				return GetRoundTripTime ();
			}
		}

		/// <summary>
		/// Return the time since last received data from the remote host in milliseconds.
		/// </summary>
		public float LastHeardTime {
			get {
				return GetLastHeardTime ();
			}
		}

		/// <summary>
		/// Return bytes received per second.
		/// </summary>
		public float BytesInPerSec {
			get {
				return GetBytesInPerSec ();
			}
		}

		/// <summary>
		/// Return bytes sent per second.
		/// </summary>
		public float BytesOutPerSec {
			get {
				return GetBytesOutPerSec ();
			}
		}

		/// <summary>
		/// Return packets received per second.
		/// </summary>
		public float PacketsInPerSec {
			get {
				return GetPacketsInPerSec ();
			}
		}

		/// <summary>
		/// Return packets sent per second.
		/// </summary>
		public float PacketsOutPerSec {
			get {
				return GetPacketsOutPerSec ();
			}
		}

		/// <summary>
		/// Return number of package downloads remaining.
		/// </summary>
		public uint NumDownloads {
			get {
				return GetNumDownloads ();
			}
		}

		/// <summary>
		/// Return name of current package download, or empty if no downloads.
		/// </summary>
		public string DownloadName {
			get {
				return GetDownloadName ();
			}
		}

		/// <summary>
		/// Return progress of current package download, or 1.0 if no downloads.
		/// </summary>
		public float DownloadProgress {
			get {
				return GetDownloadProgress ();
			}
		}
	}
}
