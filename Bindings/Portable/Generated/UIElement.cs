// WARNING - AUTOGENERATED - DO NOT EDIT
// 
// Generated using `sharpie urho`
// 
// UIElement.cs
// 
// Copyright 2015 Xamarin Inc. All rights reserved.

using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using Urho.Urho2D;
using Urho.Gui;
using Urho.Resources;
using Urho.IO;
using Urho.Navigation;
using Urho.Network;

namespace Urho.Gui
{
	/// <summary>
	/// Base class for %UI elements.
	/// </summary>
	public unsafe partial class UIElement : Animatable
	{
		unsafe partial void OnUIElementCreated ();

		[Preserve]
		public UIElement (IntPtr handle) : base (handle)
		{
			OnUIElementCreated ();
		}

		[Preserve]
		protected UIElement (UrhoObjectFlag emptyFlag) : base (emptyFlag)
		{
			OnUIElementCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetType (IntPtr handle);

		private StringHash UrhoGetType ()
		{
			Runtime.ValidateRefCounted (this);
			return new StringHash (UIElement_GetType (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_GetTypeName (IntPtr handle);

		private string GetTypeName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (UIElement_GetTypeName (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetTypeStatic ();

		private static StringHash GetTypeStatic ()
		{
			Runtime.Validate (typeof(UIElement));
			return new StringHash (UIElement_GetTypeStatic ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_GetTypeNameStatic ();

		private static string GetTypeNameStatic ()
		{
			Runtime.Validate (typeof(UIElement));
			return Marshal.PtrToStringAnsi (UIElement_GetTypeNameStatic ());
		}

		[Preserve]
		public UIElement () : this (Application.CurrentContext)
		{
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_UIElement (IntPtr context);

		[Preserve]
		public UIElement (Context context) : base (UrhoObjectFlag.Empty)
		{
			Runtime.Validate (typeof(UIElement));
			handle = UIElement_UIElement ((object)context == null ? IntPtr.Zero : context.Handle);
			Runtime.RegisterObject (this);
			OnUIElementCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_RegisterObject (IntPtr context);

		/// <summary>
		/// Register object factory.
		/// </summary>
		public new static void RegisterObject (Context context)
		{
			Runtime.Validate (typeof(UIElement));
			UIElement_RegisterObject ((object)context == null ? IntPtr.Zero : context.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_ApplyAttributes (IntPtr handle);

		/// <summary>
		/// Apply attribute changes that can not be applied immediately.
		/// </summary>
		public override void ApplyAttributes ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_ApplyAttributes (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_LoadXML (IntPtr handle, IntPtr source, bool setInstanceDefault);

		/// <summary>
		/// Load from XML data. Return true if successful.
		/// </summary>
		public override bool LoadXml (XmlElement source, bool setInstanceDefault = false)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_LoadXML (handle, (object)source == null ? IntPtr.Zero : source.Handle, setInstanceDefault);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_LoadXML0 (IntPtr handle, IntPtr source, IntPtr styleFile, bool setInstanceDefault);

		/// <summary>
		/// Load from XML data with style. Return true if successful.
		/// </summary>
		public virtual bool LoadXml (XmlElement source, Urho.Resources.XmlFile styleFile, bool setInstanceDefault = false)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_LoadXML0 (handle, (object)source == null ? IntPtr.Zero : source.Handle, (object)styleFile == null ? IntPtr.Zero : styleFile.Handle, setInstanceDefault);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_LoadChildXML (IntPtr handle, IntPtr childElem, IntPtr styleFile, bool setInstanceDefault);

		/// <summary>
		/// Create a child by loading from XML data with style. Returns the child element if successful, null if otherwise.
		/// </summary>
		public UIElement LoadChildXml (XmlElement childElem, Urho.Resources.XmlFile styleFile = null, bool setInstanceDefault = false)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<UIElement> (UIElement_LoadChildXML (handle, (object)childElem == null ? IntPtr.Zero : childElem.Handle, (object)styleFile == null ? IntPtr.Zero : styleFile.Handle, setInstanceDefault));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_SaveXML (IntPtr handle, IntPtr dest);

		/// <summary>
		/// Save as XML data. Return true if successful.
		/// </summary>
		public override bool SaveXml (XmlElement dest)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_SaveXML (handle, (object)dest == null ? IntPtr.Zero : dest.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_Update (IntPtr handle, float timeStep);

		/// <summary>
		/// Perform UI element update.
		/// </summary>
		public virtual void Update (float timeStep)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_Update (handle, timeStep);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsWithinScissor (IntPtr handle, ref Urho.IntRect currentScissor);

		/// <summary>
		/// Return whether is visible and inside a scissor rectangle and should be rendered.
		/// </summary>
		public virtual bool IsWithinScissor (Urho.IntRect currentScissor)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsWithinScissor (handle, ref currentScissor);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntVector2 UIElement_GetScreenPosition (IntPtr handle);

		/// <summary>
		/// Update and return screen position.
		/// </summary>
		private Urho.IntVector2 GetScreenPosition ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetScreenPosition (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_OnHover (IntPtr handle, ref Urho.IntVector2 position, ref Urho.IntVector2 screenPosition, int buttons, int qualifiers, IntPtr cursor);

		/// <summary>
		/// React to mouse hover.
		/// </summary>
		public virtual void OnHover (Urho.IntVector2 position, Urho.IntVector2 screenPosition, int buttons, int qualifiers, Cursor cursor)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_OnHover (handle, ref position, ref screenPosition, buttons, qualifiers, (object)cursor == null ? IntPtr.Zero : cursor.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_OnClickBegin (IntPtr handle, ref Urho.IntVector2 position, ref Urho.IntVector2 screenPosition, int button, int buttons, int qualifiers, IntPtr cursor);

		/// <summary>
		/// React to mouse click begin.
		/// </summary>
		public virtual void OnClickBegin (Urho.IntVector2 position, Urho.IntVector2 screenPosition, int button, int buttons, int qualifiers, Cursor cursor)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_OnClickBegin (handle, ref position, ref screenPosition, button, buttons, qualifiers, (object)cursor == null ? IntPtr.Zero : cursor.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_OnClickEnd (IntPtr handle, ref Urho.IntVector2 position, ref Urho.IntVector2 screenPosition, int button, int buttons, int qualifiers, IntPtr cursor, IntPtr beginElement);

		/// <summary>
		/// React to mouse click end.
		/// </summary>
		public virtual void OnClickEnd (Urho.IntVector2 position, Urho.IntVector2 screenPosition, int button, int buttons, int qualifiers, Cursor cursor, UIElement beginElement)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_OnClickEnd (handle, ref position, ref screenPosition, button, buttons, qualifiers, (object)cursor == null ? IntPtr.Zero : cursor.Handle, (object)beginElement == null ? IntPtr.Zero : beginElement.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_OnDoubleClick (IntPtr handle, ref Urho.IntVector2 position, ref Urho.IntVector2 screenPosition, int button, int buttons, int qualifiers, IntPtr cursor);

		/// <summary>
		/// React to double mouse click.
		/// </summary>
		public virtual void OnDoubleClick (Urho.IntVector2 position, Urho.IntVector2 screenPosition, int button, int buttons, int qualifiers, Cursor cursor)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_OnDoubleClick (handle, ref position, ref screenPosition, button, buttons, qualifiers, (object)cursor == null ? IntPtr.Zero : cursor.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_OnWheel (IntPtr handle, int delta, int buttons, int qualifiers);

		/// <summary>
		/// React to mouse wheel.
		/// </summary>
		public virtual void OnWheel (int delta, int buttons, int qualifiers)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_OnWheel (handle, delta, buttons, qualifiers);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_OnKey (IntPtr handle, int key, int buttons, int qualifiers);

		/// <summary>
		/// React to a key press.
		/// </summary>
		public virtual void OnKey (int key, int buttons, int qualifiers)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_OnKey (handle, key, buttons, qualifiers);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_OnTextInput (IntPtr handle, string text);

		/// <summary>
		/// React to text input event.
		/// </summary>
		public virtual void OnTextInput (string text)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_OnTextInput (handle, text);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_OnResize (IntPtr handle, ref Urho.IntVector2 newSize, ref Urho.IntVector2 delta);

		/// <summary>
		/// React to resize.
		/// </summary>
		public virtual void OnResize (Urho.IntVector2 newSize, Urho.IntVector2 delta)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_OnResize (handle, ref newSize, ref delta);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_OnPositionSet (IntPtr handle, ref Urho.IntVector2 newPosition);

		/// <summary>
		/// React to position change.
		/// </summary>
		public virtual void OnPositionSet (Urho.IntVector2 newPosition)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_OnPositionSet (handle, ref newPosition);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_OnSetEditable (IntPtr handle);

		/// <summary>
		/// React to editable status change.
		/// </summary>
		public virtual void OnSetEditable ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_OnSetEditable (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_OnIndentSet (IntPtr handle);

		/// <summary>
		/// React to indent change.
		/// </summary>
		public virtual void OnIndentSet ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_OnIndentSet (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntVector2 UIElement_ScreenToElement (IntPtr handle, ref Urho.IntVector2 screenPosition);

		/// <summary>
		/// Convert screen coordinates to element coordinates.
		/// </summary>
		public virtual Urho.IntVector2 ScreenToElement (Urho.IntVector2 screenPosition)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_ScreenToElement (handle, ref screenPosition);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntVector2 UIElement_ElementToScreen (IntPtr handle, ref Urho.IntVector2 position);

		/// <summary>
		/// Convert element coordinates to screen coordinates.
		/// </summary>
		public virtual Urho.IntVector2 ElementToScreen (Urho.IntVector2 position)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_ElementToScreen (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsWheelHandler (IntPtr handle);

		/// <summary>
		/// Return whether the element could handle wheel input.
		/// </summary>
		private bool IsWheelHandler ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsWheelHandler (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_LoadXML1_File (IntPtr handle, IntPtr source);

		/// <summary>
		/// Load from an XML file. Return true if successful.
		/// </summary>
		public bool LoadXml (File source)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_LoadXML1_File (handle, (object)source == null ? IntPtr.Zero : source.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_LoadXML1_MemoryBuffer (IntPtr handle, IntPtr source);

		/// <summary>
		/// Load from an XML file. Return true if successful.
		/// </summary>
		public bool LoadXml (MemoryBuffer source)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_LoadXML1_MemoryBuffer (handle, (object)source == null ? IntPtr.Zero : source.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_SaveXML2_File (IntPtr handle, IntPtr dest, string indentation);

		/// <summary>
		/// Save to an XML file. Return true if successful.
		/// </summary>
		public bool SaveXml (File dest, string indentation = "\t")
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_SaveXML2_File (handle, (object)dest == null ? IntPtr.Zero : dest.Handle, indentation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_SaveXML2_MemoryBuffer (IntPtr handle, IntPtr dest, string indentation);

		/// <summary>
		/// Save to an XML file. Return true if successful.
		/// </summary>
		public bool SaveXml (MemoryBuffer dest, string indentation = "\t")
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_SaveXML2_MemoryBuffer (handle, (object)dest == null ? IntPtr.Zero : dest.Handle, indentation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_FilterAttributes (IntPtr handle, IntPtr dest);

		/// <summary>
		/// Filter attributes in serialization process.
		/// </summary>
		public bool FilterAttributes (XmlElement dest)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_FilterAttributes (handle, (object)dest == null ? IntPtr.Zero : dest.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetName (IntPtr handle, string name);

		/// <summary>
		/// Set name.
		/// </summary>
		private void SetName (string name)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetName (handle, name);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetPosition (IntPtr handle, ref Urho.IntVector2 position);

		/// <summary>
		/// Set position.
		/// </summary>
		private void SetPosition (Urho.IntVector2 position)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetPosition (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetPosition3 (IntPtr handle, int x, int y);

		/// <summary>
		/// Set position.
		/// </summary>
		public void SetPosition (int x, int y)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetPosition3 (handle, x, y);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetSize (IntPtr handle, ref Urho.IntVector2 size);

		/// <summary>
		/// Set size.
		/// </summary>
		private void SetSize (Urho.IntVector2 size)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetSize (handle, ref size);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetSize4 (IntPtr handle, int width, int height);

		/// <summary>
		/// Set size.
		/// </summary>
		public void SetSize (int width, int height)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetSize4 (handle, width, height);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetWidth (IntPtr handle, int width);

		/// <summary>
		/// Set width only.
		/// </summary>
		private void SetWidth (int width)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetWidth (handle, width);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetHeight (IntPtr handle, int height);

		/// <summary>
		/// Set height only.
		/// </summary>
		private void SetHeight (int height)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetHeight (handle, height);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMinSize (IntPtr handle, ref Urho.IntVector2 minSize);

		/// <summary>
		/// Set minimum size.
		/// </summary>
		private void SetMinSize (Urho.IntVector2 minSize)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMinSize (handle, ref minSize);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMinSize5 (IntPtr handle, int width, int height);

		/// <summary>
		/// Set minimum size.
		/// </summary>
		public void SetMinSize (int width, int height)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMinSize5 (handle, width, height);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMinWidth (IntPtr handle, int width);

		/// <summary>
		/// Set minimum width.
		/// </summary>
		private void SetMinWidth (int width)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMinWidth (handle, width);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMinHeight (IntPtr handle, int height);

		/// <summary>
		/// Set minimum height.
		/// </summary>
		private void SetMinHeight (int height)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMinHeight (handle, height);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMaxSize (IntPtr handle, ref Urho.IntVector2 maxSize);

		/// <summary>
		/// Set maximum size.
		/// </summary>
		private void SetMaxSize (Urho.IntVector2 maxSize)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMaxSize (handle, ref maxSize);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMaxSize6 (IntPtr handle, int width, int height);

		/// <summary>
		/// Set maximum size.
		/// </summary>
		public void SetMaxSize (int width, int height)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMaxSize6 (handle, width, height);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMaxWidth (IntPtr handle, int width);

		/// <summary>
		/// Set maximum width.
		/// </summary>
		private void SetMaxWidth (int width)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMaxWidth (handle, width);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMaxHeight (IntPtr handle, int height);

		/// <summary>
		/// Set maximum height.
		/// </summary>
		private void SetMaxHeight (int height)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMaxHeight (handle, height);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetFixedSize (IntPtr handle, ref Urho.IntVector2 size);

		/// <summary>
		/// Set fixed size.
		/// </summary>
		public void SetFixedSize (Urho.IntVector2 size)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetFixedSize (handle, ref size);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetFixedSize7 (IntPtr handle, int width, int height);

		/// <summary>
		/// Set fixed size.
		/// </summary>
		public void SetFixedSize (int width, int height)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetFixedSize7 (handle, width, height);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetFixedWidth (IntPtr handle, int width);

		/// <summary>
		/// Set fixed width.
		/// </summary>
		public void SetFixedWidth (int width)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetFixedWidth (handle, width);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetFixedHeight (IntPtr handle, int height);

		/// <summary>
		/// Set fixed height.
		/// </summary>
		public void SetFixedHeight (int height)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetFixedHeight (handle, height);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetAlignment (IntPtr handle, HorizontalAlignment hAlign, VerticalAlignment vAlign);

		/// <summary>
		/// Set horizontal and vertical alignment.
		/// </summary>
		public void SetAlignment (HorizontalAlignment hAlign, VerticalAlignment vAlign)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetAlignment (handle, hAlign, vAlign);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetHorizontalAlignment (IntPtr handle, HorizontalAlignment align);

		/// <summary>
		/// Set horizontal alignment.
		/// </summary>
		private void SetHorizontalAlignment (HorizontalAlignment align)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetHorizontalAlignment (handle, align);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVerticalAlignment (IntPtr handle, VerticalAlignment align);

		/// <summary>
		/// Set vertical alignment.
		/// </summary>
		private void SetVerticalAlignment (VerticalAlignment align)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVerticalAlignment (handle, align);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetEnableAnchor (IntPtr handle, bool enable);

		/// <summary>
		/// Enable automatic positioning
		/// &
		/// sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.
		/// </summary>
		private void SetEnableAnchor (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetEnableAnchor (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMinAnchor (IntPtr handle, ref Urho.Vector2 anchor);

		/// <summary>
		/// Set minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.
		/// </summary>
		private void SetMinAnchor (Urho.Vector2 anchor)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMinAnchor (handle, ref anchor);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMinAnchor8 (IntPtr handle, float x, float y);

		/// <summary>
		/// Set minimum anchor.
		/// </summary>
		public void SetMinAnchor (float x, float y)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMinAnchor8 (handle, x, y);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMaxAnchor (IntPtr handle, ref Urho.Vector2 anchor);

		/// <summary>
		/// Set maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.
		/// </summary>
		private void SetMaxAnchor (Urho.Vector2 anchor)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMaxAnchor (handle, ref anchor);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMaxAnchor9 (IntPtr handle, float x, float y);

		/// <summary>
		/// Set maximum anchor.
		/// </summary>
		public void SetMaxAnchor (float x, float y)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMaxAnchor9 (handle, x, y);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMinOffset (IntPtr handle, ref Urho.IntVector2 offset);

		/// <summary>
		/// Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.
		/// </summary>
		private void SetMinOffset (Urho.IntVector2 offset)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMinOffset (handle, ref offset);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetMaxOffset (IntPtr handle, ref Urho.IntVector2 offset);

		/// <summary>
		/// Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.
		/// </summary>
		private void SetMaxOffset (Urho.IntVector2 offset)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetMaxOffset (handle, ref offset);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetPivot (IntPtr handle, ref Urho.Vector2 pivot);

		/// <summary>
		/// Set pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal
		/// &
		/// vertical alignment.
		/// </summary>
		private void SetPivot (Urho.Vector2 pivot)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetPivot (handle, ref pivot);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetPivot10 (IntPtr handle, float x, float y);

		/// <summary>
		/// Set pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal
		/// &
		/// vertical alignment.
		/// </summary>
		public void SetPivot (float x, float y)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetPivot10 (handle, x, y);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetClipBorder (IntPtr handle, ref Urho.IntRect rect);

		/// <summary>
		/// Set child element clipping border.
		/// </summary>
		private void SetClipBorder (Urho.IntRect rect)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetClipBorder (handle, ref rect);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetColor (IntPtr handle, ref Urho.Color color);

		/// <summary>
		/// Set color on all corners.
		/// </summary>
		public void SetColor (Urho.Color color)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetColor (handle, ref color);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetColor11 (IntPtr handle, Corner corner, ref Urho.Color color);

		/// <summary>
		/// Set color on one corner.
		/// </summary>
		public void SetColor (Corner corner, Urho.Color color)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetColor11 (handle, corner, ref color);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetPriority (IntPtr handle, int priority);

		/// <summary>
		/// Set priority.
		/// </summary>
		private void SetPriority (int priority)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetPriority (handle, priority);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetOpacity (IntPtr handle, float opacity);

		/// <summary>
		/// Set opacity.
		/// </summary>
		private void SetOpacity (float opacity)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetOpacity (handle, opacity);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetBringToFront (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether should be brought to front when focused.
		/// </summary>
		private void SetBringToFront (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetBringToFront (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetBringToBack (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether should be put to background when another element is focused.
		/// </summary>
		private void SetBringToBack (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetBringToBack (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetClipChildren (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether should clip child elements. Default false.
		/// </summary>
		private void SetClipChildren (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetClipChildren (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetSortChildren (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether should sort child elements according to priority. Default true.
		/// </summary>
		private void SetSortChildren (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetSortChildren (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetUseDerivedOpacity (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether parent elements' opacity affects opacity. Default true.
		/// </summary>
		private void SetUseDerivedOpacity (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetUseDerivedOpacity (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetEnabled (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether reacts to input. Default false, but is enabled by subclasses if applicable.
		/// </summary>
		private void SetEnabled (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetEnabled (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetDeepEnabled (IntPtr handle, bool enable);

		/// <summary>
		/// Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.
		/// </summary>
		public void SetDeepEnabled (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetDeepEnabled (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_ResetDeepEnabled (IntPtr handle);

		/// <summary>
		/// Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.
		/// </summary>
		public void ResetDeepEnabled ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_ResetDeepEnabled (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetEnabledRecursive (IntPtr handle, bool enable);

		/// <summary>
		/// Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.
		/// </summary>
		public void SetEnabledRecursive (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetEnabledRecursive (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetEditable (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether value is editable through input. Not applicable to all elements. Default true.
		/// </summary>
		private void SetEditable (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetEditable (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetFocus (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether is focused. Only one element can be focused at a time.
		/// </summary>
		public void SetFocus (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetFocus (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetSelected (IntPtr handle, bool enable);

		/// <summary>
		/// Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.
		/// </summary>
		private void SetSelected (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetSelected (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVisible (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether is visible. Visibility propagates to child elements.
		/// </summary>
		private void SetVisible (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVisible (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetFocusMode (IntPtr handle, FocusMode mode);

		/// <summary>
		/// Set focus mode.
		/// </summary>
		private void SetFocusMode (FocusMode mode)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetFocusMode (handle, mode);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetDragDropMode (IntPtr handle, uint mode);

		/// <summary>
		/// Set drag and drop flags.
		/// </summary>
		private void SetDragDropMode (uint mode)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetDragDropMode (handle, mode);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_SetStyle (IntPtr handle, string styleName, IntPtr file);

		/// <summary>
		/// Set style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.
		/// </summary>
		public bool SetStyle (string styleName, Urho.Resources.XmlFile file = null)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_SetStyle (handle, styleName, (object)file == null ? IntPtr.Zero : file.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_SetStyle12 (IntPtr handle, IntPtr element);

		/// <summary>
		/// Set style from an XML element. Return true if the style is applied successfully.
		/// </summary>
		public bool SetStyle (XmlElement element)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_SetStyle12 (handle, (object)element == null ? IntPtr.Zero : element.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_SetStyleAuto (IntPtr handle, IntPtr file);

		/// <summary>
		/// Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.
		/// </summary>
		public bool SetStyleAuto (Urho.Resources.XmlFile file = null)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_SetStyleAuto (handle, (object)file == null ? IntPtr.Zero : file.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetDefaultStyle (IntPtr handle, IntPtr style);

		/// <summary>
		/// Set default style file for later use by children elements.
		/// </summary>
		public void SetDefaultStyle (Urho.Resources.XmlFile style)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetDefaultStyle (handle, (object)style == null ? IntPtr.Zero : style.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetLayout (IntPtr handle, LayoutMode mode, int spacing, ref Urho.IntRect border);

		/// <summary>
		/// Set layout parameters.
		/// </summary>
		public void SetLayout (LayoutMode mode, int spacing, Urho.IntRect border)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetLayout (handle, mode, spacing, ref border);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetLayoutMode (IntPtr handle, LayoutMode mode);

		/// <summary>
		/// Set layout mode only.
		/// </summary>
		private void SetLayoutMode (LayoutMode mode)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetLayoutMode (handle, mode);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetLayoutSpacing (IntPtr handle, int spacing);

		/// <summary>
		/// Set layout spacing.
		/// </summary>
		private void SetLayoutSpacing (int spacing)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetLayoutSpacing (handle, spacing);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetLayoutBorder (IntPtr handle, ref Urho.IntRect border);

		/// <summary>
		/// Set layout border.
		/// </summary>
		private void SetLayoutBorder (Urho.IntRect border)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetLayoutBorder (handle, ref border);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetLayoutFlexScale (IntPtr handle, ref Urho.Vector2 scale);

		/// <summary>
		/// Set layout flex scale.
		/// </summary>
		private void SetLayoutFlexScale (Urho.Vector2 scale)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetLayoutFlexScale (handle, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetIndent (IntPtr handle, int indent);

		/// <summary>
		/// Set horizontal indentation.
		/// </summary>
		private void SetIndent (int indent)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetIndent (handle, indent);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetIndentSpacing (IntPtr handle, int indentSpacing);

		/// <summary>
		/// Set indent spacing (number of pixels per indentation level).
		/// </summary>
		private void SetIndentSpacing (int indentSpacing)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetIndentSpacing (handle, indentSpacing);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_UpdateLayout (IntPtr handle);

		/// <summary>
		/// Manually update layout. Should not be necessary in most cases, but is provided for completeness.
		/// </summary>
		public void UpdateLayout ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_UpdateLayout (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_DisableLayoutUpdate (IntPtr handle);

		/// <summary>
		/// Disable automatic layout update. Should only be used if there are performance problems.
		/// </summary>
		public void DisableLayoutUpdate ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_DisableLayoutUpdate (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_EnableLayoutUpdate (IntPtr handle);

		/// <summary>
		/// Enable automatic layout update.
		/// </summary>
		public void EnableLayoutUpdate ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_EnableLayoutUpdate (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_BringToFront (IntPtr handle);

		/// <summary>
		/// Bring UI element to front.
		/// </summary>
		public void BringToFront ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_BringToFront (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_CreateChild (IntPtr handle, int type, string name, uint index);

		/// <summary>
		/// Create and add a child element and return it.
		/// </summary>
		public UIElement CreateChild (StringHash type, string name = "", uint index = uint.MaxValue)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<UIElement> (UIElement_CreateChild (handle, type.Code, name, index));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_AddChild (IntPtr handle, IntPtr element);

		/// <summary>
		/// Add a child element.
		/// </summary>
		public void AddChild (UIElement element)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_AddChild (handle, (object)element == null ? IntPtr.Zero : element.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_InsertChild (IntPtr handle, uint index, IntPtr element);

		/// <summary>
		/// Insert a child element into a specific position in the child list.
		/// </summary>
		public void InsertChild (uint index, UIElement element)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_InsertChild (handle, index, (object)element == null ? IntPtr.Zero : element.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_RemoveChild (IntPtr handle, IntPtr element, uint index);

		/// <summary>
		/// Remove a child element. Starting search at specified index if provided.
		/// </summary>
		public void RemoveChild (UIElement element, uint index = 0)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_RemoveChild (handle, (object)element == null ? IntPtr.Zero : element.Handle, index);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_RemoveChildAtIndex (IntPtr handle, uint index);

		/// <summary>
		/// Remove a child element at index.
		/// </summary>
		public void RemoveChildAtIndex (uint index)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_RemoveChildAtIndex (handle, index);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_RemoveAllChildren (IntPtr handle);

		/// <summary>
		/// Remove all child elements.
		/// </summary>
		public void RemoveAllChildren ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_RemoveAllChildren (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_Remove (IntPtr handle);

		/// <summary>
		/// Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.
		/// </summary>
		public void Remove ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_Remove (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint UIElement_FindChild (IntPtr handle, IntPtr element);

		/// <summary>
		/// Find child index. Return M_MAX_UNSIGNED if not found.
		/// </summary>
		public uint FindChild (UIElement element)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_FindChild (handle, (object)element == null ? IntPtr.Zero : element.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetParent (IntPtr handle, IntPtr parent, uint index);

		/// <summary>
		/// Set parent element. Same as parent->InsertChild(index, this).
		/// </summary>
		public void SetParent (UIElement parent, uint index = uint.MaxValue)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetParent (handle, (object)parent == null ? IntPtr.Zero : parent.Handle, index);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_0 (IntPtr handle, int key, ref Vector3 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Vector3 value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_0 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_1 (IntPtr handle, int key, ref IntRect value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, IntRect value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_1 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_2 (IntPtr handle, int key, ref Color value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Color value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_2 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_3 (IntPtr handle, int key, ref Vector2 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Vector2 value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_3 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_4 (IntPtr handle, int key, ref Vector4 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Vector4 value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_4 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_5 (IntPtr handle, int key, ref IntVector2 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, IntVector2 value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_5 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_6 (IntPtr handle, int key, ref Quaternion value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Quaternion value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_6 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_7 (IntPtr handle, int key, ref Matrix4 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Matrix4 value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_7 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_8 (IntPtr handle, int key, ref Matrix3x4 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Matrix3x4 value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_8 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_9 (IntPtr handle, int key, int value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, int value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_9 (handle, key.Code, value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_10 (IntPtr handle, int key, float value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, float value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_10 (handle, key.Code, value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_11 (IntPtr handle, int key, string value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, string value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_11 (handle, key.Code, value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetVar_12 (IntPtr handle, int key, bool value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, bool value)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetVar_12 (handle, key.Code, value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetInternal (IntPtr handle, bool enable);

		/// <summary>
		/// Mark as internally (programmatically) created. Used when an element composes itself out of child elements.
		/// </summary>
		private void SetInternal (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetInternal (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetTraversalMode (IntPtr handle, TraversalMode traversalMode);

		/// <summary>
		/// Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.
		/// </summary>
		private void SetTraversalMode (TraversalMode traversalMode)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetTraversalMode (handle, traversalMode);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetElementEventSender (IntPtr handle, bool flag);

		/// <summary>
		/// Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.
		/// </summary>
		public void SetElementEventSender (bool flag)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetElementEventSender (handle, flag);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_AddTag (IntPtr handle, string tag);

		/// <summary>
		/// Add a tag.
		/// </summary>
		public void AddTag (string tag)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_AddTag (handle, tag);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_RemoveTag (IntPtr handle, string tag);

		/// <summary>
		/// Remove specific tag. Return true if existed.
		/// </summary>
		public bool RemoveTag (string tag)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_RemoveTag (handle, tag);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_RemoveAllTags (IntPtr handle);

		/// <summary>
		/// Remove all tags.
		/// </summary>
		public void RemoveAllTags ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_RemoveAllTags (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_GetName (IntPtr handle);

		/// <summary>
		/// Return name.
		/// </summary>
		private string GetName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (UIElement_GetName (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntVector2 UIElement_GetPosition (IntPtr handle);

		/// <summary>
		/// Return position.
		/// </summary>
		private Urho.IntVector2 GetPosition ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetPosition (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntVector2 UIElement_GetSize (IntPtr handle);

		/// <summary>
		/// Return size.
		/// </summary>
		private Urho.IntVector2 GetSize ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetSize (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetWidth (IntPtr handle);

		/// <summary>
		/// Return width.
		/// </summary>
		private int GetWidth ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetWidth (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetHeight (IntPtr handle);

		/// <summary>
		/// Return height.
		/// </summary>
		private int GetHeight ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetHeight (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntVector2 UIElement_GetMinSize (IntPtr handle);

		/// <summary>
		/// Return minimum size.
		/// </summary>
		private Urho.IntVector2 GetMinSize ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetMinSize (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetMinWidth (IntPtr handle);

		/// <summary>
		/// Return minimum width.
		/// </summary>
		private int GetMinWidth ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetMinWidth (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetMinHeight (IntPtr handle);

		/// <summary>
		/// Return minimum height.
		/// </summary>
		private int GetMinHeight ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetMinHeight (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntVector2 UIElement_GetMaxSize (IntPtr handle);

		/// <summary>
		/// Return maximum size.
		/// </summary>
		private Urho.IntVector2 GetMaxSize ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetMaxSize (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetMaxWidth (IntPtr handle);

		/// <summary>
		/// Return minimum width.
		/// </summary>
		private int GetMaxWidth ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetMaxWidth (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetMaxHeight (IntPtr handle);

		/// <summary>
		/// Return minimum height.
		/// </summary>
		private int GetMaxHeight ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetMaxHeight (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsFixedSize (IntPtr handle);

		/// <summary>
		/// Return true if size is fixed.
		/// </summary>
		private bool IsFixedSize ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsFixedSize (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsFixedWidth (IntPtr handle);

		/// <summary>
		/// Return true if width is fixed.
		/// </summary>
		private bool IsFixedWidth ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsFixedWidth (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsFixedHeight (IntPtr handle);

		/// <summary>
		/// Return true if height is fixed.
		/// </summary>
		private bool IsFixedHeight ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsFixedHeight (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntVector2 UIElement_GetChildOffset (IntPtr handle);

		/// <summary>
		/// Return child element offset.
		/// </summary>
		private Urho.IntVector2 GetChildOffset ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetChildOffset (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern HorizontalAlignment UIElement_GetHorizontalAlignment (IntPtr handle);

		/// <summary>
		/// Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.
		/// </summary>
		private HorizontalAlignment GetHorizontalAlignment ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetHorizontalAlignment (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern VerticalAlignment UIElement_GetVerticalAlignment (IntPtr handle);

		/// <summary>
		/// Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.
		/// </summary>
		private VerticalAlignment GetVerticalAlignment ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetVerticalAlignment (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_GetEnableAnchor (IntPtr handle);

		/// <summary>
		/// Return whether anchor positioning
		/// &
		/// sizing is enabled.
		/// </summary>
		private bool GetEnableAnchor ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetEnableAnchor (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Vector2 UIElement_GetMinAnchor (IntPtr handle);

		/// <summary>
		/// Return minimum anchor.
		/// </summary>
		private Urho.Vector2 GetMinAnchor ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetMinAnchor (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Vector2 UIElement_GetMaxAnchor (IntPtr handle);

		/// <summary>
		/// Return maximum anchor.
		/// </summary>
		private Urho.Vector2 GetMaxAnchor ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetMaxAnchor (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntVector2 UIElement_GetMinOffset (IntPtr handle);

		private Urho.IntVector2 GetMinOffset ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetMinOffset (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntVector2 UIElement_GetMaxOffset (IntPtr handle);

		private Urho.IntVector2 GetMaxOffset ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetMaxOffset (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Vector2 UIElement_GetPivot (IntPtr handle);

		/// <summary>
		/// Return pivot.
		/// </summary>
		private Urho.Vector2 GetPivot ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetPivot (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntRect UIElement_GetClipBorder (IntPtr handle);

		/// <summary>
		/// Return child element clipping border.
		/// </summary>
		private Urho.IntRect GetClipBorder ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetClipBorder (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Color UIElement_GetColor (IntPtr handle, Corner corner);

		/// <summary>
		/// Return corner color.
		/// </summary>
		public Urho.Color GetColor (Corner corner)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetColor (handle, corner);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetPriority (IntPtr handle);

		/// <summary>
		/// Return priority.
		/// </summary>
		private int GetPriority ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetPriority (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float UIElement_GetOpacity (IntPtr handle);

		/// <summary>
		/// Return opacity.
		/// </summary>
		private float GetOpacity ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetOpacity (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float UIElement_GetDerivedOpacity (IntPtr handle);

		/// <summary>
		/// Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.
		/// </summary>
		private float GetDerivedOpacity ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetDerivedOpacity (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_GetBringToFront (IntPtr handle);

		/// <summary>
		/// Return whether should be brought to front when focused.
		/// </summary>
		private bool GetBringToFront ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetBringToFront (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_GetBringToBack (IntPtr handle);

		/// <summary>
		/// Return whether should be put to background when another element is focused.
		/// </summary>
		private bool GetBringToBack ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetBringToBack (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_GetClipChildren (IntPtr handle);

		/// <summary>
		/// Return whether should clip child elements.
		/// </summary>
		private bool GetClipChildren ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetClipChildren (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_GetSortChildren (IntPtr handle);

		/// <summary>
		/// Return whether should sort child elements according to priority.
		/// </summary>
		private bool GetSortChildren ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetSortChildren (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_GetUseDerivedOpacity (IntPtr handle);

		/// <summary>
		/// Return whether parent elements' opacity affects opacity.
		/// </summary>
		private bool GetUseDerivedOpacity ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetUseDerivedOpacity (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_HasFocus (IntPtr handle);

		/// <summary>
		/// Return whether has focus.
		/// </summary>
		public bool HasFocus ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_HasFocus (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsChildOf (IntPtr handle, IntPtr element);

		/// <summary>
		/// Return whether is a direct or indirect child of specified element.
		/// </summary>
		public bool IsChildOf (UIElement element)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsChildOf (handle, (object)element == null ? IntPtr.Zero : element.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsEnabled (IntPtr handle);

		/// <summary>
		/// Return whether reacts to input.
		/// </summary>
		private bool IsEnabled ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsEnabled (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsEnabledSelf (IntPtr handle);

		/// <summary>
		/// Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.
		/// </summary>
		private bool IsEnabledSelf ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsEnabledSelf (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsEditable (IntPtr handle);

		/// <summary>
		/// Return whether value is editable through input.
		/// </summary>
		private bool IsEditable ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsEditable (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsSelected (IntPtr handle);

		/// <summary>
		/// Return whether is selected. Actual meaning is element dependent.
		/// </summary>
		private bool IsSelected ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsSelected (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsVisible (IntPtr handle);

		/// <summary>
		/// Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.
		/// </summary>
		private bool IsVisible ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsVisible (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsVisibleEffective (IntPtr handle);

		/// <summary>
		/// Return whether element is effectively visible (parent element chain is visible.)
		/// </summary>
		private bool IsVisibleEffective ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsVisibleEffective (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsHovering (IntPtr handle);

		/// <summary>
		/// Return whether the cursor is hovering on this element.
		/// </summary>
		private bool IsHovering ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsHovering (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsInternal (IntPtr handle);

		/// <summary>
		/// Return whether is internally created.
		/// </summary>
		private bool IsInternal ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsInternal (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_HasColorGradient (IntPtr handle);

		/// <summary>
		/// Return whether has different color in at least one corner.
		/// </summary>
		public bool HasColorGradient ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_HasColorGradient (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern FocusMode UIElement_GetFocusMode (IntPtr handle);

		/// <summary>
		/// Return focus mode.
		/// </summary>
		private FocusMode GetFocusMode ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetFocusMode (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint UIElement_GetDragDropMode (IntPtr handle);

		/// <summary>
		/// Return drag and drop flags.
		/// </summary>
		private uint GetDragDropMode ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetDragDropMode (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_GetAppliedStyle (IntPtr handle);

		/// <summary>
		/// Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).
		/// </summary>
		private string GetAppliedStyle ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (UIElement_GetAppliedStyle (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_GetDefaultStyle (IntPtr handle, bool recursiveUp);

		/// <summary>
		/// Return default style.
		/// </summary>
		public Urho.Resources.XmlFile GetDefaultStyle (bool recursiveUp = true)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Urho.Resources.XmlFile> (UIElement_GetDefaultStyle (handle, recursiveUp));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern LayoutMode UIElement_GetLayoutMode (IntPtr handle);

		/// <summary>
		/// Return layout mode.
		/// </summary>
		private LayoutMode GetLayoutMode ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetLayoutMode (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetLayoutSpacing (IntPtr handle);

		/// <summary>
		/// Return layout spacing.
		/// </summary>
		private int GetLayoutSpacing ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetLayoutSpacing (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntRect UIElement_GetLayoutBorder (IntPtr handle);

		/// <summary>
		/// Return layout border.
		/// </summary>
		private Urho.IntRect GetLayoutBorder ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetLayoutBorder (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Vector2 UIElement_GetLayoutFlexScale (IntPtr handle);

		/// <summary>
		/// Return layout flex scale.
		/// </summary>
		private Urho.Vector2 GetLayoutFlexScale ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetLayoutFlexScale (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint UIElement_GetNumChildren (IntPtr handle, bool recursive);

		/// <summary>
		/// Return number of child elements.
		/// </summary>
		public uint GetNumChildren (bool recursive = false)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetNumChildren (handle, recursive);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_GetChild (IntPtr handle, uint index);

		/// <summary>
		/// Return child element by index.
		/// </summary>
		public UIElement GetChild (uint index)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<UIElement> (UIElement_GetChild (handle, index));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_GetChild13 (IntPtr handle, string name, bool recursive);

		/// <summary>
		/// Return child element by name.
		/// </summary>
		public UIElement GetChild (string name, bool recursive = false)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<UIElement> (UIElement_GetChild13 (handle, name, recursive));
		}

		private IReadOnlyList<UIElement> _GetChildren_cache;

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_GetChildren (IntPtr handle);

		/// <summary>
		/// Return immediate child elements.
		/// </summary>
		private IReadOnlyList<UIElement> GetChildren ()
		{
			Runtime.ValidateRefCounted (this);
			return _GetChildren_cache != null ? _GetChildren_cache : _GetChildren_cache = Runtime.CreateVectorSharedPtrProxy<UIElement> (UIElement_GetChildren (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_GetParent (IntPtr handle);

		/// <summary>
		/// Return parent element.
		/// </summary>
		private UIElement GetParent ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<UIElement> (UIElement_GetParent (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_GetRoot (IntPtr handle);

		/// <summary>
		/// Return root element.
		/// </summary>
		private UIElement GetRoot ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<UIElement> (UIElement_GetRoot (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Color UIElement_GetDerivedColor (IntPtr handle);

		/// <summary>
		/// Return derived color. Only valid when no gradient.
		/// </summary>
		private Urho.Color GetDerivedColor ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetDerivedColor (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_HasTag (IntPtr handle, string tag);

		/// <summary>
		/// Return whether element is tagged by a specific tag.
		/// </summary>
		public bool HasTag (string tag)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_HasTag (handle, tag);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetDragButtonCombo (IntPtr handle);

		/// <summary>
		/// Return the drag button combo if this element is being dragged.
		/// </summary>
		private int GetDragButtonCombo ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetDragButtonCombo (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint UIElement_GetDragButtonCount (IntPtr handle);

		/// <summary>
		/// Return the number of buttons dragging this element.
		/// </summary>
		private uint GetDragButtonCount ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetDragButtonCount (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsInside (IntPtr handle, ref Urho.IntVector2 position, bool isScreen);

		/// <summary>
		/// Return whether a point (either in element or screen coordinates) is inside the element.
		/// </summary>
		public bool IsInside (Urho.IntVector2 position, bool isScreen)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsInside (handle, ref position, isScreen);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsInsideCombined (IntPtr handle, ref Urho.IntVector2 position, bool isScreen);

		/// <summary>
		/// Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.
		/// </summary>
		public bool IsInsideCombined (Urho.IntVector2 position, bool isScreen)
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsInsideCombined (handle, ref position, isScreen);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntRect UIElement_GetCombinedScreenRect (IntPtr handle);

		/// <summary>
		/// Return combined screen coordinate rect of element and its children.
		/// </summary>
		private IntRect GetCombinedScreenRect ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetCombinedScreenRect (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SortChildren (IntPtr handle);

		/// <summary>
		/// Sort child elements if sorting enabled and order dirty. Called by UI.
		/// </summary>
		public void SortChildren ()
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SortChildren (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetLayoutElementMaxSize (IntPtr handle);

		/// <summary>
		/// Return maximum layout element size in the layout direction. Only valid after layout has been calculated. Used internally by UI for optimizations.
		/// </summary>
		private int GetLayoutElementMaxSize ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetLayoutElementMaxSize (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetIndent (IntPtr handle);

		/// <summary>
		/// Return horizontal indentation.
		/// </summary>
		private int GetIndent ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetIndent (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetIndentSpacing (IntPtr handle);

		/// <summary>
		/// Return indent spacing (number of pixels per indentation level).
		/// </summary>
		private int GetIndentSpacing ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetIndentSpacing (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int UIElement_GetIndentWidth (IntPtr handle);

		/// <summary>
		/// Return indent width in pixels.
		/// </summary>
		private int GetIndentWidth ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetIndentWidth (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetChildOffset (IntPtr handle, ref Urho.IntVector2 offset);

		/// <summary>
		/// Set child offset.
		/// </summary>
		private void SetChildOffset (Urho.IntVector2 offset)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetChildOffset (handle, ref offset);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void UIElement_SetHovering (IntPtr handle, bool enable);

		/// <summary>
		/// Set hovering state.
		/// </summary>
		private void SetHovering (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			UIElement_SetHovering (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Color UIElement_GetColorAttr (IntPtr handle);

		/// <summary>
		/// Return color attribute. Uses just the top-left color.
		/// </summary>
		private Urho.Color GetColorAttr ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetColorAttr (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern TraversalMode UIElement_GetTraversalMode (IntPtr handle);

		/// <summary>
		/// Return traversal mode for rendering.
		/// </summary>
		private TraversalMode GetTraversalMode ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetTraversalMode (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool UIElement_IsElementEventSender (IntPtr handle);

		/// <summary>
		/// Return whether element should send child added / removed events by itself. If false, defers to parent element.
		/// </summary>
		public bool IsElementEventSender ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_IsElementEventSender (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr UIElement_GetElementEventSender (IntPtr handle);

		/// <summary>
		/// Get element which should send child added / removed events.
		/// </summary>
		private UIElement GetElementEventSender ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<UIElement> (UIElement_GetElementEventSender (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.IntVector2 UIElement_GetEffectiveMinSize (IntPtr handle);

		/// <summary>
		/// Return effective minimum size, also considering layout. Used internally.
		/// </summary>
		private Urho.IntVector2 GetEffectiveMinSize ()
		{
			Runtime.ValidateRefCounted (this);
			return UIElement_GetEffectiveMinSize (handle);
		}

		public override StringHash Type {
			get {
				return UrhoGetType ();
			}
		}

		public override string TypeName {
			get {
				return GetTypeName ();
			}
		}

		[Preserve]
		public new static StringHash TypeStatic {
			get {
				return GetTypeStatic ();
			}
		}

		public new static string TypeNameStatic {
			get {
				return GetTypeNameStatic ();
			}
		}

		/// <summary>
		/// Update and return screen position.
		/// </summary>
		public virtual Urho.IntVector2 ScreenPosition {
			get {
				return GetScreenPosition ();
			}
		}

		/// <summary>
		/// Return whether the element could handle wheel input.
		/// </summary>
		public virtual bool WheelHandler {
			get {
				return IsWheelHandler ();
			}
		}

		/// <summary>
		/// Return name.
		/// Or
		/// Set name.
		/// </summary>
		public string Name {
			get {
				return GetName ();
			}
			set {
				SetName (value);
			}
		}

		/// <summary>
		/// Return position.
		/// Or
		/// Set position.
		/// </summary>
		public Urho.IntVector2 Position {
			get {
				return GetPosition ();
			}
			set {
				SetPosition (value);
			}
		}

		/// <summary>
		/// Return size.
		/// Or
		/// Set size.
		/// </summary>
		public Urho.IntVector2 Size {
			get {
				return GetSize ();
			}
			set {
				SetSize (value);
			}
		}

		/// <summary>
		/// Return width.
		/// Or
		/// Set width only.
		/// </summary>
		public int Width {
			get {
				return GetWidth ();
			}
			set {
				SetWidth (value);
			}
		}

		/// <summary>
		/// Return height.
		/// Or
		/// Set height only.
		/// </summary>
		public int Height {
			get {
				return GetHeight ();
			}
			set {
				SetHeight (value);
			}
		}

		/// <summary>
		/// Return minimum size.
		/// Or
		/// Set minimum size.
		/// </summary>
		public Urho.IntVector2 MinSize {
			get {
				return GetMinSize ();
			}
			set {
				SetMinSize (value);
			}
		}

		/// <summary>
		/// Return minimum width.
		/// Or
		/// Set minimum width.
		/// </summary>
		public int MinWidth {
			get {
				return GetMinWidth ();
			}
			set {
				SetMinWidth (value);
			}
		}

		/// <summary>
		/// Return minimum height.
		/// Or
		/// Set minimum height.
		/// </summary>
		public int MinHeight {
			get {
				return GetMinHeight ();
			}
			set {
				SetMinHeight (value);
			}
		}

		/// <summary>
		/// Return maximum size.
		/// Or
		/// Set maximum size.
		/// </summary>
		public Urho.IntVector2 MaxSize {
			get {
				return GetMaxSize ();
			}
			set {
				SetMaxSize (value);
			}
		}

		/// <summary>
		/// Return minimum width.
		/// Or
		/// Set maximum width.
		/// </summary>
		public int MaxWidth {
			get {
				return GetMaxWidth ();
			}
			set {
				SetMaxWidth (value);
			}
		}

		/// <summary>
		/// Return minimum height.
		/// Or
		/// Set maximum height.
		/// </summary>
		public int MaxHeight {
			get {
				return GetMaxHeight ();
			}
			set {
				SetMaxHeight (value);
			}
		}

		/// <summary>
		/// Return true if size is fixed.
		/// </summary>
		public bool FixedSize {
			get {
				return IsFixedSize ();
			}
		}

		/// <summary>
		/// Return true if width is fixed.
		/// </summary>
		public bool FixedWidth {
			get {
				return IsFixedWidth ();
			}
		}

		/// <summary>
		/// Return true if height is fixed.
		/// </summary>
		public bool FixedHeight {
			get {
				return IsFixedHeight ();
			}
		}

		/// <summary>
		/// Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.
		/// Or
		/// Set horizontal alignment.
		/// </summary>
		public HorizontalAlignment HorizontalAlignment {
			get {
				return GetHorizontalAlignment ();
			}
			set {
				SetHorizontalAlignment (value);
			}
		}

		/// <summary>
		/// Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.
		/// Or
		/// Set vertical alignment.
		/// </summary>
		public VerticalAlignment VerticalAlignment {
			get {
				return GetVerticalAlignment ();
			}
			set {
				SetVerticalAlignment (value);
			}
		}

		/// <summary>
		/// Return whether anchor positioning
		/// &
		/// sizing is enabled.
		/// Or
		/// Enable automatic positioning
		/// &
		/// sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.
		/// </summary>
		public bool EnableAnchor {
			get {
				return GetEnableAnchor ();
			}
			set {
				SetEnableAnchor (value);
			}
		}

		/// <summary>
		/// Return minimum anchor.
		/// Or
		/// Set minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.
		/// </summary>
		public Urho.Vector2 MinAnchor {
			get {
				return GetMinAnchor ();
			}
			set {
				SetMinAnchor (value);
			}
		}

		/// <summary>
		/// Return maximum anchor.
		/// Or
		/// Set maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.
		/// </summary>
		public Urho.Vector2 MaxAnchor {
			get {
				return GetMaxAnchor ();
			}
			set {
				SetMaxAnchor (value);
			}
		}

		/// <summary>
		/// Or
		/// Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.
		/// </summary>
		public Urho.IntVector2 MinOffset {
			get {
				return GetMinOffset ();
			}
			set {
				SetMinOffset (value);
			}
		}

		/// <summary>
		/// Or
		/// Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.
		/// </summary>
		public Urho.IntVector2 MaxOffset {
			get {
				return GetMaxOffset ();
			}
			set {
				SetMaxOffset (value);
			}
		}

		/// <summary>
		/// Return pivot.
		/// Or
		/// Set pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal
		/// &
		/// vertical alignment.
		/// </summary>
		public Urho.Vector2 Pivot {
			get {
				return GetPivot ();
			}
			set {
				SetPivot (value);
			}
		}

		/// <summary>
		/// Return child element clipping border.
		/// Or
		/// Set child element clipping border.
		/// </summary>
		public Urho.IntRect ClipBorder {
			get {
				return GetClipBorder ();
			}
			set {
				SetClipBorder (value);
			}
		}

		/// <summary>
		/// Return priority.
		/// Or
		/// Set priority.
		/// </summary>
		public int Priority {
			get {
				return GetPriority ();
			}
			set {
				SetPriority (value);
			}
		}

		/// <summary>
		/// Return opacity.
		/// Or
		/// Set opacity.
		/// </summary>
		public float Opacity {
			get {
				return GetOpacity ();
			}
			set {
				SetOpacity (value);
			}
		}

		/// <summary>
		/// Return whether should be brought to front when focused.
		/// Or
		/// Set whether should be brought to front when focused.
		/// </summary>
		public bool BringToFrontOnFocus {
			get {
				return GetBringToFront ();
			}
			set {
				SetBringToFront (value);
			}
		}

		/// <summary>
		/// Return whether should be put to background when another element is focused.
		/// Or
		/// Set whether should be put to background when another element is focused.
		/// </summary>
		public bool BringToBackOnFocus {
			get {
				return GetBringToBack ();
			}
			set {
				SetBringToBack (value);
			}
		}

		/// <summary>
		/// Return whether should clip child elements.
		/// Or
		/// Set whether should clip child elements. Default false.
		/// </summary>
		public bool ClipChildren {
			get {
				return GetClipChildren ();
			}
			set {
				SetClipChildren (value);
			}
		}

		/// <summary>
		/// Return whether should sort child elements according to priority.
		/// Or
		/// Set whether should sort child elements according to priority. Default true.
		/// </summary>
		public bool ShouldSortChildren {
			get {
				return GetSortChildren ();
			}
			set {
				SetSortChildren (value);
			}
		}

		/// <summary>
		/// Return whether parent elements' opacity affects opacity.
		/// Or
		/// Set whether parent elements' opacity affects opacity. Default true.
		/// </summary>
		public bool UseDerivedOpacity {
			get {
				return GetUseDerivedOpacity ();
			}
			set {
				SetUseDerivedOpacity (value);
			}
		}

		/// <summary>
		/// Return whether reacts to input.
		/// Or
		/// Set whether reacts to input. Default false, but is enabled by subclasses if applicable.
		/// </summary>
		public bool Enabled {
			get {
				return IsEnabled ();
			}
			set {
				SetEnabled (value);
			}
		}

		/// <summary>
		/// Return whether value is editable through input.
		/// Or
		/// Set whether value is editable through input. Not applicable to all elements. Default true.
		/// </summary>
		public bool Editable {
			get {
				return IsEditable ();
			}
			set {
				SetEditable (value);
			}
		}

		/// <summary>
		/// Return whether is selected. Actual meaning is element dependent.
		/// Or
		/// Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.
		/// </summary>
		public bool Selected {
			get {
				return IsSelected ();
			}
			set {
				SetSelected (value);
			}
		}

		/// <summary>
		/// Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.
		/// Or
		/// Set whether is visible. Visibility propagates to child elements.
		/// </summary>
		public bool Visible {
			get {
				return IsVisible ();
			}
			set {
				SetVisible (value);
			}
		}

		/// <summary>
		/// Return focus mode.
		/// Or
		/// Set focus mode.
		/// </summary>
		public FocusMode FocusMode {
			get {
				return GetFocusMode ();
			}
			set {
				SetFocusMode (value);
			}
		}

		/// <summary>
		/// Return drag and drop flags.
		/// Or
		/// Set drag and drop flags.
		/// </summary>
		public uint DragDropMode {
			get {
				return GetDragDropMode ();
			}
			set {
				SetDragDropMode (value);
			}
		}

		/// <summary>
		/// Return layout mode.
		/// Or
		/// Set layout mode only.
		/// </summary>
		public LayoutMode LayoutMode {
			get {
				return GetLayoutMode ();
			}
			set {
				SetLayoutMode (value);
			}
		}

		/// <summary>
		/// Return layout spacing.
		/// Or
		/// Set layout spacing.
		/// </summary>
		public int LayoutSpacing {
			get {
				return GetLayoutSpacing ();
			}
			set {
				SetLayoutSpacing (value);
			}
		}

		/// <summary>
		/// Return layout border.
		/// Or
		/// Set layout border.
		/// </summary>
		public Urho.IntRect LayoutBorder {
			get {
				return GetLayoutBorder ();
			}
			set {
				SetLayoutBorder (value);
			}
		}

		/// <summary>
		/// Return layout flex scale.
		/// Or
		/// Set layout flex scale.
		/// </summary>
		public Urho.Vector2 LayoutFlexScale {
			get {
				return GetLayoutFlexScale ();
			}
			set {
				SetLayoutFlexScale (value);
			}
		}

		/// <summary>
		/// Return horizontal indentation.
		/// Or
		/// Set horizontal indentation.
		/// </summary>
		public int Indent {
			get {
				return GetIndent ();
			}
			set {
				SetIndent (value);
			}
		}

		/// <summary>
		/// Return indent spacing (number of pixels per indentation level).
		/// Or
		/// Set indent spacing (number of pixels per indentation level).
		/// </summary>
		public int IndentSpacing {
			get {
				return GetIndentSpacing ();
			}
			set {
				SetIndentSpacing (value);
			}
		}

		/// <summary>
		/// Return whether is internally created.
		/// Or
		/// Mark as internally (programmatically) created. Used when an element composes itself out of child elements.
		/// </summary>
		public bool Internal {
			get {
				return IsInternal ();
			}
			set {
				SetInternal (value);
			}
		}

		/// <summary>
		/// Return traversal mode for rendering.
		/// Or
		/// Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.
		/// </summary>
		public TraversalMode TraversalMode {
			get {
				return GetTraversalMode ();
			}
			set {
				SetTraversalMode (value);
			}
		}

		/// <summary>
		/// Get element which should send child added / removed events.
		/// </summary>
		public UIElement ElementEventSender {
			get {
				return GetElementEventSender ();
			}
		}

		/// <summary>
		/// Return child element offset.
		/// Or
		/// Set child offset.
		/// </summary>
		public Urho.IntVector2 ChildOffset {
			get {
				return GetChildOffset ();
			}
			set {
				SetChildOffset (value);
			}
		}

		/// <summary>
		/// Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.
		/// </summary>
		public float DerivedOpacity {
			get {
				return GetDerivedOpacity ();
			}
		}

		/// <summary>
		/// Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.
		/// </summary>
		public bool EnabledSelf {
			get {
				return IsEnabledSelf ();
			}
		}

		/// <summary>
		/// Return whether element is effectively visible (parent element chain is visible.)
		/// </summary>
		public bool VisibleEffective {
			get {
				return IsVisibleEffective ();
			}
		}

		/// <summary>
		/// Return whether the cursor is hovering on this element.
		/// Or
		/// Set hovering state.
		/// </summary>
		public bool Hovering {
			get {
				return IsHovering ();
			}
			set {
				SetHovering (value);
			}
		}

		/// <summary>
		/// Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).
		/// </summary>
		public string AppliedStyle {
			get {
				return GetAppliedStyle ();
			}
		}

		/// <summary>
		/// Return immediate child elements.
		/// </summary>
		public IReadOnlyList<UIElement> Children {
			get {
				return GetChildren ();
			}
		}

		/// <summary>
		/// Return parent element.
		/// </summary>
		public UIElement Parent {
			get {
				return GetParent ();
			}
		}

		/// <summary>
		/// Return root element.
		/// </summary>
		public UIElement Root {
			get {
				return GetRoot ();
			}
		}

		/// <summary>
		/// Return derived color. Only valid when no gradient.
		/// </summary>
		public Urho.Color DerivedColor {
			get {
				return GetDerivedColor ();
			}
		}

		/// <summary>
		/// Return the drag button combo if this element is being dragged.
		/// </summary>
		public int DragButtonCombo {
			get {
				return GetDragButtonCombo ();
			}
		}

		/// <summary>
		/// Return the number of buttons dragging this element.
		/// </summary>
		public uint DragButtonCount {
			get {
				return GetDragButtonCount ();
			}
		}

		/// <summary>
		/// Return combined screen coordinate rect of element and its children.
		/// </summary>
		public IntRect CombinedScreenRect {
			get {
				return GetCombinedScreenRect ();
			}
		}

		/// <summary>
		/// Return maximum layout element size in the layout direction. Only valid after layout has been calculated. Used internally by UI for optimizations.
		/// </summary>
		public int LayoutElementMaxSize {
			get {
				return GetLayoutElementMaxSize ();
			}
		}

		/// <summary>
		/// Return indent width in pixels.
		/// </summary>
		public int IndentWidth {
			get {
				return GetIndentWidth ();
			}
		}

		/// <summary>
		/// Return color attribute. Uses just the top-left color.
		/// </summary>
		public Urho.Color ColorAttr {
			get {
				return GetColorAttr ();
			}
		}

		/// <summary>
		/// Return effective minimum size, also considering layout. Used internally.
		/// </summary>
		public Urho.IntVector2 EffectiveMinSize {
			get {
				return GetEffectiveMinSize ();
			}
		}
	}
}
