// WARNING - AUTOGENERATED - DO NOT EDIT
// 
// Generated using `sharpie urho`
// 
// Node.cs
// 
// Copyright 2015 Xamarin Inc. All rights reserved.

using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using Urho.Urho2D;
using Urho.Gui;
using Urho.Resources;
using Urho.IO;
using Urho.Navigation;
using Urho.Network;

namespace Urho
{
	/// <summary>
	/// %Scene node that may contain components and child nodes.
	/// </summary>
	public unsafe partial class Node : Animatable
	{
		unsafe partial void OnNodeCreated ();

		[Preserve]
		public Node (IntPtr handle) : base (handle)
		{
			OnNodeCreated ();
		}

		[Preserve]
		protected Node (UrhoObjectFlag emptyFlag) : base (emptyFlag)
		{
			OnNodeCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Node_GetType (IntPtr handle);

		private StringHash GetType ()
		{
			Runtime.ValidateRefCounted (this);
			return new StringHash (Node_GetType (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetTypeName (IntPtr handle);

		private string GetTypeName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (Node_GetTypeName (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Node_GetTypeStatic ();

		private static StringHash GetTypeStatic ()
		{
			Runtime.Validate (typeof(Node));
			return new StringHash (Node_GetTypeStatic ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetTypeNameStatic ();

		private static string GetTypeNameStatic ()
		{
			Runtime.Validate (typeof(Node));
			return Marshal.PtrToStringAnsi (Node_GetTypeNameStatic ());
		}

		[Preserve]
		public Node () : this (Application.CurrentContext)
		{
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_Node (IntPtr context);

		[Preserve]
		public Node (Context context) : base (UrhoObjectFlag.Empty)
		{
			Runtime.Validate (typeof(Node));
			handle = Node_Node ((object)context == null ? IntPtr.Zero : context.Handle);
			Runtime.RegisterObject (this);
			OnNodeCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RegisterObject (IntPtr context);

		/// <summary>
		/// Register object factory.
		/// </summary>
		public new static void RegisterObject (Context context)
		{
			Runtime.Validate (typeof(Node));
			Node_RegisterObject ((object)context == null ? IntPtr.Zero : context.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_Load_File (IntPtr handle, IntPtr source, bool setInstanceDefault);

		/// <summary>
		/// Load from binary data. Return true if successful.
		/// </summary>
		public override bool Load (File source, bool setInstanceDefault = false)
		{
			Runtime.ValidateRefCounted (this);
			return Node_Load_File (handle, (object)source == null ? IntPtr.Zero : source.Handle, setInstanceDefault);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_Load_MemoryBuffer (IntPtr handle, IntPtr source, bool setInstanceDefault);

		/// <summary>
		/// Load from binary data. Return true if successful.
		/// </summary>
		public override bool Load (MemoryBuffer source, bool setInstanceDefault = false)
		{
			Runtime.ValidateRefCounted (this);
			return Node_Load_MemoryBuffer (handle, (object)source == null ? IntPtr.Zero : source.Handle, setInstanceDefault);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_LoadXML (IntPtr handle, IntPtr source, bool setInstanceDefault);

		/// <summary>
		/// Load from XML data. Return true if successful.
		/// </summary>
		public override bool LoadXml (XmlElement source, bool setInstanceDefault = false)
		{
			Runtime.ValidateRefCounted (this);
			return Node_LoadXML (handle, (object)source == null ? IntPtr.Zero : source.Handle, setInstanceDefault);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_Save_File (IntPtr handle, IntPtr dest);

		/// <summary>
		/// Save as binary data. Return true if successful.
		/// </summary>
		public override bool Save (File dest)
		{
			Runtime.ValidateRefCounted (this);
			return Node_Save_File (handle, (object)dest == null ? IntPtr.Zero : dest.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_Save_MemoryBuffer (IntPtr handle, IntPtr dest);

		/// <summary>
		/// Save as binary data. Return true if successful.
		/// </summary>
		public override bool Save (MemoryBuffer dest)
		{
			Runtime.ValidateRefCounted (this);
			return Node_Save_MemoryBuffer (handle, (object)dest == null ? IntPtr.Zero : dest.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_SaveXML (IntPtr handle, IntPtr dest);

		/// <summary>
		/// Save as XML data. Return true if successful.
		/// </summary>
		public override bool SaveXml (XmlElement dest)
		{
			Runtime.ValidateRefCounted (this);
			return Node_SaveXML (handle, (object)dest == null ? IntPtr.Zero : dest.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_ApplyAttributes (IntPtr handle);

		/// <summary>
		/// Apply attribute changes that can not be applied immediately recursively to child nodes and components.
		/// </summary>
		public override void ApplyAttributes ()
		{
			Runtime.ValidateRefCounted (this);
			Node_ApplyAttributes (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_SaveDefaultAttributes (IntPtr handle);

		/// <summary>
		/// Return whether should save default-valued attributes into XML. Always save node transforms for readability, even if identity.
		/// </summary>
		public override bool SaveDefaultAttributes ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_SaveDefaultAttributes (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_MarkNetworkUpdate (IntPtr handle);

		/// <summary>
		/// Mark for attribute check on the next network update.
		/// </summary>
		public override void MarkNetworkUpdate ()
		{
			Runtime.ValidateRefCounted (this);
			Node_MarkNetworkUpdate (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_AddReplicationState (IntPtr handle, NodeReplicationState* state);

		/// <summary>
		/// Add a replication state that is tracking this node.
		/// </summary>
		public virtual void AddReplicationState (NodeReplicationState* state)
		{
			Runtime.ValidateRefCounted (this);
			Node_AddReplicationState (handle, state);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_SaveXML0_File (IntPtr handle, IntPtr dest, string indentation);

		/// <summary>
		/// Save to an XML file. Return true if successful.
		/// </summary>
		public virtual bool SaveXml (File dest, string indentation = "\t")
		{
			Runtime.ValidateRefCounted (this);
			return Node_SaveXML0_File (handle, (object)dest == null ? IntPtr.Zero : dest.Handle, indentation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_SaveXML0_MemoryBuffer (IntPtr handle, IntPtr dest, string indentation);

		/// <summary>
		/// Save to an XML file. Return true if successful.
		/// </summary>
		public virtual bool SaveXml (MemoryBuffer dest, string indentation = "\t")
		{
			Runtime.ValidateRefCounted (this);
			return Node_SaveXML0_MemoryBuffer (handle, (object)dest == null ? IntPtr.Zero : dest.Handle, indentation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_SaveJSON_File (IntPtr handle, IntPtr dest, string indentation);

		/// <summary>
		/// Save to a JSON file. Return true if successful.
		/// </summary>
		public virtual bool SaveJson (File dest, string indentation = "\t")
		{
			Runtime.ValidateRefCounted (this);
			return Node_SaveJSON_File (handle, (object)dest == null ? IntPtr.Zero : dest.Handle, indentation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_SaveJSON_MemoryBuffer (IntPtr handle, IntPtr dest, string indentation);

		/// <summary>
		/// Save to a JSON file. Return true if successful.
		/// </summary>
		public virtual bool SaveJson (MemoryBuffer dest, string indentation = "\t")
		{
			Runtime.ValidateRefCounted (this);
			return Node_SaveJSON_MemoryBuffer (handle, (object)dest == null ? IntPtr.Zero : dest.Handle, indentation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetName (IntPtr handle, string name);

		/// <summary>
		/// Set name of the scene node. Names are not required to be unique.
		/// </summary>
		private void SetName (string name)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetName (handle, name);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_AddTag (IntPtr handle, string tag);

		/// <summary>
		/// Add a tag.
		/// </summary>
		public void AddTag (string tag)
		{
			Runtime.ValidateRefCounted (this);
			Node_AddTag (handle, tag);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_RemoveTag (IntPtr handle, string tag);

		/// <summary>
		/// Remove tag. Return true if existed.
		/// </summary>
		public bool RemoveTag (string tag)
		{
			Runtime.ValidateRefCounted (this);
			return Node_RemoveTag (handle, tag);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RemoveAllTags (IntPtr handle);

		/// <summary>
		/// Remove all tags.
		/// </summary>
		public void RemoveAllTags ()
		{
			Runtime.ValidateRefCounted (this);
			Node_RemoveAllTags (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetPosition (IntPtr handle, ref Urho.Vector3 position);

		/// <summary>
		/// Set position in parent space. If the scene node is on the root level (is child of the scene itself), this is same as world space.
		/// </summary>
		private void SetPosition (Urho.Vector3 position)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetPosition (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetPosition2D (IntPtr handle, ref Urho.Vector2 position);

		/// <summary>
		/// Set position in parent space (for Urho2D).
		/// </summary>
		public void SetPosition2D (Urho.Vector2 position)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetPosition2D (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetPosition2D1 (IntPtr handle, float x, float y);

		/// <summary>
		/// Set position in parent space (for Urho2D).
		/// </summary>
		public void SetPosition2D (float x, float y)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetPosition2D1 (handle, x, y);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetRotation (IntPtr handle, ref Urho.Quaternion rotation);

		/// <summary>
		/// Set rotation in parent space.
		/// </summary>
		private void SetRotation (Urho.Quaternion rotation)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetRotation (handle, ref rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetRotation2D (IntPtr handle, float rotation);

		/// <summary>
		/// Set rotation in parent space (for Urho2D).
		/// </summary>
		private void SetRotation2D (float rotation)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetRotation2D (handle, rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetDirection (IntPtr handle, ref Urho.Vector3 direction);

		/// <summary>
		/// Set forward direction in parent space. Positive Z axis equals identity rotation.
		/// </summary>
		public void SetDirection (Urho.Vector3 direction)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetDirection (handle, ref direction);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetScale (IntPtr handle, float scale);

		/// <summary>
		/// Set uniform scale in parent space.
		/// </summary>
		public void SetScale (float scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetScale (handle, scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetScale2 (IntPtr handle, ref Urho.Vector3 scale);

		/// <summary>
		/// Set scale in parent space.
		/// </summary>
		private void SetScale (Urho.Vector3 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetScale2 (handle, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetScale2D (IntPtr handle, ref Urho.Vector2 scale);

		/// <summary>
		/// Set scale in parent space (for Urho2D).
		/// </summary>
		public void SetScale2D (Urho.Vector2 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetScale2D (handle, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetScale2D3 (IntPtr handle, float x, float y);

		/// <summary>
		/// Set scale in parent space (for Urho2D).
		/// </summary>
		public void SetScale2D (float x, float y)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetScale2D3 (handle, x, y);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetTransform (IntPtr handle, ref Urho.Vector3 position, ref Urho.Quaternion rotation);

		/// <summary>
		/// Set both position and rotation in parent space as an atomic operation. This is faster than setting position and rotation separately.
		/// </summary>
		public void SetTransform (Urho.Vector3 position, Urho.Quaternion rotation)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetTransform (handle, ref position, ref rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetTransform4 (IntPtr handle, ref Urho.Vector3 position, ref Urho.Quaternion rotation, float scale);

		/// <summary>
		/// Set both position, rotation and uniform scale in parent space as an atomic operation.
		/// </summary>
		public void SetTransform (Urho.Vector3 position, Urho.Quaternion rotation, float scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetTransform4 (handle, ref position, ref rotation, scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetTransform5 (IntPtr handle, ref Urho.Vector3 position, ref Urho.Quaternion rotation, ref Urho.Vector3 scale);

		/// <summary>
		/// Set both position, rotation and scale in parent space as an atomic operation.
		/// </summary>
		public void SetTransform (Urho.Vector3 position, Urho.Quaternion rotation, Urho.Vector3 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetTransform5 (handle, ref position, ref rotation, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetTransform6 (IntPtr handle, ref Urho.Matrix3x4 matrix);

		/// <summary>
		/// Set node transformation in parent space as an atomic operation.
		/// </summary>
		public void SetTransform (Urho.Matrix3x4 matrix)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetTransform6 (handle, ref matrix);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetTransform2D (IntPtr handle, ref Urho.Vector2 position, float rotation);

		/// <summary>
		/// Set both position and rotation in parent space as an atomic operation (for Urho2D).
		/// </summary>
		public void SetTransform2D (Urho.Vector2 position, float rotation)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetTransform2D (handle, ref position, rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetTransform2D7 (IntPtr handle, ref Urho.Vector2 position, float rotation, float scale);

		/// <summary>
		/// Set both position, rotation and uniform scale in parent space as an atomic operation (for Urho2D).
		/// </summary>
		public void SetTransform2D (Urho.Vector2 position, float rotation, float scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetTransform2D7 (handle, ref position, rotation, scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetTransform2D8 (IntPtr handle, ref Urho.Vector2 position, float rotation, ref Urho.Vector2 scale);

		/// <summary>
		/// Set both position, rotation and scale in parent space as an atomic operation (for Urho2D).
		/// </summary>
		public void SetTransform2D (Urho.Vector2 position, float rotation, Urho.Vector2 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetTransform2D8 (handle, ref position, rotation, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldPosition (IntPtr handle, ref Urho.Vector3 position);

		/// <summary>
		/// Set position in world space.
		/// </summary>
		public void SetWorldPosition (Urho.Vector3 position)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldPosition (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldPosition2D (IntPtr handle, ref Urho.Vector2 position);

		/// <summary>
		/// Set position in world space (for Urho2D).
		/// </summary>
		public void SetWorldPosition2D (Urho.Vector2 position)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldPosition2D (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldPosition2D9 (IntPtr handle, float x, float y);

		/// <summary>
		/// Set position in world space (for Urho2D).
		/// </summary>
		public void SetWorldPosition2D (float x, float y)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldPosition2D9 (handle, x, y);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldRotation (IntPtr handle, ref Urho.Quaternion rotation);

		/// <summary>
		/// Set rotation in world space.
		/// </summary>
		public void SetWorldRotation (Urho.Quaternion rotation)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldRotation (handle, ref rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldRotation2D (IntPtr handle, float rotation);

		/// <summary>
		/// Set rotation in world space (for Urho2D).
		/// </summary>
		private void SetWorldRotation2D (float rotation)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldRotation2D (handle, rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldDirection (IntPtr handle, ref Urho.Vector3 direction);

		/// <summary>
		/// Set forward direction in world space.
		/// </summary>
		public void SetWorldDirection (Urho.Vector3 direction)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldDirection (handle, ref direction);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldScale (IntPtr handle, float scale);

		/// <summary>
		/// Set uniform scale in world space.
		/// </summary>
		public void SetWorldScale (float scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldScale (handle, scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldScale10 (IntPtr handle, ref Urho.Vector3 scale);

		/// <summary>
		/// Set scale in world space.
		/// </summary>
		public void SetWorldScale (Urho.Vector3 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldScale10 (handle, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldScale2D (IntPtr handle, ref Urho.Vector2 scale);

		/// <summary>
		/// Set scale in world space (for Urho2D).
		/// </summary>
		public void SetWorldScale2D (Urho.Vector2 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldScale2D (handle, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldScale2D11 (IntPtr handle, float x, float y);

		/// <summary>
		/// Set scale in world space (for Urho2D).
		/// </summary>
		public void SetWorldScale2D (float x, float y)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldScale2D11 (handle, x, y);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldTransform (IntPtr handle, ref Urho.Vector3 position, ref Urho.Quaternion rotation);

		/// <summary>
		/// Set both position and rotation in world space as an atomic operation.
		/// </summary>
		public void SetWorldTransform (Urho.Vector3 position, Urho.Quaternion rotation)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldTransform (handle, ref position, ref rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldTransform12 (IntPtr handle, ref Urho.Vector3 position, ref Urho.Quaternion rotation, float scale);

		/// <summary>
		/// Set both position, rotation and uniform scale in world space as an atomic operation.
		/// </summary>
		public void SetWorldTransform (Urho.Vector3 position, Urho.Quaternion rotation, float scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldTransform12 (handle, ref position, ref rotation, scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldTransform13 (IntPtr handle, ref Urho.Vector3 position, ref Urho.Quaternion rotation, ref Urho.Vector3 scale);

		/// <summary>
		/// Set both position, rotation and scale in world space as an atomic opration.
		/// </summary>
		public void SetWorldTransform (Urho.Vector3 position, Urho.Quaternion rotation, Urho.Vector3 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldTransform13 (handle, ref position, ref rotation, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldTransform2D (IntPtr handle, ref Urho.Vector2 position, float rotation);

		/// <summary>
		/// Set both position and rotation in world space as an atomic operation (for Urho2D).
		/// </summary>
		public void SetWorldTransform2D (Urho.Vector2 position, float rotation)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldTransform2D (handle, ref position, rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldTransform2D14 (IntPtr handle, ref Urho.Vector2 position, float rotation, float scale);

		/// <summary>
		/// Set both position, rotation and uniform scale in world space as an atomic operation (for Urho2D).
		/// </summary>
		public void SetWorldTransform2D (Urho.Vector2 position, float rotation, float scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldTransform2D14 (handle, ref position, rotation, scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetWorldTransform2D15 (IntPtr handle, ref Urho.Vector2 position, float rotation, ref Urho.Vector2 scale);

		/// <summary>
		/// Set both position, rotation and scale in world space as an atomic opration (for Urho2D).
		/// </summary>
		public void SetWorldTransform2D (Urho.Vector2 position, float rotation, Urho.Vector2 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetWorldTransform2D15 (handle, ref position, rotation, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_Translate (IntPtr handle, ref Urho.Vector3 delta, TransformSpace space);

		/// <summary>
		/// Move the scene node in the chosen transform space.
		/// </summary>
		public void Translate (Urho.Vector3 delta, TransformSpace space = TransformSpace.Local)
		{
			Runtime.ValidateRefCounted (this);
			Node_Translate (handle, ref delta, space);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_Translate2D (IntPtr handle, ref Urho.Vector2 delta, TransformSpace space);

		/// <summary>
		/// Move the scene node in the chosen transform space (for Urho2D).
		/// </summary>
		public void Translate2D (Urho.Vector2 delta, TransformSpace space = TransformSpace.Local)
		{
			Runtime.ValidateRefCounted (this);
			Node_Translate2D (handle, ref delta, space);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_Rotate (IntPtr handle, ref Urho.Quaternion delta, TransformSpace space);

		/// <summary>
		/// Rotate the scene node in the chosen transform space.
		/// </summary>
		public void Rotate (Urho.Quaternion delta, TransformSpace space = TransformSpace.Local)
		{
			Runtime.ValidateRefCounted (this);
			Node_Rotate (handle, ref delta, space);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_Rotate2D (IntPtr handle, float delta, TransformSpace space);

		/// <summary>
		/// Rotate the scene node in the chosen transform space (for Urho2D).
		/// </summary>
		public void Rotate2D (float delta, TransformSpace space = TransformSpace.Local)
		{
			Runtime.ValidateRefCounted (this);
			Node_Rotate2D (handle, delta, space);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RotateAround (IntPtr handle, ref Urho.Vector3 point, ref Urho.Quaternion delta, TransformSpace space);

		/// <summary>
		/// Rotate around a point in the chosen transform space.
		/// </summary>
		public void RotateAround (Urho.Vector3 point, Urho.Quaternion delta, TransformSpace space = TransformSpace.Local)
		{
			Runtime.ValidateRefCounted (this);
			Node_RotateAround (handle, ref point, ref delta, space);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RotateAround2D (IntPtr handle, ref Urho.Vector2 point, float delta, TransformSpace space);

		/// <summary>
		/// Rotate around a point in the chosen transform space (for Urho2D).
		/// </summary>
		public void RotateAround2D (Urho.Vector2 point, float delta, TransformSpace space = TransformSpace.Local)
		{
			Runtime.ValidateRefCounted (this);
			Node_RotateAround2D (handle, ref point, delta, space);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_Pitch (IntPtr handle, float angle, TransformSpace space);

		/// <summary>
		/// Rotate around the X axis.
		/// </summary>
		public void Pitch (float angle, TransformSpace space = TransformSpace.Local)
		{
			Runtime.ValidateRefCounted (this);
			Node_Pitch (handle, angle, space);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_Yaw (IntPtr handle, float angle, TransformSpace space);

		/// <summary>
		/// Rotate around the Y axis.
		/// </summary>
		public void Yaw (float angle, TransformSpace space = TransformSpace.Local)
		{
			Runtime.ValidateRefCounted (this);
			Node_Yaw (handle, angle, space);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_Roll (IntPtr handle, float angle, TransformSpace space);

		/// <summary>
		/// Rotate around the Z axis.
		/// </summary>
		public void Roll (float angle, TransformSpace space = TransformSpace.Local)
		{
			Runtime.ValidateRefCounted (this);
			Node_Roll (handle, angle, space);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_LookAt (IntPtr handle, ref Urho.Vector3 target, ref Urho.Vector3 up, TransformSpace space);

		/// <summary>
		/// Look at a target position in the chosen transform space. Note that the up vector is always specified in world space. Return true if successful, or false if resulted in an illegal rotation, in which case the current rotation remains.
		/// </summary>
		public bool LookAt (Urho.Vector3 target, Urho.Vector3 up, TransformSpace space = TransformSpace.World)
		{
			Runtime.ValidateRefCounted (this);
			return Node_LookAt (handle, ref target, ref up, space);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_Scale (IntPtr handle, float scale);

		/// <summary>
		/// Modify scale in parent space uniformly.
		/// </summary>
		public void ScaleNode (float scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_Scale (handle, scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_Scale16 (IntPtr handle, ref Urho.Vector3 scale);

		/// <summary>
		/// Modify scale in parent space.
		/// </summary>
		public void ScaleNode (Urho.Vector3 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_Scale16 (handle, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_Scale2D (IntPtr handle, ref Urho.Vector2 scale);

		/// <summary>
		/// Modify scale in parent space (for Urho2D).
		/// </summary>
		public void ScaleNode2D (Urho.Vector2 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_Scale2D (handle, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetEnabled (IntPtr handle, bool enable);

		/// <summary>
		/// Set enabled/disabled state without recursion. Components in a disabled node become effectively disabled regardless of their own enable/disable state.
		/// </summary>
		private void SetEnabled (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetEnabled (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetDeepEnabled (IntPtr handle, bool enable);

		/// <summary>
		/// Set enabled state on self and child nodes. Nodes' own enabled state is remembered (IsEnabledSelf) and can be restored.
		/// </summary>
		public void SetDeepEnabled (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetDeepEnabled (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_ResetDeepEnabled (IntPtr handle);

		/// <summary>
		/// Reset enabled state to the node's remembered state prior to calling SetDeepEnabled.
		/// </summary>
		public void ResetDeepEnabled ()
		{
			Runtime.ValidateRefCounted (this);
			Node_ResetDeepEnabled (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetEnabledRecursive (IntPtr handle, bool enable);

		/// <summary>
		/// Set enabled state on self and child nodes. Unlike SetDeepEnabled this does not remember the nodes' own enabled state, but overwrites it.
		/// </summary>
		public void SetEnabledRecursive (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetEnabledRecursive (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetOwner (IntPtr handle, IntPtr owner);

		/// <summary>
		/// Set owner connection for networking.
		/// </summary>
		private void SetOwner (Connection owner)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetOwner (handle, (object)owner == null ? IntPtr.Zero : owner.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_MarkDirty (IntPtr handle);

		/// <summary>
		/// Mark node and child nodes to need world transform recalculation. Notify listener components.
		/// </summary>
		public void MarkDirty ()
		{
			Runtime.ValidateRefCounted (this);
			Node_MarkDirty (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_CreateChild (IntPtr handle, string name, CreateMode mode, uint id, bool temporary);

		/// <summary>
		/// Create a child scene node (with specified ID if provided).
		/// </summary>
		public Node CreateChild (string name = "", CreateMode mode = CreateMode.Replicated, uint id = 0, bool temporary = false)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Node> (Node_CreateChild (handle, name, mode, id, temporary));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_CreateTemporaryChild (IntPtr handle, string name, CreateMode mode, uint id);

		/// <summary>
		/// Create a temporary child scene node (with specified ID if provided).
		/// </summary>
		public Node CreateTemporaryChild (string name = "", CreateMode mode = CreateMode.Replicated, uint id = 0)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Node> (Node_CreateTemporaryChild (handle, name, mode, id));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_AddChild (IntPtr handle, IntPtr node, uint index);

		/// <summary>
		/// Add a child scene node at a specific index. If index is not explicitly specified or is greater than current children size, append the new child at the end.
		/// </summary>
		public void AddChild (Node node, uint index = uint.MaxValue)
		{
			Runtime.ValidateRefCounted (this);
			Node_AddChild (handle, (object)node == null ? IntPtr.Zero : node.Handle, index);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RemoveChild (IntPtr handle, IntPtr node);

		/// <summary>
		/// Remove a child scene node.
		/// </summary>
		public void RemoveChild (Node node)
		{
			Runtime.ValidateRefCounted (this);
			Node_RemoveChild (handle, (object)node == null ? IntPtr.Zero : node.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RemoveAllChildren (IntPtr handle);

		/// <summary>
		/// Remove all child scene nodes.
		/// </summary>
		public void RemoveAllChildren ()
		{
			Runtime.ValidateRefCounted (this);
			Node_RemoveAllChildren (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RemoveChildren (IntPtr handle, bool removeReplicated, bool removeLocal, bool recursive);

		/// <summary>
		/// Remove child scene nodes that match criteria.
		/// </summary>
		public void RemoveChildren (bool removeReplicated, bool removeLocal, bool recursive)
		{
			Runtime.ValidateRefCounted (this);
			Node_RemoveChildren (handle, removeReplicated, removeLocal, recursive);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_CreateComponent (IntPtr handle, int type, CreateMode mode, uint id);

		/// <summary>
		/// Create a component to this node (with specified ID if provided).
		/// </summary>
		public Component CreateComponent (StringHash type, CreateMode mode = CreateMode.Replicated, uint id = 0)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Component> (Node_CreateComponent (handle, type.Code, mode, id));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetOrCreateComponent (IntPtr handle, int type, CreateMode mode, uint id);

		/// <summary>
		/// Create a component to this node if it does not exist already.
		/// </summary>
		public Component GetOrCreateComponent (StringHash type, CreateMode mode = CreateMode.Replicated, uint id = 0)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Component> (Node_GetOrCreateComponent (handle, type.Code, mode, id));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_CloneComponent (IntPtr handle, IntPtr component, uint id);

		/// <summary>
		/// Clone a component from another node using its create mode. Return the clone if successful or null on failure.
		/// </summary>
		public Component CloneComponent (Component component, uint id = 0)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Component> (Node_CloneComponent (handle, (object)component == null ? IntPtr.Zero : component.Handle, id));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_CloneComponent17 (IntPtr handle, IntPtr component, CreateMode mode, uint id);

		/// <summary>
		/// Clone a component from another node and specify the create mode. Return the clone if successful or null on failure.
		/// </summary>
		public Component CloneComponent (Component component, CreateMode mode, uint id = 0)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Component> (Node_CloneComponent17 (handle, (object)component == null ? IntPtr.Zero : component.Handle, mode, id));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RemoveComponent (IntPtr handle, IntPtr component);

		/// <summary>
		/// Remove a component from this node.
		/// </summary>
		public void RemoveComponent (Component component)
		{
			Runtime.ValidateRefCounted (this);
			Node_RemoveComponent (handle, (object)component == null ? IntPtr.Zero : component.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RemoveComponent18 (IntPtr handle, int type);

		/// <summary>
		/// Remove the first component of specific type from this node.
		/// </summary>
		public void RemoveComponent (StringHash type)
		{
			Runtime.ValidateRefCounted (this);
			Node_RemoveComponent18 (handle, type.Code);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RemoveComponents (IntPtr handle, bool removeReplicated, bool removeLocal);

		/// <summary>
		/// Remove components that match criteria.
		/// </summary>
		public void RemoveComponents (bool removeReplicated, bool removeLocal)
		{
			Runtime.ValidateRefCounted (this);
			Node_RemoveComponents (handle, removeReplicated, removeLocal);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RemoveComponents19 (IntPtr handle, int type);

		/// <summary>
		/// Remove all components of specific type.
		/// </summary>
		public void RemoveComponents (StringHash type)
		{
			Runtime.ValidateRefCounted (this);
			Node_RemoveComponents19 (handle, type.Code);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RemoveAllComponents (IntPtr handle);

		/// <summary>
		/// Remove all components from this node.
		/// </summary>
		public void RemoveAllComponents ()
		{
			Runtime.ValidateRefCounted (this);
			Node_RemoveAllComponents (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_ReorderComponent (IntPtr handle, IntPtr component, uint index);

		/// <summary>
		/// Adjust index order of an existing component in this node.
		/// </summary>
		public void ReorderComponent (Component component, uint index)
		{
			Runtime.ValidateRefCounted (this);
			Node_ReorderComponent (handle, (object)component == null ? IntPtr.Zero : component.Handle, index);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_Clone (IntPtr handle, CreateMode mode);

		/// <summary>
		/// Clone scene node, components and child nodes. Return the clone.
		/// </summary>
		public Node Clone (CreateMode mode = CreateMode.Replicated)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Node> (Node_Clone (handle, mode));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_Remove (IntPtr handle);

		/// <summary>
		/// Remove from the parent node. If no other shared pointer references exist, causes immediate deletion.
		/// </summary>
		public void Remove ()
		{
			Runtime.ValidateRefCounted (this);
			Node_Remove (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetParent (IntPtr handle, IntPtr parent);

		/// <summary>
		/// Assign to a new parent scene node. Retains the world transform.
		/// </summary>
		private void SetParent (Node parent)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetParent (handle, (object)parent == null ? IntPtr.Zero : parent.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_0 (IntPtr handle, int key, ref Vector3 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Vector3 value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_0 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_1 (IntPtr handle, int key, ref IntRect value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, IntRect value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_1 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_2 (IntPtr handle, int key, ref Color value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Color value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_2 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_3 (IntPtr handle, int key, ref Vector2 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Vector2 value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_3 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_4 (IntPtr handle, int key, ref Vector4 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Vector4 value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_4 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_5 (IntPtr handle, int key, ref IntVector2 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, IntVector2 value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_5 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_6 (IntPtr handle, int key, ref Quaternion value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Quaternion value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_6 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_7 (IntPtr handle, int key, ref Matrix4 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Matrix4 value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_7 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_8 (IntPtr handle, int key, ref Matrix3x4 value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, Matrix3x4 value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_8 (handle, key.Code, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_9 (IntPtr handle, int key, int value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, int value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_9 (handle, key.Code, value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_10 (IntPtr handle, int key, float value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, float value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_10 (handle, key.Code, value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_11 (IntPtr handle, int key, string value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, string value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_11 (handle, key.Code, value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetVar_12 (IntPtr handle, int key, bool value);

		/// <summary>
		/// Set a user variable.
		/// </summary>
		public void SetVar (StringHash key, bool value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetVar_12 (handle, key.Code, value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_AddListener (IntPtr handle, IntPtr component);

		/// <summary>
		/// Add listener component that is notified of node being dirtied. Can either be in the same node or another.
		/// </summary>
		public void AddListener (Component component)
		{
			Runtime.ValidateRefCounted (this);
			Node_AddListener (handle, (object)component == null ? IntPtr.Zero : component.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_RemoveListener (IntPtr handle, IntPtr component);

		/// <summary>
		/// Remove listener component.
		/// </summary>
		public void RemoveListener (Component component)
		{
			Runtime.ValidateRefCounted (this);
			Node_RemoveListener (handle, (object)component == null ? IntPtr.Zero : component.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Node_GetID (IntPtr handle);

		/// <summary>
		/// Return ID.
		/// </summary>
		private uint GetID ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetID (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetName (IntPtr handle);

		/// <summary>
		/// Return name.
		/// </summary>
		private string GetName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (Node_GetName (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Node_GetNameHash (IntPtr handle);

		/// <summary>
		/// Return name hash.
		/// </summary>
		private StringHash GetNameHash ()
		{
			Runtime.ValidateRefCounted (this);
			return new StringHash (Node_GetNameHash (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_HasTag (IntPtr handle, string tag);

		/// <summary>
		/// Return whether has a specific tag.
		/// </summary>
		public bool HasTag (string tag)
		{
			Runtime.ValidateRefCounted (this);
			return Node_HasTag (handle, tag);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetParent (IntPtr handle);

		/// <summary>
		/// Return parent scene node.
		/// </summary>
		private Node GetParent ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Node> (Node_GetParent (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetScene (IntPtr handle);

		/// <summary>
		/// Return scene.
		/// </summary>
		private Scene GetScene ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Scene> (Node_GetScene (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_IsChildOf (IntPtr handle, IntPtr node);

		/// <summary>
		/// Return whether is a direct or indirect child of specified node.
		/// </summary>
		public bool IsChildOf (Node node)
		{
			Runtime.ValidateRefCounted (this);
			return Node_IsChildOf (handle, (object)node == null ? IntPtr.Zero : node.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_IsEnabled (IntPtr handle);

		/// <summary>
		/// Return whether is enabled. Disables nodes effectively disable all their components.
		/// </summary>
		private bool IsEnabled ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_IsEnabled (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_IsEnabledSelf (IntPtr handle);

		/// <summary>
		/// Return the node's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.
		/// </summary>
		private bool IsEnabledSelf ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_IsEnabledSelf (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetOwner (IntPtr handle);

		/// <summary>
		/// Return owner connection in networking.
		/// </summary>
		private Connection GetOwner ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Connection> (Node_GetOwner (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Vector3 Node_GetPosition (IntPtr handle);

		/// <summary>
		/// Return position in parent space.
		/// </summary>
		private Urho.Vector3 GetPosition ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetPosition (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector2 Node_GetPosition2D (IntPtr handle);

		/// <summary>
		/// Return position in parent space (for Urho2D).
		/// </summary>
		private Vector2 GetPosition2D ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetPosition2D (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Quaternion Node_GetRotation (IntPtr handle);

		/// <summary>
		/// Return rotation in parent space.
		/// </summary>
		private Urho.Quaternion GetRotation ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetRotation (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Node_GetRotation2D (IntPtr handle);

		/// <summary>
		/// Return rotation in parent space (for Urho2D).
		/// </summary>
		private float GetRotation2D ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetRotation2D (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_GetDirection (IntPtr handle);

		/// <summary>
		/// Return forward direction in parent space. Positive Z axis equals identity rotation.
		/// </summary>
		private Vector3 GetDirection ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetDirection (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_GetUp (IntPtr handle);

		/// <summary>
		/// Return up direction in parent space. Positive Y axis equals identity rotation.
		/// </summary>
		private Vector3 GetUp ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetUp (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_GetRight (IntPtr handle);

		/// <summary>
		/// Return right direction in parent space. Positive X axis equals identity rotation.
		/// </summary>
		private Vector3 GetRight ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetRight (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Vector3 Node_GetScale (IntPtr handle);

		/// <summary>
		/// Return scale in parent space.
		/// </summary>
		private Urho.Vector3 GetScale ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetScale (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector2 Node_GetScale2D (IntPtr handle);

		/// <summary>
		/// Return scale in parent space (for Urho2D).
		/// </summary>
		private Vector2 GetScale2D ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetScale2D (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Matrix3x4 Node_GetTransform (IntPtr handle);

		/// <summary>
		/// Return parent space transform matrix.
		/// </summary>
		private Matrix3x4 GetTransform ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetTransform (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_GetWorldPosition (IntPtr handle);

		/// <summary>
		/// Return position in world space.
		/// </summary>
		private Vector3 GetWorldPosition ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetWorldPosition (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector2 Node_GetWorldPosition2D (IntPtr handle);

		/// <summary>
		/// Return position in world space (for Urho2D).
		/// </summary>
		private Vector2 GetWorldPosition2D ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetWorldPosition2D (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Quaternion Node_GetWorldRotation (IntPtr handle);

		/// <summary>
		/// Return rotation in world space.
		/// </summary>
		private Quaternion GetWorldRotation ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetWorldRotation (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Node_GetWorldRotation2D (IntPtr handle);

		/// <summary>
		/// Return rotation in world space (for Urho2D).
		/// </summary>
		private float GetWorldRotation2D ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetWorldRotation2D (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_GetWorldDirection (IntPtr handle);

		/// <summary>
		/// Return direction in world space.
		/// </summary>
		private Vector3 GetWorldDirection ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetWorldDirection (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_GetWorldUp (IntPtr handle);

		/// <summary>
		/// Return node's up vector in world space.
		/// </summary>
		private Vector3 GetWorldUp ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetWorldUp (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_GetWorldRight (IntPtr handle);

		/// <summary>
		/// Return node's right vector in world space.
		/// </summary>
		private Vector3 GetWorldRight ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetWorldRight (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_GetWorldScale (IntPtr handle);

		/// <summary>
		/// Return scale in world space.
		/// </summary>
		private Vector3 GetWorldScale ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetWorldScale (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_GetSignedWorldScale (IntPtr handle);

		/// <summary>
		/// Return signed scale in world space. Utilized for Urho2D physics.
		/// </summary>
		private Vector3 GetSignedWorldScale ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetSignedWorldScale (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector2 Node_GetWorldScale2D (IntPtr handle);

		/// <summary>
		/// Return scale in world space (for Urho2D).
		/// </summary>
		private Vector2 GetWorldScale2D ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetWorldScale2D (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Matrix3x4 Node_GetWorldTransform (IntPtr handle);

		/// <summary>
		/// Return world space transform matrix.
		/// </summary>
		private Urho.Matrix3x4 GetWorldTransform ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetWorldTransform (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_LocalToWorld (IntPtr handle, ref Urho.Vector3 position);

		/// <summary>
		/// Convert a local space position to world space.
		/// </summary>
		public Vector3 LocalToWorld (Urho.Vector3 position)
		{
			Runtime.ValidateRefCounted (this);
			return Node_LocalToWorld (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_LocalToWorld20 (IntPtr handle, ref Urho.Vector4 vector);

		/// <summary>
		/// Convert a local space position or rotation to world space.
		/// </summary>
		public Vector3 LocalToWorld (Urho.Vector4 vector)
		{
			Runtime.ValidateRefCounted (this);
			return Node_LocalToWorld20 (handle, ref vector);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector2 Node_LocalToWorld2D (IntPtr handle, ref Urho.Vector2 vector);

		/// <summary>
		/// Convert a local space position or rotation to world space (for Urho2D).
		/// </summary>
		public Vector2 LocalToWorld2D (Urho.Vector2 vector)
		{
			Runtime.ValidateRefCounted (this);
			return Node_LocalToWorld2D (handle, ref vector);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_WorldToLocal (IntPtr handle, ref Urho.Vector3 position);

		/// <summary>
		/// Convert a world space position to local space.
		/// </summary>
		public Vector3 WorldToLocal (Urho.Vector3 position)
		{
			Runtime.ValidateRefCounted (this);
			return Node_WorldToLocal (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 Node_WorldToLocal21 (IntPtr handle, ref Urho.Vector4 vector);

		/// <summary>
		/// Convert a world space position or rotation to local space.
		/// </summary>
		public Vector3 WorldToLocal (Urho.Vector4 vector)
		{
			Runtime.ValidateRefCounted (this);
			return Node_WorldToLocal21 (handle, ref vector);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector2 Node_WorldToLocal2D (IntPtr handle, ref Urho.Vector2 vector);

		/// <summary>
		/// Convert a world space position or rotation to local space (for Urho2D).
		/// </summary>
		public Vector2 WorldToLocal2D (Urho.Vector2 vector)
		{
			Runtime.ValidateRefCounted (this);
			return Node_WorldToLocal2D (handle, ref vector);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_IsDirty (IntPtr handle);

		/// <summary>
		/// Return whether transform has changed and world transform needs recalculation.
		/// </summary>
		private bool IsDirty ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_IsDirty (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Node_GetNumChildren (IntPtr handle, bool recursive);

		/// <summary>
		/// Return number of child scene nodes.
		/// </summary>
		public uint GetNumChildren (bool recursive = false)
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetNumChildren (handle, recursive);
		}

		private IReadOnlyList<Node> _GetChildren_cache;

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetChildren (IntPtr handle);

		/// <summary>
		/// Return immediate child scene nodes.
		/// </summary>
		private IReadOnlyList<Node> GetChildren ()
		{
			Runtime.ValidateRefCounted (this);
			return _GetChildren_cache != null ? _GetChildren_cache : _GetChildren_cache = Runtime.CreateVectorSharedPtrProxy<Node> (Node_GetChildren (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetChild (IntPtr handle, uint index);

		/// <summary>
		/// Return child scene node by index.
		/// </summary>
		public Node GetChild (uint index)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Node> (Node_GetChild (handle, index));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetChild22 (IntPtr handle, string name, bool recursive);

		/// <summary>
		/// Return child scene node by name.
		/// </summary>
		public Node GetChild (string name, bool recursive = false)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Node> (Node_GetChild22 (handle, name, recursive));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetChild23 (IntPtr handle, int nameHash, bool recursive);

		/// <summary>
		/// Return child scene node by name hash.
		/// </summary>
		public Node GetChild (StringHash nameHash, bool recursive = false)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Node> (Node_GetChild23 (handle, nameHash.Code, recursive));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Node_GetNumComponents (IntPtr handle);

		/// <summary>
		/// Return number of components.
		/// </summary>
		private uint GetNumComponents ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetNumComponents (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Node_GetNumNetworkComponents (IntPtr handle);

		/// <summary>
		/// Return number of non-local components.
		/// </summary>
		private uint GetNumNetworkComponents ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetNumNetworkComponents (handle);
		}

		private IReadOnlyList<Component> _GetComponents_cache;

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetComponents (IntPtr handle);

		/// <summary>
		/// Return all components.
		/// </summary>
		private IReadOnlyList<Component> GetComponents ()
		{
			Runtime.ValidateRefCounted (this);
			return _GetComponents_cache != null ? _GetComponents_cache : _GetComponents_cache = Runtime.CreateVectorSharedPtrProxy<Component> (Node_GetComponents (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetComponent (IntPtr handle, int type, bool recursive);

		/// <summary>
		/// Return component by type. If there are several, returns the first.
		/// </summary>
		public Component GetComponent (StringHash type, bool recursive = false)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Component> (Node_GetComponent (handle, type.Code, recursive));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_GetParentComponent (IntPtr handle, int type, bool fullTraversal);

		/// <summary>
		/// Return component in parent node. If there are several, returns the first. May optional traverse up to the root node.
		/// </summary>
		public Component GetParentComponent (StringHash type, bool fullTraversal = false)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Component> (Node_GetParentComponent (handle, type.Code, fullTraversal));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Node_HasComponent (IntPtr handle, int type);

		/// <summary>
		/// Return whether has a specific component.
		/// </summary>
		public bool HasComponent (StringHash type)
		{
			Runtime.ValidateRefCounted (this);
			return Node_HasComponent (handle, type.Code);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetID (IntPtr handle, uint id);

		/// <summary>
		/// Set ID. Called by Scene.
		/// </summary>
		private void SetID (uint id)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetID (handle, id);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetScene (IntPtr handle, IntPtr scene);

		/// <summary>
		/// Set scene. Called by Scene.
		/// </summary>
		private void SetScene (Scene scene)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetScene (handle, (object)scene == null ? IntPtr.Zero : scene.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_ResetScene (IntPtr handle);

		/// <summary>
		/// Reset scene, ID and owner. Called by Scene.
		/// </summary>
		public void ResetScene ()
		{
			Runtime.ValidateRefCounted (this);
			Node_ResetScene (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetNetPositionAttr (IntPtr handle, ref Urho.Vector3 value);

		/// <summary>
		/// Set network position attribute.
		/// </summary>
		private void SetNetPositionAttr (Urho.Vector3 value)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetNetPositionAttr (handle, ref value);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Vector3 Node_GetNetPositionAttr (IntPtr handle);

		/// <summary>
		/// Return network position attribute.
		/// </summary>
		private Urho.Vector3 GetNetPositionAttr ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetNetPositionAttr (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_PrepareNetworkUpdate (IntPtr handle);

		/// <summary>
		/// Prepare network update by comparing attributes and marking replication states dirty as necessary.
		/// </summary>
		public virtual void PrepareNetworkUpdate ()
		{
			Runtime.ValidateRefCounted (this);
			Node_PrepareNetworkUpdate (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_CleanupConnection (IntPtr handle, IntPtr connection);

		/// <summary>
		/// Clean up all references to a network connection that is about to be removed.
		/// </summary>
		public virtual void CleanupConnection (Connection connection)
		{
			Runtime.ValidateRefCounted (this);
			Node_CleanupConnection (handle, (object)connection == null ? IntPtr.Zero : connection.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_MarkReplicationDirty (IntPtr handle);

		/// <summary>
		/// Mark node dirty in scene replication states.
		/// </summary>
		public void MarkReplicationDirty ()
		{
			Runtime.ValidateRefCounted (this);
			Node_MarkReplicationDirty (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Node_CreateChild24 (IntPtr handle, uint id, CreateMode mode, bool temporary);

		/// <summary>
		/// Create a child node with specific ID.
		/// </summary>
		public Node CreateChild (uint id, CreateMode mode, bool temporary = false)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Node> (Node_CreateChild24 (handle, id, mode, temporary));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_AddComponent (IntPtr handle, IntPtr component, uint id, CreateMode mode);

		/// <summary>
		/// Add a pre-created component. Using this function from application code is discouraged, as component operation without an owner node may not be well-defined in all cases. Prefer CreateComponent() instead.
		/// </summary>
		public void AddComponent (Component component, uint id, CreateMode mode)
		{
			Runtime.ValidateRefCounted (this);
			Node_AddComponent (handle, (object)component == null ? IntPtr.Zero : component.Handle, id, mode);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Node_GetNumPersistentChildren (IntPtr handle);

		/// <summary>
		/// Calculate number of non-temporary child nodes.
		/// </summary>
		private uint GetNumPersistentChildren ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetNumPersistentChildren (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Node_GetNumPersistentComponents (IntPtr handle);

		/// <summary>
		/// Calculate number of non-temporary components.
		/// </summary>
		private uint GetNumPersistentComponents ()
		{
			Runtime.ValidateRefCounted (this);
			return Node_GetNumPersistentComponents (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetPositionSilent (IntPtr handle, ref Urho.Vector3 position);

		/// <summary>
		/// Set position in parent space silently without marking the node
		/// &
		/// child nodes dirty. Used by animation code.
		/// </summary>
		public void SetPositionSilent (Urho.Vector3 position)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetPositionSilent (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetRotationSilent (IntPtr handle, ref Urho.Quaternion rotation);

		/// <summary>
		/// Set position in parent space silently without marking the node
		/// &
		/// child nodes dirty. Used by animation code.
		/// </summary>
		public void SetRotationSilent (Urho.Quaternion rotation)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetRotationSilent (handle, ref rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetScaleSilent (IntPtr handle, ref Urho.Vector3 scale);

		/// <summary>
		/// Set scale in parent space silently without marking the node
		/// &
		/// child nodes dirty. Used by animation code.
		/// </summary>
		public void SetScaleSilent (Urho.Vector3 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetScaleSilent (handle, ref scale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Node_SetTransformSilent (IntPtr handle, ref Urho.Vector3 position, ref Urho.Quaternion rotation, ref Urho.Vector3 scale);

		/// <summary>
		/// Set local transform silently without marking the node
		/// &
		/// child nodes dirty. Used by animation code.
		/// </summary>
		public void SetTransformSilent (Urho.Vector3 position, Urho.Quaternion rotation, Urho.Vector3 scale)
		{
			Runtime.ValidateRefCounted (this);
			Node_SetTransformSilent (handle, ref position, ref rotation, ref scale);
		}

		public override StringHash Type {
			get {
				return GetType ();
			}
		}

		public override string TypeName {
			get {
				return GetTypeName ();
			}
		}

		[Preserve]
		public new static StringHash TypeStatic {
			get {
				return GetTypeStatic ();
			}
		}

		public new static string TypeNameStatic {
			get {
				return GetTypeNameStatic ();
			}
		}

		/// <summary>
		/// Return name.
		/// Or
		/// Set name of the scene node. Names are not required to be unique.
		/// </summary>
		public string Name {
			get {
				return GetName ();
			}
			set {
				SetName (value);
			}
		}

		/// <summary>
		/// Return position in parent space.
		/// Or
		/// Set position in parent space. If the scene node is on the root level (is child of the scene itself), this is same as world space.
		/// </summary>
		public Urho.Vector3 Position {
			get {
				return GetPosition ();
			}
			set {
				SetPosition (value);
			}
		}

		/// <summary>
		/// Return position in parent space (for Urho2D).
		/// </summary>
		public Vector2 Position2D {
			get {
				return GetPosition2D ();
			}
		}

		/// <summary>
		/// Return rotation in parent space.
		/// Or
		/// Set rotation in parent space.
		/// </summary>
		public Urho.Quaternion Rotation {
			get {
				return GetRotation ();
			}
			set {
				SetRotation (value);
			}
		}

		/// <summary>
		/// Return rotation in parent space (for Urho2D).
		/// Or
		/// Set rotation in parent space (for Urho2D).
		/// </summary>
		public float Rotation2D {
			get {
				return GetRotation2D ();
			}
			set {
				SetRotation2D (value);
			}
		}

		/// <summary>
		/// Return forward direction in parent space. Positive Z axis equals identity rotation.
		/// </summary>
		public Vector3 Direction {
			get {
				return GetDirection ();
			}
		}

		/// <summary>
		/// Return scale in parent space.
		/// Or
		/// Set scale in parent space.
		/// </summary>
		public Urho.Vector3 Scale {
			get {
				return GetScale ();
			}
			set {
				SetScale (value);
			}
		}

		/// <summary>
		/// Return scale in parent space (for Urho2D).
		/// </summary>
		public Vector2 Scale2D {
			get {
				return GetScale2D ();
			}
		}

		/// <summary>
		/// Return parent space transform matrix.
		/// </summary>
		public Matrix3x4 Transform {
			get {
				return GetTransform ();
			}
		}

		/// <summary>
		/// Return position in world space.
		/// </summary>
		public Vector3 WorldPosition {
			get {
				return GetWorldPosition ();
			}
		}

		/// <summary>
		/// Return position in world space (for Urho2D).
		/// </summary>
		public Vector2 WorldPosition2D {
			get {
				return GetWorldPosition2D ();
			}
		}

		/// <summary>
		/// Return rotation in world space.
		/// </summary>
		public Quaternion WorldRotation {
			get {
				return GetWorldRotation ();
			}
		}

		/// <summary>
		/// Return rotation in world space (for Urho2D).
		/// Or
		/// Set rotation in world space (for Urho2D).
		/// </summary>
		public float WorldRotation2D {
			get {
				return GetWorldRotation2D ();
			}
			set {
				SetWorldRotation2D (value);
			}
		}

		/// <summary>
		/// Return direction in world space.
		/// </summary>
		public Vector3 WorldDirection {
			get {
				return GetWorldDirection ();
			}
		}

		/// <summary>
		/// Return scale in world space.
		/// </summary>
		public Vector3 WorldScale {
			get {
				return GetWorldScale ();
			}
		}

		/// <summary>
		/// Return scale in world space (for Urho2D).
		/// </summary>
		public Vector2 WorldScale2D {
			get {
				return GetWorldScale2D ();
			}
		}

		/// <summary>
		/// Return whether is enabled. Disables nodes effectively disable all their components.
		/// Or
		/// Set enabled/disabled state without recursion. Components in a disabled node become effectively disabled regardless of their own enable/disable state.
		/// </summary>
		public bool Enabled {
			get {
				return IsEnabled ();
			}
			set {
				SetEnabled (value);
			}
		}

		/// <summary>
		/// Return owner connection in networking.
		/// Or
		/// Set owner connection for networking.
		/// </summary>
		public Connection Owner {
			get {
				return GetOwner ();
			}
			set {
				SetOwner (value);
			}
		}

		/// <summary>
		/// Return parent scene node.
		/// Or
		/// Assign to a new parent scene node. Retains the world transform.
		/// </summary>
		public Node Parent {
			get {
				return GetParent ();
			}
			set {
				SetParent (value);
			}
		}

		/// <summary>
		/// Return ID.
		/// Or
		/// Set ID. Called by Scene.
		/// </summary>
		public uint ID {
			get {
				return GetID ();
			}
			set {
				SetID (value);
			}
		}

		/// <summary>
		/// Return name hash.
		/// </summary>
		public StringHash NameHash {
			get {
				return GetNameHash ();
			}
		}

		/// <summary>
		/// Return scene.
		/// Or
		/// Set scene. Called by Scene.
		/// </summary>
		public Scene Scene {
			get {
				return GetScene ();
			}
			set {
				SetScene (value);
			}
		}

		/// <summary>
		/// Return the node's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.
		/// </summary>
		public bool EnabledSelf {
			get {
				return IsEnabledSelf ();
			}
		}

		/// <summary>
		/// Return up direction in parent space. Positive Y axis equals identity rotation.
		/// </summary>
		public Vector3 Up {
			get {
				return GetUp ();
			}
		}

		/// <summary>
		/// Return right direction in parent space. Positive X axis equals identity rotation.
		/// </summary>
		public Vector3 Right {
			get {
				return GetRight ();
			}
		}

		/// <summary>
		/// Return node's up vector in world space.
		/// </summary>
		public Vector3 WorldUp {
			get {
				return GetWorldUp ();
			}
		}

		/// <summary>
		/// Return node's right vector in world space.
		/// </summary>
		public Vector3 WorldRight {
			get {
				return GetWorldRight ();
			}
		}

		/// <summary>
		/// Return signed scale in world space. Utilized for Urho2D physics.
		/// </summary>
		public Vector3 SignedWorldScale {
			get {
				return GetSignedWorldScale ();
			}
		}

		/// <summary>
		/// Return world space transform matrix.
		/// </summary>
		public Urho.Matrix3x4 WorldTransform {
			get {
				return GetWorldTransform ();
			}
		}

		/// <summary>
		/// Return whether transform has changed and world transform needs recalculation.
		/// </summary>
		public bool Dirty {
			get {
				return IsDirty ();
			}
		}

		/// <summary>
		/// Return immediate child scene nodes.
		/// </summary>
		public IReadOnlyList<Node> Children {
			get {
				return GetChildren ();
			}
		}

		/// <summary>
		/// Return number of components.
		/// </summary>
		public uint NumComponents {
			get {
				return GetNumComponents ();
			}
		}

		/// <summary>
		/// Return number of non-local components.
		/// </summary>
		public uint NumNetworkComponents {
			get {
				return GetNumNetworkComponents ();
			}
		}

		/// <summary>
		/// Return all components.
		/// </summary>
		public IReadOnlyList<Component> Components {
			get {
				return GetComponents ();
			}
		}

		/// <summary>
		/// Return network position attribute.
		/// Or
		/// Set network position attribute.
		/// </summary>
		public Urho.Vector3 NetPositionAttr {
			get {
				return GetNetPositionAttr ();
			}
			set {
				SetNetPositionAttr (value);
			}
		}

		/// <summary>
		/// Calculate number of non-temporary child nodes.
		/// </summary>
		public uint NumPersistentChildren {
			get {
				return GetNumPersistentChildren ();
			}
		}

		/// <summary>
		/// Calculate number of non-temporary components.
		/// </summary>
		public uint NumPersistentComponents {
			get {
				return GetNumPersistentComponents ();
			}
		}
	}
}
