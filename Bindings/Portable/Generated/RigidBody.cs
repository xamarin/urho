// WARNING - AUTOGENERATED - DO NOT EDIT
// 
// Generated using `sharpie urho`
// 
// RigidBody.cs
// 
// Copyright 2015 Xamarin Inc. All rights reserved.

using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using Urho.Urho2D;
using Urho.Gui;
using Urho.Resources;
using Urho.IO;
using Urho.Navigation;
using Urho.Network;

namespace Urho.Physics
{
	/// <summary>
	/// Physics rigid body component.
	/// </summary>
	public unsafe partial class RigidBody : Component
	{
		unsafe partial void OnRigidBodyCreated ();

		[Preserve]
		public RigidBody (IntPtr handle) : base (handle)
		{
			OnRigidBodyCreated ();
		}

		[Preserve]
		protected RigidBody (UrhoObjectFlag emptyFlag) : base (emptyFlag)
		{
			OnRigidBodyCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int RigidBody_GetType (IntPtr handle);

		private StringHash UrhoGetType ()
		{
			Runtime.ValidateRefCounted (this);
			return new StringHash (RigidBody_GetType (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr RigidBody_GetTypeName (IntPtr handle);

		private string GetTypeName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (RigidBody_GetTypeName (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int RigidBody_GetTypeStatic ();

		private static StringHash GetTypeStatic ()
		{
			Runtime.Validate (typeof(RigidBody));
			return new StringHash (RigidBody_GetTypeStatic ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr RigidBody_GetTypeNameStatic ();

		private static string GetTypeNameStatic ()
		{
			Runtime.Validate (typeof(RigidBody));
			return Marshal.PtrToStringAnsi (RigidBody_GetTypeNameStatic ());
		}

		[Preserve]
		public RigidBody () : this (Application.CurrentContext)
		{
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr RigidBody_RigidBody (IntPtr context);

		[Preserve]
		public RigidBody (Context context) : base (UrhoObjectFlag.Empty)
		{
			Runtime.Validate (typeof(RigidBody));
			handle = RigidBody_RigidBody ((object)context == null ? IntPtr.Zero : context.Handle);
			Runtime.RegisterObject (this);
			OnRigidBodyCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_RegisterObject (IntPtr context);

		/// <summary>
		/// Register object factory.
		/// </summary>
		public new static void RegisterObject (Context context)
		{
			Runtime.Validate (typeof(RigidBody));
			RigidBody_RegisterObject ((object)context == null ? IntPtr.Zero : context.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_ApplyAttributes (IntPtr handle);

		/// <summary>
		/// Apply attribute changes that can not be applied immediately. Called after scene load or a network update.
		/// </summary>
		public override void ApplyAttributes ()
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_ApplyAttributes (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_OnSetEnabled (IntPtr handle);

		/// <summary>
		/// Handle enabled/disabled state change.
		/// </summary>
		public override void OnSetEnabled ()
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_OnSetEnabled (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_DrawDebugGeometry (IntPtr handle, IntPtr debug, bool depthTest);

		/// <summary>
		/// Visualize the component as debug geometry.
		/// </summary>
		public override void DrawDebugGeometry (DebugRenderer debug, bool depthTest)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_DrawDebugGeometry (handle, (object)debug == null ? IntPtr.Zero : debug.Handle, depthTest);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetMass (IntPtr handle, float mass);

		/// <summary>
		/// Set mass. Zero mass makes the body static.
		/// </summary>
		private void SetMass (float mass)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetMass (handle, mass);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetPosition (IntPtr handle, ref Urho.Vector3 position);

		/// <summary>
		/// Set rigid body position in world space.
		/// </summary>
		public void SetPosition (Urho.Vector3 position)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetPosition (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetRotation (IntPtr handle, ref Urho.Quaternion rotation);

		/// <summary>
		/// Set rigid body rotation in world space.
		/// </summary>
		public void SetRotation (Urho.Quaternion rotation)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetRotation (handle, ref rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetTransform (IntPtr handle, ref Urho.Vector3 position, ref Urho.Quaternion rotation);

		/// <summary>
		/// Set rigid body position and rotation in world space as an atomic operation.
		/// </summary>
		public void SetTransform (Urho.Vector3 position, Urho.Quaternion rotation)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetTransform (handle, ref position, ref rotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetLinearVelocity (IntPtr handle, ref Urho.Vector3 velocity);

		/// <summary>
		/// Set linear velocity.
		/// </summary>
		public void SetLinearVelocity (Urho.Vector3 velocity)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetLinearVelocity (handle, ref velocity);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetLinearFactor (IntPtr handle, ref Urho.Vector3 factor);

		/// <summary>
		/// Set linear degrees of freedom. Use 1 to enable an axis or 0 to disable. Default is all axes enabled (1, 1, 1).
		/// </summary>
		public void SetLinearFactor (Urho.Vector3 factor)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetLinearFactor (handle, ref factor);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetLinearRestThreshold (IntPtr handle, float threshold);

		/// <summary>
		/// Set linear velocity deactivation threshold.
		/// </summary>
		private void SetLinearRestThreshold (float threshold)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetLinearRestThreshold (handle, threshold);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetLinearDamping (IntPtr handle, float damping);

		/// <summary>
		/// Set linear velocity damping factor.
		/// </summary>
		private void SetLinearDamping (float damping)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetLinearDamping (handle, damping);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetAngularVelocity (IntPtr handle, ref Urho.Vector3 angularVelocity);

		/// <summary>
		/// Set angular velocity.
		/// </summary>
		public void SetAngularVelocity (Urho.Vector3 angularVelocity)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetAngularVelocity (handle, ref angularVelocity);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetAngularFactor (IntPtr handle, ref Urho.Vector3 factor);

		/// <summary>
		/// Set angular degrees of freedom. Use 1 to enable an axis or 0 to disable. Default is all axes enabled (1, 1, 1).
		/// </summary>
		public void SetAngularFactor (Urho.Vector3 factor)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetAngularFactor (handle, ref factor);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetAngularRestThreshold (IntPtr handle, float threshold);

		/// <summary>
		/// Set angular velocity deactivation threshold.
		/// </summary>
		private void SetAngularRestThreshold (float threshold)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetAngularRestThreshold (handle, threshold);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetAngularDamping (IntPtr handle, float factor);

		/// <summary>
		/// Set angular velocity damping factor.
		/// </summary>
		private void SetAngularDamping (float factor)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetAngularDamping (handle, factor);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetFriction (IntPtr handle, float friction);

		/// <summary>
		/// Set friction coefficient.
		/// </summary>
		private void SetFriction (float friction)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetFriction (handle, friction);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetAnisotropicFriction (IntPtr handle, ref Urho.Vector3 friction);

		/// <summary>
		/// Set anisotropic friction.
		/// </summary>
		public void SetAnisotropicFriction (Urho.Vector3 friction)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetAnisotropicFriction (handle, ref friction);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetRollingFriction (IntPtr handle, float friction);

		/// <summary>
		/// Set rolling friction coefficient.
		/// </summary>
		private void SetRollingFriction (float friction)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetRollingFriction (handle, friction);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetRestitution (IntPtr handle, float restitution);

		/// <summary>
		/// Set restitution coefficient.
		/// </summary>
		private void SetRestitution (float restitution)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetRestitution (handle, restitution);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetContactProcessingThreshold (IntPtr handle, float threshold);

		/// <summary>
		/// Set contact processing threshold.
		/// </summary>
		private void SetContactProcessingThreshold (float threshold)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetContactProcessingThreshold (handle, threshold);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetCcdRadius (IntPtr handle, float radius);

		/// <summary>
		/// Set continuous collision detection swept sphere radius.
		/// </summary>
		private void SetCcdRadius (float radius)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetCcdRadius (handle, radius);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetCcdMotionThreshold (IntPtr handle, float threshold);

		/// <summary>
		/// Set continuous collision detection motion-per-simulation-step threshold. 0 disables, which is the default.
		/// </summary>
		private void SetCcdMotionThreshold (float threshold)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetCcdMotionThreshold (handle, threshold);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetUseGravity (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether gravity is applied to rigid body.
		/// </summary>
		private void SetUseGravity (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetUseGravity (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetGravityOverride (IntPtr handle, ref Urho.Vector3 gravity);

		/// <summary>
		/// Set gravity override. If zero, uses physics world's gravity.
		/// </summary>
		private void SetGravityOverride (Urho.Vector3 gravity)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetGravityOverride (handle, ref gravity);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetKinematic (IntPtr handle, bool enable);

		/// <summary>
		/// Set rigid body kinematic mode. In kinematic mode forces are not applied to the rigid body.
		/// </summary>
		private void SetKinematic (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetKinematic (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetTrigger (IntPtr handle, bool enable);

		/// <summary>
		/// Set rigid body trigger mode. In trigger mode collisions are reported but do not apply forces.
		/// </summary>
		private void SetTrigger (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetTrigger (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetCollisionLayer (IntPtr handle, uint layer);

		/// <summary>
		/// Set collision layer.
		/// </summary>
		private void SetCollisionLayer (uint layer)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetCollisionLayer (handle, layer);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetCollisionMask (IntPtr handle, uint mask);

		/// <summary>
		/// Set collision mask.
		/// </summary>
		private void SetCollisionMask (uint mask)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetCollisionMask (handle, mask);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetCollisionLayerAndMask (IntPtr handle, uint layer, uint mask);

		/// <summary>
		/// Set collision group and mask.
		/// </summary>
		public void SetCollisionLayerAndMask (uint layer, uint mask)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetCollisionLayerAndMask (handle, layer, mask);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_SetCollisionEventMode (IntPtr handle, CollisionEventMode mode);

		/// <summary>
		/// Set collision event signaling mode. Default is to signal when rigid bodies are active.
		/// </summary>
		private void SetCollisionEventMode (CollisionEventMode mode)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_SetCollisionEventMode (handle, mode);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_ApplyForce (IntPtr handle, ref Urho.Vector3 force);

		/// <summary>
		/// Apply force to center of mass.
		/// </summary>
		public void ApplyForce (Urho.Vector3 force)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_ApplyForce (handle, ref force);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_ApplyForce0 (IntPtr handle, ref Urho.Vector3 force, ref Urho.Vector3 position);

		/// <summary>
		/// Apply force at local position.
		/// </summary>
		public void ApplyForce (Urho.Vector3 force, Urho.Vector3 position)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_ApplyForce0 (handle, ref force, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_ApplyTorque (IntPtr handle, ref Urho.Vector3 torque);

		/// <summary>
		/// Apply torque.
		/// </summary>
		public void ApplyTorque (Urho.Vector3 torque)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_ApplyTorque (handle, ref torque);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_ApplyImpulse (IntPtr handle, ref Urho.Vector3 impulse);

		/// <summary>
		/// Apply impulse to center of mass.
		/// </summary>
		public void ApplyImpulse (Urho.Vector3 impulse)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_ApplyImpulse (handle, ref impulse);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_ApplyImpulse1 (IntPtr handle, ref Urho.Vector3 impulse, ref Urho.Vector3 position);

		/// <summary>
		/// Apply impulse at local position.
		/// </summary>
		public void ApplyImpulse (Urho.Vector3 impulse, Urho.Vector3 position)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_ApplyImpulse1 (handle, ref impulse, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_ApplyTorqueImpulse (IntPtr handle, ref Urho.Vector3 torque);

		/// <summary>
		/// Apply torque impulse.
		/// </summary>
		public void ApplyTorqueImpulse (Urho.Vector3 torque)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_ApplyTorqueImpulse (handle, ref torque);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_ResetForces (IntPtr handle);

		/// <summary>
		/// Reset accumulated forces.
		/// </summary>
		public void ResetForces ()
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_ResetForces (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_Activate (IntPtr handle);

		/// <summary>
		/// Activate rigid body if it was resting.
		/// </summary>
		public void Activate ()
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_Activate (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_ReAddBodyToWorld (IntPtr handle);

		/// <summary>
		/// Readd rigid body to the physics world to clean up internal state like stale contacts.
		/// </summary>
		public void ReAddBodyToWorld ()
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_ReAddBodyToWorld (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_DisableMassUpdate (IntPtr handle);

		/// <summary>
		/// Disable mass update. Call this to optimize performance when adding or editing multiple collision shapes in the same node.
		/// </summary>
		public void DisableMassUpdate ()
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_DisableMassUpdate (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_EnableMassUpdate (IntPtr handle);

		/// <summary>
		/// Re-enable mass update and recalculate the mass/inertia by calling UpdateMass(). Call when collision shape changes are finished.
		/// </summary>
		public void EnableMassUpdate ()
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_EnableMassUpdate (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr RigidBody_GetPhysicsWorld (IntPtr handle);

		/// <summary>
		/// Return physics world.
		/// </summary>
		private PhysicsWorld GetPhysicsWorld ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<PhysicsWorld> (RigidBody_GetPhysicsWorld (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float RigidBody_GetMass (IntPtr handle);

		/// <summary>
		/// Return mass.
		/// </summary>
		private float GetMass ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetMass (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 RigidBody_GetPosition (IntPtr handle);

		/// <summary>
		/// Return rigid body position in world space.
		/// </summary>
		private Vector3 GetPosition ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetPosition (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Quaternion RigidBody_GetRotation (IntPtr handle);

		/// <summary>
		/// Return rigid body rotation in world space.
		/// </summary>
		private Quaternion GetRotation ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetRotation (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 RigidBody_GetLinearVelocity (IntPtr handle);

		/// <summary>
		/// Return linear velocity.
		/// </summary>
		private Vector3 GetLinearVelocity ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetLinearVelocity (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 RigidBody_GetLinearFactor (IntPtr handle);

		/// <summary>
		/// Return linear degrees of freedom.
		/// </summary>
		private Vector3 GetLinearFactor ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetLinearFactor (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 RigidBody_GetVelocityAtPoint (IntPtr handle, ref Urho.Vector3 position);

		/// <summary>
		/// Return linear velocity at local point.
		/// </summary>
		public Vector3 GetVelocityAtPoint (Urho.Vector3 position)
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetVelocityAtPoint (handle, ref position);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float RigidBody_GetLinearRestThreshold (IntPtr handle);

		/// <summary>
		/// Return linear velocity deactivation threshold.
		/// </summary>
		private float GetLinearRestThreshold ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetLinearRestThreshold (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float RigidBody_GetLinearDamping (IntPtr handle);

		/// <summary>
		/// Return linear velocity damping factor.
		/// </summary>
		private float GetLinearDamping ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetLinearDamping (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 RigidBody_GetAngularVelocity (IntPtr handle);

		/// <summary>
		/// Return angular velocity.
		/// </summary>
		private Vector3 GetAngularVelocity ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetAngularVelocity (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 RigidBody_GetAngularFactor (IntPtr handle);

		/// <summary>
		/// Return angular degrees of freedom.
		/// </summary>
		private Vector3 GetAngularFactor ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetAngularFactor (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float RigidBody_GetAngularRestThreshold (IntPtr handle);

		/// <summary>
		/// Return angular velocity deactivation threshold.
		/// </summary>
		private float GetAngularRestThreshold ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetAngularRestThreshold (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float RigidBody_GetAngularDamping (IntPtr handle);

		/// <summary>
		/// Return angular velocity damping factor.
		/// </summary>
		private float GetAngularDamping ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetAngularDamping (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float RigidBody_GetFriction (IntPtr handle);

		/// <summary>
		/// Return friction coefficient.
		/// </summary>
		private float GetFriction ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetFriction (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector3 RigidBody_GetAnisotropicFriction (IntPtr handle);

		/// <summary>
		/// Return anisotropic friction.
		/// </summary>
		private Vector3 GetAnisotropicFriction ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetAnisotropicFriction (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float RigidBody_GetRollingFriction (IntPtr handle);

		/// <summary>
		/// Return rolling friction coefficient.
		/// </summary>
		private float GetRollingFriction ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetRollingFriction (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float RigidBody_GetRestitution (IntPtr handle);

		/// <summary>
		/// Return restitution coefficient.
		/// </summary>
		private float GetRestitution ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetRestitution (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float RigidBody_GetContactProcessingThreshold (IntPtr handle);

		/// <summary>
		/// Return contact processing threshold.
		/// </summary>
		private float GetContactProcessingThreshold ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetContactProcessingThreshold (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float RigidBody_GetCcdRadius (IntPtr handle);

		/// <summary>
		/// Return continuous collision detection swept sphere radius.
		/// </summary>
		private float GetCcdRadius ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetCcdRadius (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float RigidBody_GetCcdMotionThreshold (IntPtr handle);

		/// <summary>
		/// Return continuous collision detection motion-per-simulation-step threshold.
		/// </summary>
		private float GetCcdMotionThreshold ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetCcdMotionThreshold (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool RigidBody_GetUseGravity (IntPtr handle);

		/// <summary>
		/// Return whether rigid body uses gravity.
		/// </summary>
		private bool GetUseGravity ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetUseGravity (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Vector3 RigidBody_GetGravityOverride (IntPtr handle);

		/// <summary>
		/// Return gravity override. If zero (default), uses the physics world's gravity.
		/// </summary>
		private Urho.Vector3 GetGravityOverride ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetGravityOverride (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Urho.Vector3 RigidBody_GetCenterOfMass (IntPtr handle);

		/// <summary>
		/// Return center of mass offset.
		/// </summary>
		private Urho.Vector3 GetCenterOfMass ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetCenterOfMass (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool RigidBody_IsKinematic (IntPtr handle);

		/// <summary>
		/// Return kinematic mode flag.
		/// </summary>
		private bool IsKinematic ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_IsKinematic (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool RigidBody_IsTrigger (IntPtr handle);

		/// <summary>
		/// Return whether this RigidBody is acting as a trigger.
		/// </summary>
		private bool IsTrigger ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_IsTrigger (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool RigidBody_IsActive (IntPtr handle);

		/// <summary>
		/// Return whether rigid body is active (not sleeping.)
		/// </summary>
		private bool IsActive ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_IsActive (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint RigidBody_GetCollisionLayer (IntPtr handle);

		/// <summary>
		/// Return collision layer.
		/// </summary>
		private uint GetCollisionLayer ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetCollisionLayer (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint RigidBody_GetCollisionMask (IntPtr handle);

		/// <summary>
		/// Return collision mask.
		/// </summary>
		private uint GetCollisionMask ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetCollisionMask (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern CollisionEventMode RigidBody_GetCollisionEventMode (IntPtr handle);

		/// <summary>
		/// Return collision event signaling mode.
		/// </summary>
		private CollisionEventMode GetCollisionEventMode ()
		{
			Runtime.ValidateRefCounted (this);
			return RigidBody_GetCollisionEventMode (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_ApplyWorldTransform (IntPtr handle, ref Urho.Vector3 newWorldPosition, ref Urho.Quaternion newWorldRotation);

		/// <summary>
		/// Apply new world transform after a simulation step. Called internally.
		/// </summary>
		public void ApplyWorldTransform (Urho.Vector3 newWorldPosition, Urho.Quaternion newWorldRotation)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_ApplyWorldTransform (handle, ref newWorldPosition, ref newWorldRotation);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_UpdateMass (IntPtr handle);

		/// <summary>
		/// Update mass and inertia to the Bullet rigid body.
		/// </summary>
		public void UpdateMass ()
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_UpdateMass (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_UpdateGravity (IntPtr handle);

		/// <summary>
		/// Update gravity parameters to the Bullet rigid body.
		/// </summary>
		public void UpdateGravity ()
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_UpdateGravity (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_AddConstraint (IntPtr handle, IntPtr constraint);

		/// <summary>
		/// Add a constraint that refers to this rigid body.
		/// </summary>
		public void AddConstraint (Constraint constraint)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_AddConstraint (handle, (object)constraint == null ? IntPtr.Zero : constraint.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_RemoveConstraint (IntPtr handle, IntPtr constraint);

		/// <summary>
		/// Remove a constraint that refers to this rigid body.
		/// </summary>
		public void RemoveConstraint (Constraint constraint)
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_RemoveConstraint (handle, (object)constraint == null ? IntPtr.Zero : constraint.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void RigidBody_ReleaseBody (IntPtr handle);

		/// <summary>
		/// Remove the rigid body.
		/// </summary>
		public void ReleaseBody ()
		{
			Runtime.ValidateRefCounted (this);
			RigidBody_ReleaseBody (handle);
		}

		public override StringHash Type {
			get {
				return UrhoGetType ();
			}
		}

		public override string TypeName {
			get {
				return GetTypeName ();
			}
		}

		[Preserve]
		public new static StringHash TypeStatic {
			get {
				return GetTypeStatic ();
			}
		}

		public new static string TypeNameStatic {
			get {
				return GetTypeNameStatic ();
			}
		}

		/// <summary>
		/// Return mass.
		/// Or
		/// Set mass. Zero mass makes the body static.
		/// </summary>
		public float Mass {
			get {
				return GetMass ();
			}
			set {
				SetMass (value);
			}
		}

		/// <summary>
		/// Return rigid body position in world space.
		/// </summary>
		public Vector3 Position {
			get {
				return GetPosition ();
			}
		}

		/// <summary>
		/// Return rigid body rotation in world space.
		/// </summary>
		public Quaternion Rotation {
			get {
				return GetRotation ();
			}
		}

		/// <summary>
		/// Return linear velocity.
		/// </summary>
		public Vector3 LinearVelocity {
			get {
				return GetLinearVelocity ();
			}
		}

		/// <summary>
		/// Return linear degrees of freedom.
		/// </summary>
		public Vector3 LinearFactor {
			get {
				return GetLinearFactor ();
			}
		}

		/// <summary>
		/// Return linear velocity deactivation threshold.
		/// Or
		/// Set linear velocity deactivation threshold.
		/// </summary>
		public float LinearRestThreshold {
			get {
				return GetLinearRestThreshold ();
			}
			set {
				SetLinearRestThreshold (value);
			}
		}

		/// <summary>
		/// Return linear velocity damping factor.
		/// Or
		/// Set linear velocity damping factor.
		/// </summary>
		public float LinearDamping {
			get {
				return GetLinearDamping ();
			}
			set {
				SetLinearDamping (value);
			}
		}

		/// <summary>
		/// Return angular velocity.
		/// </summary>
		public Vector3 AngularVelocity {
			get {
				return GetAngularVelocity ();
			}
		}

		/// <summary>
		/// Return angular degrees of freedom.
		/// </summary>
		public Vector3 AngularFactor {
			get {
				return GetAngularFactor ();
			}
		}

		/// <summary>
		/// Return angular velocity deactivation threshold.
		/// Or
		/// Set angular velocity deactivation threshold.
		/// </summary>
		public float AngularRestThreshold {
			get {
				return GetAngularRestThreshold ();
			}
			set {
				SetAngularRestThreshold (value);
			}
		}

		/// <summary>
		/// Return angular velocity damping factor.
		/// Or
		/// Set angular velocity damping factor.
		/// </summary>
		public float AngularDamping {
			get {
				return GetAngularDamping ();
			}
			set {
				SetAngularDamping (value);
			}
		}

		/// <summary>
		/// Return friction coefficient.
		/// Or
		/// Set friction coefficient.
		/// </summary>
		public float Friction {
			get {
				return GetFriction ();
			}
			set {
				SetFriction (value);
			}
		}

		/// <summary>
		/// Return anisotropic friction.
		/// </summary>
		public Vector3 AnisotropicFriction {
			get {
				return GetAnisotropicFriction ();
			}
		}

		/// <summary>
		/// Return rolling friction coefficient.
		/// Or
		/// Set rolling friction coefficient.
		/// </summary>
		public float RollingFriction {
			get {
				return GetRollingFriction ();
			}
			set {
				SetRollingFriction (value);
			}
		}

		/// <summary>
		/// Return restitution coefficient.
		/// Or
		/// Set restitution coefficient.
		/// </summary>
		public float Restitution {
			get {
				return GetRestitution ();
			}
			set {
				SetRestitution (value);
			}
		}

		/// <summary>
		/// Return contact processing threshold.
		/// Or
		/// Set contact processing threshold.
		/// </summary>
		public float ContactProcessingThreshold {
			get {
				return GetContactProcessingThreshold ();
			}
			set {
				SetContactProcessingThreshold (value);
			}
		}

		/// <summary>
		/// Return continuous collision detection swept sphere radius.
		/// Or
		/// Set continuous collision detection swept sphere radius.
		/// </summary>
		public float CcdRadius {
			get {
				return GetCcdRadius ();
			}
			set {
				SetCcdRadius (value);
			}
		}

		/// <summary>
		/// Return continuous collision detection motion-per-simulation-step threshold.
		/// Or
		/// Set continuous collision detection motion-per-simulation-step threshold. 0 disables, which is the default.
		/// </summary>
		public float CcdMotionThreshold {
			get {
				return GetCcdMotionThreshold ();
			}
			set {
				SetCcdMotionThreshold (value);
			}
		}

		/// <summary>
		/// Return whether rigid body uses gravity.
		/// Or
		/// Set whether gravity is applied to rigid body.
		/// </summary>
		public bool UseGravity {
			get {
				return GetUseGravity ();
			}
			set {
				SetUseGravity (value);
			}
		}

		/// <summary>
		/// Return gravity override. If zero (default), uses the physics world's gravity.
		/// Or
		/// Set gravity override. If zero, uses physics world's gravity.
		/// </summary>
		public Urho.Vector3 GravityOverride {
			get {
				return GetGravityOverride ();
			}
			set {
				SetGravityOverride (value);
			}
		}

		/// <summary>
		/// Return kinematic mode flag.
		/// Or
		/// Set rigid body kinematic mode. In kinematic mode forces are not applied to the rigid body.
		/// </summary>
		public bool Kinematic {
			get {
				return IsKinematic ();
			}
			set {
				SetKinematic (value);
			}
		}

		/// <summary>
		/// Return whether this RigidBody is acting as a trigger.
		/// Or
		/// Set rigid body trigger mode. In trigger mode collisions are reported but do not apply forces.
		/// </summary>
		public bool Trigger {
			get {
				return IsTrigger ();
			}
			set {
				SetTrigger (value);
			}
		}

		/// <summary>
		/// Return collision layer.
		/// Or
		/// Set collision layer.
		/// </summary>
		public uint CollisionLayer {
			get {
				return GetCollisionLayer ();
			}
			set {
				SetCollisionLayer (value);
			}
		}

		/// <summary>
		/// Return collision mask.
		/// Or
		/// Set collision mask.
		/// </summary>
		public uint CollisionMask {
			get {
				return GetCollisionMask ();
			}
			set {
				SetCollisionMask (value);
			}
		}

		/// <summary>
		/// Return collision event signaling mode.
		/// Or
		/// Set collision event signaling mode. Default is to signal when rigid bodies are active.
		/// </summary>
		public CollisionEventMode CollisionEventMode {
			get {
				return GetCollisionEventMode ();
			}
			set {
				SetCollisionEventMode (value);
			}
		}

		/// <summary>
		/// Return physics world.
		/// </summary>
		public PhysicsWorld PhysicsWorld {
			get {
				return GetPhysicsWorld ();
			}
		}

		/// <summary>
		/// Return center of mass offset.
		/// </summary>
		public Urho.Vector3 CenterOfMass {
			get {
				return GetCenterOfMass ();
			}
		}

		/// <summary>
		/// Return whether rigid body is active (not sleeping.)
		/// </summary>
		public bool Active {
			get {
				return IsActive ();
			}
		}
	}
}
