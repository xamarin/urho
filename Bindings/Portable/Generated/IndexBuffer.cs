// WARNING - AUTOGENERATED - DO NOT EDIT
// 
// Generated using `sharpie urho`
// 
// IndexBuffer.cs
// 
// Copyright 2015 Xamarin Inc. All rights reserved.

using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using Urho.Urho2D;
using Urho.Gui;
using Urho.Resources;
using Urho.IO;
using Urho.Navigation;
using Urho.Network;

namespace Urho
{
	/// <summary>
	/// Hardware index buffer.
	/// </summary>
	public unsafe partial class IndexBuffer : UrhoObject
	{
		public IndexBuffer (IntPtr handle) : base (handle)
		{
		}

		protected IndexBuffer (UrhoObjectFlag emptyFlag) : base (emptyFlag)
		{
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int IndexBuffer_GetType (IntPtr handle);

		private StringHash UrhoGetType ()
		{
			Runtime.ValidateRefCounted (this);
			return new StringHash (IndexBuffer_GetType (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr IndexBuffer_GetTypeName (IntPtr handle);

		private string GetTypeName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (IndexBuffer_GetTypeName (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int IndexBuffer_GetTypeStatic ();

		private static StringHash GetTypeStatic ()
		{
			Runtime.Validate (typeof(IndexBuffer));
			return new StringHash (IndexBuffer_GetTypeStatic ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr IndexBuffer_GetTypeNameStatic ();

		private static string GetTypeNameStatic ()
		{
			Runtime.Validate (typeof(IndexBuffer));
			return Marshal.PtrToStringAnsi (IndexBuffer_GetTypeNameStatic ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr IndexBuffer_IndexBuffer (IntPtr context, bool forceHeadless);

		public IndexBuffer (Context context, bool forceHeadless) : base (UrhoObjectFlag.Empty)
		{
			Runtime.Validate (typeof(IndexBuffer));
			handle = IndexBuffer_IndexBuffer ((object)context == null ? IntPtr.Zero : context.Handle, forceHeadless);
			Runtime.RegisterObject (this);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void IndexBuffer_OnDeviceLost (IntPtr handle);

		/// <summary>
		/// Mark the buffer destroyed on graphics context destruction. May be a no-op depending on the API.
		/// </summary>
		public void OnDeviceLost ()
		{
			Runtime.ValidateRefCounted (this);
			IndexBuffer_OnDeviceLost (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void IndexBuffer_Release (IntPtr handle);

		/// <summary>
		/// Release buffer.
		/// </summary>
		public void Release ()
		{
			Runtime.ValidateRefCounted (this);
			IndexBuffer_Release (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void IndexBuffer_SetShadowed (IntPtr handle, bool enable);

		/// <summary>
		/// Enable shadowing in CPU memory. Shadowing is forced on if the graphics subsystem does not exist.
		/// </summary>
		private void SetShadowed (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			IndexBuffer_SetShadowed (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool IndexBuffer_SetSize (IntPtr handle, uint indexCount, bool largeIndices, bool dynamic);

		/// <summary>
		/// Set size and vertex elements and dynamic mode. Previous data will be lost.
		/// </summary>
		public bool SetSize (uint indexCount, bool largeIndices, bool dynamic)
		{
			Runtime.ValidateRefCounted (this);
			return IndexBuffer_SetSize (handle, indexCount, largeIndices, dynamic);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool IndexBuffer_SetData (IntPtr handle, void* data);

		/// <summary>
		/// Set all data in the buffer.
		/// </summary>
		public bool SetData (void* data)
		{
			Runtime.ValidateRefCounted (this);
			return IndexBuffer_SetData (handle, data);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool IndexBuffer_SetDataRange (IntPtr handle, void* data, uint start, uint count, bool discard);

		/// <summary>
		/// Set a data range in the buffer. Optionally discard data outside the range.
		/// </summary>
		public bool SetDataRange (void* data, uint start, uint count, bool discard)
		{
			Runtime.ValidateRefCounted (this);
			return IndexBuffer_SetDataRange (handle, data, start, count, discard);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr IndexBuffer_Lock (IntPtr handle, uint start, uint count, bool discard);

		/// <summary>
		/// Lock the buffer for write-only editing. Return data pointer if successful. Optionally discard data outside the range.
		/// </summary>
		public IntPtr Lock (uint start, uint count, bool discard)
		{
			Runtime.ValidateRefCounted (this);
			return IndexBuffer_Lock (handle, start, count, discard);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void IndexBuffer_Unlock (IntPtr handle);

		/// <summary>
		/// Unlock the buffer and apply changes to the GPU buffer.
		/// </summary>
		public void Unlock ()
		{
			Runtime.ValidateRefCounted (this);
			IndexBuffer_Unlock (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool IndexBuffer_IsShadowed (IntPtr handle);

		/// <summary>
		/// Return whether CPU memory shadowing is enabled.
		/// </summary>
		private bool IsShadowed ()
		{
			Runtime.ValidateRefCounted (this);
			return IndexBuffer_IsShadowed (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool IndexBuffer_IsDynamic (IntPtr handle);

		/// <summary>
		/// Return whether is dynamic.
		/// </summary>
		private bool IsDynamic ()
		{
			Runtime.ValidateRefCounted (this);
			return IndexBuffer_IsDynamic (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool IndexBuffer_IsLocked (IntPtr handle);

		/// <summary>
		/// Return whether is currently locked.
		/// </summary>
		private bool IsLocked ()
		{
			Runtime.ValidateRefCounted (this);
			return IndexBuffer_IsLocked (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint IndexBuffer_GetIndexCount (IntPtr handle);

		/// <summary>
		/// Return number of indices.
		/// </summary>
		private uint GetIndexCount ()
		{
			Runtime.ValidateRefCounted (this);
			return IndexBuffer_GetIndexCount (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint IndexBuffer_GetIndexSize (IntPtr handle);

		/// <summary>
		/// Return index size in bytes.
		/// </summary>
		private uint GetIndexSize ()
		{
			Runtime.ValidateRefCounted (this);
			return IndexBuffer_GetIndexSize (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern byte* IndexBuffer_GetShadowData (IntPtr handle);

		/// <summary>
		/// Return CPU memory shadow data.
		/// </summary>
		private byte* GetShadowData ()
		{
			Runtime.ValidateRefCounted (this);
			return IndexBuffer_GetShadowData (handle);
		}

		public override StringHash Type {
			get {
				return UrhoGetType ();
			}
		}

		public override string TypeName {
			get {
				return GetTypeName ();
			}
		}

		public static StringHash TypeStatic {
			get {
				return GetTypeStatic ();
			}
		}

		public static string TypeNameStatic {
			get {
				return GetTypeNameStatic ();
			}
		}

		/// <summary>
		/// Return whether CPU memory shadowing is enabled.
		/// Or
		/// Enable shadowing in CPU memory. Shadowing is forced on if the graphics subsystem does not exist.
		/// </summary>
		public bool Shadowed {
			get {
				return IsShadowed ();
			}
			set {
				SetShadowed (value);
			}
		}

		/// <summary>
		/// Return whether is dynamic.
		/// </summary>
		public bool Dynamic {
			get {
				return IsDynamic ();
			}
		}

		/// <summary>
		/// Return whether is currently locked.
		/// </summary>
		public bool Locked {
			get {
				return IsLocked ();
			}
		}

		/// <summary>
		/// Return number of indices.
		/// </summary>
		public uint IndexCount {
			get {
				return GetIndexCount ();
			}
		}

		/// <summary>
		/// Return index size in bytes.
		/// </summary>
		public uint IndexSize {
			get {
				return GetIndexSize ();
			}
		}

		/// <summary>
		/// Return CPU memory shadow data.
		/// </summary>
		public byte* ShadowData {
			get {
				return GetShadowData ();
			}
		}
	}
}
