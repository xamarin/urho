// WARNING - AUTOGENERATED - DO NOT EDIT
// 
// Generated using `sharpie urho`
// 
// Renderer.cs
// 
// Copyright 2015 Xamarin Inc. All rights reserved.

using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using Urho.Urho2D;
using Urho.Gui;
using Urho.Resources;
using Urho.IO;
using Urho.Navigation;
using Urho.Network;

namespace Urho
{
	/// <summary>
	/// High-level rendering subsystem. Manages drawing of 3D views.
	/// </summary>
	public unsafe partial class Renderer : UrhoObject
	{
		unsafe partial void OnRendererCreated ();

		[Preserve]
		public Renderer (IntPtr handle) : base (handle)
		{
			OnRendererCreated ();
		}

		[Preserve]
		protected Renderer (UrhoObjectFlag emptyFlag) : base (emptyFlag)
		{
			OnRendererCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetType (IntPtr handle);

		private StringHash UrhoGetType ()
		{
			Runtime.ValidateRefCounted (this);
			return new StringHash (Renderer_GetType (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetTypeName (IntPtr handle);

		private string GetTypeName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (Renderer_GetTypeName (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetTypeStatic ();

		private static StringHash GetTypeStatic ()
		{
			Runtime.Validate (typeof(Renderer));
			return new StringHash (Renderer_GetTypeStatic ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetTypeNameStatic ();

		private static string GetTypeNameStatic ()
		{
			Runtime.Validate (typeof(Renderer));
			return Marshal.PtrToStringAnsi (Renderer_GetTypeNameStatic ());
		}

		[Preserve]
		public Renderer () : this (Application.CurrentContext)
		{
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_Renderer (IntPtr context);

		[Preserve]
		public Renderer (Context context) : base (UrhoObjectFlag.Empty)
		{
			Runtime.Validate (typeof(Renderer));
			handle = Renderer_Renderer ((object)context == null ? IntPtr.Zero : context.Handle);
			Runtime.RegisterObject (this);
			OnRendererCreated ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetNumViewports (IntPtr handle, uint num);

		/// <summary>
		/// Set number of backbuffer viewports to render.
		/// </summary>
		private void SetNumViewports (uint num)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetNumViewports (handle, num);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetViewport (IntPtr handle, uint index, IntPtr viewport);

		/// <summary>
		/// Set a backbuffer viewport.
		/// </summary>
		public void SetViewport (uint index, Viewport viewport)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetViewport (handle, index, (object)viewport == null ? IntPtr.Zero : viewport.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetDefaultRenderPath (IntPtr handle, IntPtr renderPath);

		/// <summary>
		/// Set default renderpath.
		/// </summary>
		private void SetDefaultRenderPath (RenderPath renderPath)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetDefaultRenderPath (handle, (object)renderPath == null ? IntPtr.Zero : renderPath.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetDefaultRenderPath0 (IntPtr handle, IntPtr file);

		/// <summary>
		/// Set default renderpath from an XML file.
		/// </summary>
		public void SetDefaultRenderPath (Urho.Resources.XmlFile file)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetDefaultRenderPath0 (handle, (object)file == null ? IntPtr.Zero : file.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetDefaultTechnique (IntPtr handle, IntPtr tech);

		/// <summary>
		/// Set default non-textured material technique.
		/// </summary>
		private void SetDefaultTechnique (Technique tech)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetDefaultTechnique (handle, (object)tech == null ? IntPtr.Zero : tech.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetHDRRendering (IntPtr handle, bool enable);

		/// <summary>
		/// Set HDR rendering on/off.
		/// </summary>
		private void SetHDRRendering (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetHDRRendering (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetSpecularLighting (IntPtr handle, bool enable);

		/// <summary>
		/// Set specular lighting on/off.
		/// </summary>
		private void SetSpecularLighting (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetSpecularLighting (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetTextureAnisotropy (IntPtr handle, int level);

		/// <summary>
		/// Set default texture max anisotropy level.
		/// </summary>
		private void SetTextureAnisotropy (int level)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetTextureAnisotropy (handle, level);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetTextureFilterMode (IntPtr handle, TextureFilterMode mode);

		/// <summary>
		/// Set default texture filtering.
		/// </summary>
		private void SetTextureFilterMode (TextureFilterMode mode)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetTextureFilterMode (handle, mode);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetTextureQuality (IntPtr handle, int quality);

		/// <summary>
		/// Set texture quality level. See the QUALITY constants in GraphicsDefs.h.
		/// </summary>
		private void SetTextureQuality (int quality)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetTextureQuality (handle, quality);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetMaterialQuality (IntPtr handle, int quality);

		/// <summary>
		/// Set material quality level. See the QUALITY constants in GraphicsDefs.h.
		/// </summary>
		private void SetMaterialQuality (int quality)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetMaterialQuality (handle, quality);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetDrawShadows (IntPtr handle, bool enable);

		/// <summary>
		/// Set shadows on/off.
		/// </summary>
		private void SetDrawShadows (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetDrawShadows (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetShadowMapSize (IntPtr handle, int size);

		/// <summary>
		/// Set shadow map resolution.
		/// </summary>
		private void SetShadowMapSize (int size)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetShadowMapSize (handle, size);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetShadowQuality (IntPtr handle, ShadowQuality quality);

		/// <summary>
		/// Set shadow quality mode. See the SHADOWQUALITY enum in GraphicsDefs.h.
		/// </summary>
		private void SetShadowQuality (ShadowQuality quality)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetShadowQuality (handle, quality);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetShadowSoftness (IntPtr handle, float shadowSoftness);

		/// <summary>
		/// Set shadow softness, only works when SHADOWQUALITY_BLUR_VSM is used.
		/// </summary>
		private void SetShadowSoftness (float shadowSoftness)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetShadowSoftness (handle, shadowSoftness);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetVSMShadowParameters (IntPtr handle, float minVariance, float lightBleedingReduction);

		/// <summary>
		/// Set shadow parameters when VSM is used, they help to reduce light bleeding. LightBleeding must be in [0, 1[
		/// </summary>
		public void SetVSMShadowParameters (float minVariance, float lightBleedingReduction)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetVSMShadowParameters (handle, minVariance, lightBleedingReduction);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetVSMMultiSample (IntPtr handle, int multiSample);

		/// <summary>
		/// Set VSM shadow map multisampling level. Default 1 (no multisampling.)
		/// </summary>
		private void SetVSMMultiSample (int multiSample)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetVSMMultiSample (handle, multiSample);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetReuseShadowMaps (IntPtr handle, bool enable);

		/// <summary>
		/// Set reuse of shadow maps. Default is true. If disabled, also transparent geometry can be shadowed.
		/// </summary>
		private void SetReuseShadowMaps (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetReuseShadowMaps (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetMaxShadowMaps (IntPtr handle, int shadowMaps);

		/// <summary>
		/// Set maximum number of shadow maps created for one resolution. Only has effect if reuse of shadow maps is disabled.
		/// </summary>
		private void SetMaxShadowMaps (int shadowMaps)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetMaxShadowMaps (handle, shadowMaps);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetDynamicInstancing (IntPtr handle, bool enable);

		/// <summary>
		/// Set dynamic instancing on/off. When on (default), drawables using the same static-type geometry and material will be automatically combined to an instanced draw call.
		/// </summary>
		private void SetDynamicInstancing (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetDynamicInstancing (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetNumExtraInstancingBufferElements (IntPtr handle, int elements);

		/// <summary>
		/// Set number of extra instancing buffer elements. Default is 0. Extra 4-vectors are available through TEXCOORD7 and further.
		/// </summary>
		private void SetNumExtraInstancingBufferElements (int elements)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetNumExtraInstancingBufferElements (handle, elements);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetMinInstances (IntPtr handle, int instances);

		/// <summary>
		/// Set minimum number of instances required in a batch group to render as instanced.
		/// </summary>
		private void SetMinInstances (int instances)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetMinInstances (handle, instances);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetMaxSortedInstances (IntPtr handle, int instances);

		/// <summary>
		/// Set maximum number of sorted instances per batch group. If exceeded, instances are rendered unsorted.
		/// </summary>
		private void SetMaxSortedInstances (int instances)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetMaxSortedInstances (handle, instances);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetMaxOccluderTriangles (IntPtr handle, int triangles);

		/// <summary>
		/// Set maximum number of occluder triangles.
		/// </summary>
		private void SetMaxOccluderTriangles (int triangles)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetMaxOccluderTriangles (handle, triangles);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetOcclusionBufferSize (IntPtr handle, int size);

		/// <summary>
		/// Set occluder buffer width.
		/// </summary>
		private void SetOcclusionBufferSize (int size)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetOcclusionBufferSize (handle, size);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetOccluderSizeThreshold (IntPtr handle, float screenSize);

		/// <summary>
		/// Set required screen size (1.0 = full screen) for occluders.
		/// </summary>
		private void SetOccluderSizeThreshold (float screenSize)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetOccluderSizeThreshold (handle, screenSize);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetThreadedOcclusion (IntPtr handle, bool enable);

		/// <summary>
		/// Set whether to thread occluder rendering. Default false.
		/// </summary>
		private void SetThreadedOcclusion (bool enable)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetThreadedOcclusion (handle, enable);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetMobileShadowBiasMul (IntPtr handle, float mul);

		/// <summary>
		/// Set shadow depth bias multiplier for mobile platforms to counteract possible worse shadow map precision. Default 1.0 (no effect.)
		/// </summary>
		private void SetMobileShadowBiasMul (float mul)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetMobileShadowBiasMul (handle, mul);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetMobileShadowBiasAdd (IntPtr handle, float add);

		/// <summary>
		/// Set shadow depth bias addition for mobile platforms to counteract possible worse shadow map precision. Default 0.0 (no effect.)
		/// </summary>
		private void SetMobileShadowBiasAdd (float add)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetMobileShadowBiasAdd (handle, add);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetMobileNormalOffsetMul (IntPtr handle, float mul);

		/// <summary>
		/// Set shadow normal offset multiplier for mobile platforms to counteract possible worse shadow map precision. Default 1.0 (no effect.)
		/// </summary>
		private void SetMobileNormalOffsetMul (float mul)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetMobileNormalOffsetMul (handle, mul);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_ReloadShaders (IntPtr handle);

		/// <summary>
		/// Force reload of shaders.
		/// </summary>
		public void ReloadShaders ()
		{
			Runtime.ValidateRefCounted (this);
			Renderer_ReloadShaders (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_ApplyShadowMapFilter (IntPtr handle, IntPtr view, IntPtr shadowMap, float blurScale);

		/// <summary>
		/// Apply post processing filter to the shadow map. Called by View.
		/// </summary>
		public void ApplyShadowMapFilter (View view, Texture2D shadowMap, float blurScale)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_ApplyShadowMapFilter (handle, (object)view == null ? IntPtr.Zero : view.Handle, (object)shadowMap == null ? IntPtr.Zero : shadowMap.Handle, blurScale);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Renderer_GetNumViewports (IntPtr handle);

		/// <summary>
		/// Return number of backbuffer viewports.
		/// </summary>
		private uint GetNumViewports ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetNumViewports (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetViewport (IntPtr handle, uint index);

		/// <summary>
		/// Return backbuffer viewport by index.
		/// </summary>
		public Viewport GetViewport (uint index)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Viewport> (Renderer_GetViewport (handle, index));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetDefaultRenderPath (IntPtr handle);

		/// <summary>
		/// Return default renderpath.
		/// </summary>
		private RenderPath GetDefaultRenderPath ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupRefCounted<RenderPath> (Renderer_GetDefaultRenderPath (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetDefaultTechnique (IntPtr handle);

		/// <summary>
		/// Return default non-textured material technique.
		/// </summary>
		private Technique GetDefaultTechnique ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Technique> (Renderer_GetDefaultTechnique (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Renderer_GetHDRRendering (IntPtr handle);

		/// <summary>
		/// Return whether HDR rendering is enabled.
		/// </summary>
		private bool GetHDRRendering ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetHDRRendering (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Renderer_GetSpecularLighting (IntPtr handle);

		/// <summary>
		/// Return whether specular lighting is enabled.
		/// </summary>
		private bool GetSpecularLighting ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetSpecularLighting (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Renderer_GetDrawShadows (IntPtr handle);

		/// <summary>
		/// Return whether drawing shadows is enabled.
		/// </summary>
		private bool GetDrawShadows ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetDrawShadows (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetTextureAnisotropy (IntPtr handle);

		/// <summary>
		/// Return default texture max. anisotropy level.
		/// </summary>
		private int GetTextureAnisotropy ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetTextureAnisotropy (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern TextureFilterMode Renderer_GetTextureFilterMode (IntPtr handle);

		/// <summary>
		/// Return default texture filtering mode.
		/// </summary>
		private TextureFilterMode GetTextureFilterMode ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetTextureFilterMode (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetTextureQuality (IntPtr handle);

		/// <summary>
		/// Return texture quality level.
		/// </summary>
		private int GetTextureQuality ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetTextureQuality (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetMaterialQuality (IntPtr handle);

		/// <summary>
		/// Return material quality level.
		/// </summary>
		private int GetMaterialQuality ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetMaterialQuality (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetShadowMapSize (IntPtr handle);

		/// <summary>
		/// Return shadow map resolution.
		/// </summary>
		private int GetShadowMapSize ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetShadowMapSize (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern ShadowQuality Renderer_GetShadowQuality (IntPtr handle);

		/// <summary>
		/// Return shadow quality.
		/// </summary>
		private ShadowQuality GetShadowQuality ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetShadowQuality (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Renderer_GetShadowSoftness (IntPtr handle);

		/// <summary>
		/// Return shadow softness.
		/// </summary>
		private float GetShadowSoftness ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetShadowSoftness (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern Vector2 Renderer_GetVSMShadowParameters (IntPtr handle);

		/// <summary>
		/// Return VSM shadow parameters.
		/// </summary>
		private Vector2 GetVSMShadowParameters ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetVSMShadowParameters (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetVSMMultiSample (IntPtr handle);

		/// <summary>
		/// Return VSM shadow multisample level.
		/// </summary>
		private int GetVSMMultiSample ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetVSMMultiSample (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Renderer_GetReuseShadowMaps (IntPtr handle);

		/// <summary>
		/// Return whether shadow maps are reused.
		/// </summary>
		private bool GetReuseShadowMaps ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetReuseShadowMaps (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetMaxShadowMaps (IntPtr handle);

		/// <summary>
		/// Return maximum number of shadow maps per resolution.
		/// </summary>
		private int GetMaxShadowMaps ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetMaxShadowMaps (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Renderer_GetDynamicInstancing (IntPtr handle);

		/// <summary>
		/// Return whether dynamic instancing is in use.
		/// </summary>
		private bool GetDynamicInstancing ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetDynamicInstancing (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetNumExtraInstancingBufferElements (IntPtr handle);

		/// <summary>
		/// Return number of extra instancing buffer elements.
		/// </summary>
		private int GetNumExtraInstancingBufferElements ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetNumExtraInstancingBufferElements (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetMinInstances (IntPtr handle);

		/// <summary>
		/// Return minimum number of instances required in a batch group to render as instanced.
		/// </summary>
		private int GetMinInstances ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetMinInstances (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetMaxSortedInstances (IntPtr handle);

		/// <summary>
		/// Return maximum number of sorted instances per batch group.
		/// </summary>
		private int GetMaxSortedInstances ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetMaxSortedInstances (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetMaxOccluderTriangles (IntPtr handle);

		/// <summary>
		/// Return maximum number of occluder triangles.
		/// </summary>
		private int GetMaxOccluderTriangles ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetMaxOccluderTriangles (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int Renderer_GetOcclusionBufferSize (IntPtr handle);

		/// <summary>
		/// Return occlusion buffer width.
		/// </summary>
		private int GetOcclusionBufferSize ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetOcclusionBufferSize (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Renderer_GetOccluderSizeThreshold (IntPtr handle);

		/// <summary>
		/// Return occluder screen size threshold.
		/// </summary>
		private float GetOccluderSizeThreshold ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetOccluderSizeThreshold (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Renderer_GetThreadedOcclusion (IntPtr handle);

		/// <summary>
		/// Return whether occlusion rendering is threaded.
		/// </summary>
		private bool GetThreadedOcclusion ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetThreadedOcclusion (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Renderer_GetMobileShadowBiasMul (IntPtr handle);

		/// <summary>
		/// Return shadow depth bias multiplier for mobile platforms.
		/// </summary>
		private float GetMobileShadowBiasMul ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetMobileShadowBiasMul (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Renderer_GetMobileShadowBiasAdd (IntPtr handle);

		/// <summary>
		/// Return shadow depth bias addition for mobile platforms.
		/// </summary>
		private float GetMobileShadowBiasAdd ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetMobileShadowBiasAdd (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern float Renderer_GetMobileNormalOffsetMul (IntPtr handle);

		/// <summary>
		/// Return shadow normal offset multiplier for mobile platforms.
		/// </summary>
		private float GetMobileNormalOffsetMul ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetMobileNormalOffsetMul (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Renderer_GetNumViews (IntPtr handle);

		/// <summary>
		/// Return number of views rendered.
		/// </summary>
		private uint GetNumViews ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetNumViews (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Renderer_GetNumPrimitives (IntPtr handle);

		/// <summary>
		/// Return number of primitives rendered.
		/// </summary>
		private uint GetNumPrimitives ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetNumPrimitives (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Renderer_GetNumBatches (IntPtr handle);

		/// <summary>
		/// Return number of batches rendered.
		/// </summary>
		private uint GetNumBatches ()
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetNumBatches (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Renderer_GetNumGeometries (IntPtr handle, bool allViews);

		/// <summary>
		/// Return number of geometries rendered.
		/// </summary>
		public uint GetNumGeometries (bool allViews)
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetNumGeometries (handle, allViews);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Renderer_GetNumLights (IntPtr handle, bool allViews);

		/// <summary>
		/// Return number of lights rendered.
		/// </summary>
		public uint GetNumLights (bool allViews)
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetNumLights (handle, allViews);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Renderer_GetNumShadowMaps (IntPtr handle, bool allViews);

		/// <summary>
		/// Return number of shadow maps rendered.
		/// </summary>
		public uint GetNumShadowMaps (bool allViews)
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetNumShadowMaps (handle, allViews);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern uint Renderer_GetNumOccluders (IntPtr handle, bool allViews);

		/// <summary>
		/// Return number of occluders rendered.
		/// </summary>
		public uint GetNumOccluders (bool allViews)
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_GetNumOccluders (handle, allViews);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetDefaultZone (IntPtr handle);

		/// <summary>
		/// Return the default zone.
		/// </summary>
		private Zone GetDefaultZone ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Zone> (Renderer_GetDefaultZone (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetDefaultMaterial (IntPtr handle);

		/// <summary>
		/// Return the default material.
		/// </summary>
		private Material GetDefaultMaterial ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Material> (Renderer_GetDefaultMaterial (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetDefaultLightRamp (IntPtr handle);

		/// <summary>
		/// Return the default range attenuation texture.
		/// </summary>
		private Texture2D GetDefaultLightRamp ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Texture2D> (Renderer_GetDefaultLightRamp (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetDefaultLightSpot (IntPtr handle);

		/// <summary>
		/// Return the default spotlight attenuation texture.
		/// </summary>
		private Texture2D GetDefaultLightSpot ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Texture2D> (Renderer_GetDefaultLightSpot (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetFaceSelectCubeMap (IntPtr handle);

		/// <summary>
		/// Return the shadowed pointlight face selection cube map.
		/// </summary>
		private TextureCube GetFaceSelectCubeMap ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<TextureCube> (Renderer_GetFaceSelectCubeMap (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetIndirectionCubeMap (IntPtr handle);

		/// <summary>
		/// Return the shadowed pointlight indirection cube map.
		/// </summary>
		private TextureCube GetIndirectionCubeMap ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<TextureCube> (Renderer_GetIndirectionCubeMap (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetInstancingBuffer (IntPtr handle);

		/// <summary>
		/// Return the instancing vertex buffer
		/// </summary>
		private VertexBuffer GetInstancingBuffer ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<VertexBuffer> (Renderer_GetInstancingBuffer (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_Update (IntPtr handle, float timeStep);

		/// <summary>
		/// Update for rendering. Called by HandleRenderUpdate().
		/// </summary>
		public void Update (float timeStep)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_Update (handle, timeStep);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_Render (IntPtr handle);

		/// <summary>
		/// Render. Called by Engine.
		/// </summary>
		public void Render ()
		{
			Runtime.ValidateRefCounted (this);
			Renderer_Render (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_DrawDebugGeometry (IntPtr handle, bool depthTest);

		/// <summary>
		/// Add debug geometry to the debug renderer.
		/// </summary>
		public void DrawDebugGeometry (bool depthTest)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_DrawDebugGeometry (handle, depthTest);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_QueueRenderSurface (IntPtr handle, IntPtr renderTarget);

		/// <summary>
		/// Queue a render surface's viewports for rendering. Called by the surface, or by View.
		/// </summary>
		public void QueueRenderSurface (RenderSurface renderTarget)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_QueueRenderSurface (handle, (object)renderTarget == null ? IntPtr.Zero : renderTarget.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_QueueViewport (IntPtr handle, IntPtr renderTarget, IntPtr viewport);

		/// <summary>
		/// Queue a viewport for rendering. Null surface means backbuffer.
		/// </summary>
		public void QueueViewport (RenderSurface renderTarget, Viewport viewport)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_QueueViewport (handle, (object)renderTarget == null ? IntPtr.Zero : renderTarget.Handle, (object)viewport == null ? IntPtr.Zero : viewport.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetLightGeometry (IntPtr handle, IntPtr light);

		/// <summary>
		/// Return volume geometry for a light.
		/// </summary>
		public Geometry GetLightGeometry (Light light)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Geometry> (Renderer_GetLightGeometry (handle, (object)light == null ? IntPtr.Zero : light.Handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetQuadGeometry (IntPtr handle);

		/// <summary>
		/// Return quad geometry used in postprocessing.
		/// </summary>
		private Geometry GetQuadGeometry ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Geometry> (Renderer_GetQuadGeometry (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetShadowMap (IntPtr handle, IntPtr light, IntPtr camera, uint viewWidth, uint viewHeight);

		/// <summary>
		/// Allocate a shadow map. If shadow map reuse is disabled, a different map is returned each time.
		/// </summary>
		public Texture2D GetShadowMap (Light light, Camera camera, uint viewWidth, uint viewHeight)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Texture2D> (Renderer_GetShadowMap (handle, (object)light == null ? IntPtr.Zero : light.Handle, (object)camera == null ? IntPtr.Zero : camera.Handle, viewWidth, viewHeight));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetScreenBuffer (IntPtr handle, int width, int height, uint format, int multiSample, bool autoResolve, bool cubemap, bool filtered, bool srgb, uint persistentKey);

		/// <summary>
		/// Allocate a rendertarget or depth-stencil texture for deferred rendering or postprocessing. Should only be called during actual rendering, not before.
		/// </summary>
		public Texture GetScreenBuffer (int width, int height, uint format, int multiSample, bool autoResolve, bool cubemap, bool filtered, bool srgb, uint persistentKey)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Texture> (Renderer_GetScreenBuffer (handle, width, height, format, multiSample, autoResolve, cubemap, filtered, srgb, persistentKey));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetDepthStencil (IntPtr handle, int width, int height, int multiSample, bool autoResolve);

		/// <summary>
		/// Allocate a depth-stencil surface that does not need to be readable. Should only be called during actual rendering, not before.
		/// </summary>
		public RenderSurface GetDepthStencil (int width, int height, int multiSample, bool autoResolve)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupRefCounted<RenderSurface> (Renderer_GetDepthStencil (handle, width, height, multiSample, autoResolve));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetOcclusionBuffer (IntPtr handle, IntPtr camera);

		/// <summary>
		/// Allocate an occlusion buffer.
		/// </summary>
		public OcclusionBuffer GetOcclusionBuffer (Camera camera)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<OcclusionBuffer> (Renderer_GetOcclusionBuffer (handle, (object)camera == null ? IntPtr.Zero : camera.Handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetShadowCamera (IntPtr handle);

		/// <summary>
		/// Allocate a temporary shadow camera and a scene node for it. Is thread-safe.
		/// </summary>
		private Camera GetShadowCamera ()
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<Camera> (Renderer_GetShadowCamera (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_StorePreparedView (IntPtr handle, IntPtr view, IntPtr cullCamera);

		/// <summary>
		/// Mark a view as prepared by the specified culling camera.
		/// </summary>
		public void StorePreparedView (View view, Camera cullCamera)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_StorePreparedView (handle, (object)view == null ? IntPtr.Zero : view.Handle, (object)cullCamera == null ? IntPtr.Zero : cullCamera.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetPreparedView (IntPtr handle, IntPtr cullCamera);

		/// <summary>
		/// Return a prepared view if exists for the specified camera. Used to avoid duplicate view preparation CPU work.
		/// </summary>
		public View GetPreparedView (Camera cullCamera)
		{
			Runtime.ValidateRefCounted (this);
			return Runtime.LookupObject<View> (Renderer_GetPreparedView (handle, (object)cullCamera == null ? IntPtr.Zero : cullCamera.Handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SetCullMode (IntPtr handle, CullMode mode, IntPtr camera);

		/// <summary>
		/// Set cull mode while taking possible projection flipping into account.
		/// </summary>
		public void SetCullMode (CullMode mode, Camera camera)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SetCullMode (handle, mode, (object)camera == null ? IntPtr.Zero : camera.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern bool Renderer_ResizeInstancingBuffer (IntPtr handle, uint numInstances);

		/// <summary>
		/// Ensure sufficient size of the instancing vertex buffer. Return true if successful.
		/// </summary>
		public bool ResizeInstancingBuffer (uint numInstances)
		{
			Runtime.ValidateRefCounted (this);
			return Renderer_ResizeInstancingBuffer (handle, numInstances);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_SaveScreenBufferAllocations (IntPtr handle);

		/// <summary>
		/// Save the screen buffer allocation status. Called by View.
		/// </summary>
		public void SaveScreenBufferAllocations ()
		{
			Runtime.ValidateRefCounted (this);
			Renderer_SaveScreenBufferAllocations (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_RestoreScreenBufferAllocations (IntPtr handle);

		/// <summary>
		/// Restore the screen buffer allocation status. Called by View.
		/// </summary>
		public void RestoreScreenBufferAllocations ()
		{
			Runtime.ValidateRefCounted (this);
			Renderer_RestoreScreenBufferAllocations (handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_OptimizeLightByScissor (IntPtr handle, IntPtr light, IntPtr camera);

		/// <summary>
		/// Optimize a light by scissor rectangle.
		/// </summary>
		public void OptimizeLightByScissor (Light light, Camera camera)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_OptimizeLightByScissor (handle, (object)light == null ? IntPtr.Zero : light.Handle, (object)camera == null ? IntPtr.Zero : camera.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void Renderer_OptimizeLightByStencil (IntPtr handle, IntPtr light, IntPtr camera);

		/// <summary>
		/// Optimize a light by marking it to the stencil buffer and setting a stencil test.
		/// </summary>
		public void OptimizeLightByStencil (Light light, Camera camera)
		{
			Runtime.ValidateRefCounted (this);
			Renderer_OptimizeLightByStencil (handle, (object)light == null ? IntPtr.Zero : light.Handle, (object)camera == null ? IntPtr.Zero : camera.Handle);
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr Renderer_GetActualView (IntPtr view);

		/// <summary>
		/// Return a view or its source view if it uses one. Used internally for render statistics.
		/// </summary>
		public static View GetActualView (View view)
		{
			Runtime.Validate (typeof(Renderer));
			return Runtime.LookupObject<View> (Renderer_GetActualView ((object)view == null ? IntPtr.Zero : view.Handle));
		}

		public override StringHash Type {
			get {
				return UrhoGetType ();
			}
		}

		public override string TypeName {
			get {
				return GetTypeName ();
			}
		}

		[Preserve]
		public static StringHash TypeStatic {
			get {
				return GetTypeStatic ();
			}
		}

		public static string TypeNameStatic {
			get {
				return GetTypeNameStatic ();
			}
		}

		/// <summary>
		/// Return number of backbuffer viewports.
		/// Or
		/// Set number of backbuffer viewports to render.
		/// </summary>
		public uint NumViewports {
			get {
				return GetNumViewports ();
			}
			set {
				SetNumViewports (value);
			}
		}

		/// <summary>
		/// Return default renderpath.
		/// Or
		/// Set default renderpath.
		/// </summary>
		public RenderPath DefaultRenderPath {
			get {
				return GetDefaultRenderPath ();
			}
			set {
				SetDefaultRenderPath (value);
			}
		}

		/// <summary>
		/// Return default non-textured material technique.
		/// Or
		/// Set default non-textured material technique.
		/// </summary>
		public Technique DefaultTechnique {
			get {
				return GetDefaultTechnique ();
			}
			set {
				SetDefaultTechnique (value);
			}
		}

		/// <summary>
		/// Return whether HDR rendering is enabled.
		/// Or
		/// Set HDR rendering on/off.
		/// </summary>
		public bool HDRRendering {
			get {
				return GetHDRRendering ();
			}
			set {
				SetHDRRendering (value);
			}
		}

		/// <summary>
		/// Return whether specular lighting is enabled.
		/// Or
		/// Set specular lighting on/off.
		/// </summary>
		public bool SpecularLighting {
			get {
				return GetSpecularLighting ();
			}
			set {
				SetSpecularLighting (value);
			}
		}

		/// <summary>
		/// Return default texture max. anisotropy level.
		/// Or
		/// Set default texture max anisotropy level.
		/// </summary>
		public int TextureAnisotropy {
			get {
				return GetTextureAnisotropy ();
			}
			set {
				SetTextureAnisotropy (value);
			}
		}

		/// <summary>
		/// Return default texture filtering mode.
		/// Or
		/// Set default texture filtering.
		/// </summary>
		public TextureFilterMode TextureFilterMode {
			get {
				return GetTextureFilterMode ();
			}
			set {
				SetTextureFilterMode (value);
			}
		}

		/// <summary>
		/// Return texture quality level.
		/// Or
		/// Set texture quality level. See the QUALITY constants in GraphicsDefs.h.
		/// </summary>
		public int TextureQuality {
			get {
				return GetTextureQuality ();
			}
			set {
				SetTextureQuality (value);
			}
		}

		/// <summary>
		/// Return material quality level.
		/// Or
		/// Set material quality level. See the QUALITY constants in GraphicsDefs.h.
		/// </summary>
		public int MaterialQuality {
			get {
				return GetMaterialQuality ();
			}
			set {
				SetMaterialQuality (value);
			}
		}

		/// <summary>
		/// Return whether drawing shadows is enabled.
		/// Or
		/// Set shadows on/off.
		/// </summary>
		public bool DrawShadows {
			get {
				return GetDrawShadows ();
			}
			set {
				SetDrawShadows (value);
			}
		}

		/// <summary>
		/// Return shadow map resolution.
		/// Or
		/// Set shadow map resolution.
		/// </summary>
		public int ShadowMapSize {
			get {
				return GetShadowMapSize ();
			}
			set {
				SetShadowMapSize (value);
			}
		}

		/// <summary>
		/// Return shadow quality.
		/// Or
		/// Set shadow quality mode. See the SHADOWQUALITY enum in GraphicsDefs.h.
		/// </summary>
		public ShadowQuality ShadowQuality {
			get {
				return GetShadowQuality ();
			}
			set {
				SetShadowQuality (value);
			}
		}

		/// <summary>
		/// Return shadow softness.
		/// Or
		/// Set shadow softness, only works when SHADOWQUALITY_BLUR_VSM is used.
		/// </summary>
		public float ShadowSoftness {
			get {
				return GetShadowSoftness ();
			}
			set {
				SetShadowSoftness (value);
			}
		}

		/// <summary>
		/// Return VSM shadow multisample level.
		/// Or
		/// Set VSM shadow map multisampling level. Default 1 (no multisampling.)
		/// </summary>
		public int VSMMultiSample {
			get {
				return GetVSMMultiSample ();
			}
			set {
				SetVSMMultiSample (value);
			}
		}

		/// <summary>
		/// Return whether shadow maps are reused.
		/// Or
		/// Set reuse of shadow maps. Default is true. If disabled, also transparent geometry can be shadowed.
		/// </summary>
		public bool ReuseShadowMaps {
			get {
				return GetReuseShadowMaps ();
			}
			set {
				SetReuseShadowMaps (value);
			}
		}

		/// <summary>
		/// Return maximum number of shadow maps per resolution.
		/// Or
		/// Set maximum number of shadow maps created for one resolution. Only has effect if reuse of shadow maps is disabled.
		/// </summary>
		public int MaxShadowMaps {
			get {
				return GetMaxShadowMaps ();
			}
			set {
				SetMaxShadowMaps (value);
			}
		}

		/// <summary>
		/// Return whether dynamic instancing is in use.
		/// Or
		/// Set dynamic instancing on/off. When on (default), drawables using the same static-type geometry and material will be automatically combined to an instanced draw call.
		/// </summary>
		public bool DynamicInstancing {
			get {
				return GetDynamicInstancing ();
			}
			set {
				SetDynamicInstancing (value);
			}
		}

		/// <summary>
		/// Return number of extra instancing buffer elements.
		/// Or
		/// Set number of extra instancing buffer elements. Default is 0. Extra 4-vectors are available through TEXCOORD7 and further.
		/// </summary>
		public int NumExtraInstancingBufferElements {
			get {
				return GetNumExtraInstancingBufferElements ();
			}
			set {
				SetNumExtraInstancingBufferElements (value);
			}
		}

		/// <summary>
		/// Return minimum number of instances required in a batch group to render as instanced.
		/// Or
		/// Set minimum number of instances required in a batch group to render as instanced.
		/// </summary>
		public int MinInstances {
			get {
				return GetMinInstances ();
			}
			set {
				SetMinInstances (value);
			}
		}

		/// <summary>
		/// Return maximum number of sorted instances per batch group.
		/// Or
		/// Set maximum number of sorted instances per batch group. If exceeded, instances are rendered unsorted.
		/// </summary>
		public int MaxSortedInstances {
			get {
				return GetMaxSortedInstances ();
			}
			set {
				SetMaxSortedInstances (value);
			}
		}

		/// <summary>
		/// Return maximum number of occluder triangles.
		/// Or
		/// Set maximum number of occluder triangles.
		/// </summary>
		public int MaxOccluderTriangles {
			get {
				return GetMaxOccluderTriangles ();
			}
			set {
				SetMaxOccluderTriangles (value);
			}
		}

		/// <summary>
		/// Return occlusion buffer width.
		/// Or
		/// Set occluder buffer width.
		/// </summary>
		public int OcclusionBufferSize {
			get {
				return GetOcclusionBufferSize ();
			}
			set {
				SetOcclusionBufferSize (value);
			}
		}

		/// <summary>
		/// Return occluder screen size threshold.
		/// Or
		/// Set required screen size (1.0 = full screen) for occluders.
		/// </summary>
		public float OccluderSizeThreshold {
			get {
				return GetOccluderSizeThreshold ();
			}
			set {
				SetOccluderSizeThreshold (value);
			}
		}

		/// <summary>
		/// Return whether occlusion rendering is threaded.
		/// Or
		/// Set whether to thread occluder rendering. Default false.
		/// </summary>
		public bool ThreadedOcclusion {
			get {
				return GetThreadedOcclusion ();
			}
			set {
				SetThreadedOcclusion (value);
			}
		}

		/// <summary>
		/// Return shadow depth bias multiplier for mobile platforms.
		/// Or
		/// Set shadow depth bias multiplier for mobile platforms to counteract possible worse shadow map precision. Default 1.0 (no effect.)
		/// </summary>
		public float MobileShadowBiasMul {
			get {
				return GetMobileShadowBiasMul ();
			}
			set {
				SetMobileShadowBiasMul (value);
			}
		}

		/// <summary>
		/// Return shadow depth bias addition for mobile platforms.
		/// Or
		/// Set shadow depth bias addition for mobile platforms to counteract possible worse shadow map precision. Default 0.0 (no effect.)
		/// </summary>
		public float MobileShadowBiasAdd {
			get {
				return GetMobileShadowBiasAdd ();
			}
			set {
				SetMobileShadowBiasAdd (value);
			}
		}

		/// <summary>
		/// Return shadow normal offset multiplier for mobile platforms.
		/// Or
		/// Set shadow normal offset multiplier for mobile platforms to counteract possible worse shadow map precision. Default 1.0 (no effect.)
		/// </summary>
		public float MobileNormalOffsetMul {
			get {
				return GetMobileNormalOffsetMul ();
			}
			set {
				SetMobileNormalOffsetMul (value);
			}
		}

		/// <summary>
		/// Return VSM shadow parameters.
		/// </summary>
		public Vector2 VSMShadowParameters {
			get {
				return GetVSMShadowParameters ();
			}
		}

		/// <summary>
		/// Return number of views rendered.
		/// </summary>
		public uint NumViews {
			get {
				return GetNumViews ();
			}
		}

		/// <summary>
		/// Return number of primitives rendered.
		/// </summary>
		public uint NumPrimitives {
			get {
				return GetNumPrimitives ();
			}
		}

		/// <summary>
		/// Return number of batches rendered.
		/// </summary>
		public uint NumBatches {
			get {
				return GetNumBatches ();
			}
		}

		/// <summary>
		/// Return the default zone.
		/// </summary>
		public Zone DefaultZone {
			get {
				return GetDefaultZone ();
			}
		}

		/// <summary>
		/// Return the default material.
		/// </summary>
		public Material DefaultMaterial {
			get {
				return GetDefaultMaterial ();
			}
		}

		/// <summary>
		/// Return the default range attenuation texture.
		/// </summary>
		public Texture2D DefaultLightRamp {
			get {
				return GetDefaultLightRamp ();
			}
		}

		/// <summary>
		/// Return the default spotlight attenuation texture.
		/// </summary>
		public Texture2D DefaultLightSpot {
			get {
				return GetDefaultLightSpot ();
			}
		}

		/// <summary>
		/// Return the shadowed pointlight face selection cube map.
		/// </summary>
		public TextureCube FaceSelectCubeMap {
			get {
				return GetFaceSelectCubeMap ();
			}
		}

		/// <summary>
		/// Return the shadowed pointlight indirection cube map.
		/// </summary>
		public TextureCube IndirectionCubeMap {
			get {
				return GetIndirectionCubeMap ();
			}
		}

		/// <summary>
		/// Return the instancing vertex buffer
		/// </summary>
		public VertexBuffer InstancingBuffer {
			get {
				return GetInstancingBuffer ();
			}
		}

		/// <summary>
		/// Return quad geometry used in postprocessing.
		/// </summary>
		public Geometry QuadGeometry {
			get {
				return GetQuadGeometry ();
			}
		}

		/// <summary>
		/// Allocate a temporary shadow camera and a scene node for it. Is thread-safe.
		/// </summary>
		public Camera ShadowCamera {
			get {
				return GetShadowCamera ();
			}
		}
	}
}
