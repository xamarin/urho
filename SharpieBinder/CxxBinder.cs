//
// CURRENTLY
//    Generate base classes without a call to base
//    Generate the standard idioms/patterns for init, dispose
//
// WARNING
//
//    This file still contains code from the original CppBind, it is some legacy code
//    so it might be possible to remove.
//
//TODO:
//  operators
// 

using System;
using System.IO;
using System.Collections.Generic;
using System.Diagnostics;
using Clang.Ast;
using ICSharpCode.NRefactory.CSharp;
using System.Linq;
using Attribute = ICSharpCode.NRefactory.CSharp.Attribute;
using System.Reflection;
using System.Runtime.InteropServices;
using Sharpie.Bind;
using System.Text;
using UnwrapTypeInfo = System.Tuple<string, string, string[]>;

namespace SharpieBinder
{
	class CxxBinder : AstVisitor
	{
		CSharpParser csParser = new CSharpParser();

		public static Clang.Ast.Type CleanType(QualType qt)
		{
			var et = qt.Type as ElaboratedType;
			if (et == null)
				return qt.Type;
			return et.UnqualifiedDesugaredType;
		}

		public static string CleanTypeCplusplus(QualType qt)
		{
			var s = CleanType(qt).ToString();
			if (s == "_Bool")
				return "bool";

			// Ok, I want to click on that blue thing and use the action, the "1"//
			if (s.IndexOf("_Bool") != -1)
				Console.WriteLine("f");
			if (s.StartsWith("class ")) {
				s = s.Substring(6);
				return s;
			}
			if (s.StartsWith("struct "))
				return s.Substring(7);

			return s;
		}

		class BaseNodeType
		{
			public CXXRecordDecl Decl { get; set; }

			readonly Action<CXXRecordDecl, CXXRecordDecl> bindHandler;

			public BaseNodeType(Action<CXXRecordDecl, CXXRecordDecl> bindHandler)
			{
				this.bindHandler = bindHandler;
			}

			public void Bind()
			{
				bindHandler(null, Decl);
			}

			public void Bind(CXXRecordDecl decl)
			{
				bindHandler(Decl, decl);
			}
		}

		readonly List<SyntaxTree> syntaxTrees = new List<SyntaxTree>();
		readonly Dictionary<string, BaseNodeType> baseNodeTypes;
		readonly List<string> extraClasses;

		TypeDeclaration currentType;
		StreamWriter cbindingStream;

		public CxxBinder(string outputDir)
		{
			baseNodeTypes = new Dictionary<string, BaseNodeType>
			{
				["Urho3D::Object"] = new BaseNodeType(Bind),
				["Urho3D::RefCounted"] = new BaseNodeType(Bind),
				["Urho3D::RefCount"] = new BaseNodeType(Bind),
				["Urho3D::String"] = new BaseNodeType(Bind),
				["Urho3D::XMLElement"] = new BaseNodeType(Bind),
				["Urho3D::Frustum"] = new BaseNodeType(Bind),
				["Urho3D::Polyhedron"] = new BaseNodeType(Bind),
				["Urho3D::Skeleton"] = new BaseNodeType(Bind),
				["Urho3D::GPUObject"] = new BaseNodeType(Bind),
			};
			cbindingStream = File.CreateText(Path.Combine(outputDir, "binding.cpp"));
			pn("// Autogenerated, do not edit");
			pn("#include \"../../Native/AllUrho.h\"");
			pn("#include \"../../Native/interop.h\"");
			pn("using namespace Urho3D;");
			pn("extern \"C\" {");

			extraClasses = new List<string>
			{
				"AreaAllocator",
				"Spline",
				"Sphere",
				"SceneResolver",
				"UIBatch"
			};
		}

		public void Close()
		{
			pn ("}");
			cbindingStream.Close();
			cbindingStream = null;
		}

		public IEnumerable<SyntaxTree> Generate()
		{
			foreach (var syntaxTree in syntaxTrees) {
				//syntaxTree.AcceptVisitor(new Sharpie.Bind.Massagers.GenerateUsingStatementsMassager());
				yield return syntaxTree;
			}
		}

		void PushType(TypeDeclaration typeDeclaration, IEnumerable<string> comments)
		{
			var hostns = NamespaceRegistry.DetermineNamespace(typeDeclaration.Name);
			var syntaxTree = new SyntaxTree { FileName = typeDeclaration.Name + ".cs" };

			Commenter.InsertHeader(syntaxTree);

			syntaxTree.Members.Add(new UsingDeclaration("System"));
			syntaxTree.Members.Add(new UsingDeclaration() { Import = new SimpleType("System.Runtime.InteropServices") });
			syntaxTree.Members.Add(new UsingDeclaration() { Import = new SimpleType("System.Collections.Generic") });
			syntaxTree.Members.Add(new UsingDeclaration() { Import = new SimpleType("Urho.Urho2D") });
			syntaxTree.Members.Add(new UsingDeclaration() { Import = new SimpleType("Urho.Gui") });
			syntaxTree.Members.Add(new UsingDeclaration() { Import = new SimpleType("Urho.Resources") });
			syntaxTree.Members.Add(new UsingDeclaration() { Import = new SimpleType("Urho.IO") });
			syntaxTree.Members.Add(new UsingDeclaration() { Import = new SimpleType("Urho.Navigation") });
			syntaxTree.Members.Add(new UsingDeclaration() { Import = new SimpleType("Urho.Network") });

			var ns = new NamespaceDeclaration(hostns);
			syntaxTree.Members.Add(ns);
			syntaxTrees.Add(syntaxTree);

			allTypes[typeDeclaration.Name] = typeDeclaration;
			currentTypeNames.Clear();
			uniqueMethodName = 0;
			ns.Members.Add(currentType = typeDeclaration);
			Commenter.InsertSummary(currentType, comments);
		}

		HashSet<string> currentTypeNames = new HashSet<string>();
		int uniqueMethodName;
		Dictionary<string, TypeDeclaration> allTypes = new Dictionary<string, TypeDeclaration>();
		public HashSet<string> unhandledEnums = new HashSet<string> ();

		public override void VisitEnumDecl(EnumDecl decl, VisitKind visitKind)
		{
			if (visitKind != VisitKind.Enter || !decl.IsCompleteDefinition || decl.QualifiedName == null)
				return;

			if (!decl.QualifiedName.StartsWith ("Urho")) {
				if (!decl.QualifiedName.ToLower ().Contains ("loopmode2d"))
			
				return;
			}
			
			string typeName = RemapTypeName(decl.Name);

			PushType(new TypeDeclaration
			{
				Name = typeName,
				ClassType = ClassType.Enum,
				Modifiers = Modifiers.Public
			}, StringUtil.GetTypeComments(decl));

			foreach (var constantDecl in decl.Decls<EnumConstantDecl>()) {
				var valueName = StringUtil. RemapEnumName (typeName, constantDecl.Name);
				var enumValue = new EnumMemberDeclaration { Name = valueName };
				if (constantDecl.InitExpr != null) {
					APSInt v;
					constantDecl.InitExpr.EvaluateAsInt (decl.AstContext, out v);
					var ul = v.GetLimitedValue ();
					PrimitiveExpression value;
					if ((ul & 0xffffffff) == ul)
						value = new PrimitiveExpression ((int)ul);
					else
						throw new NotImplementedException ($"Got a {ul} value which will not fit on an int, you must manually handle this case in the generatorg");
					enumValue.Initializer = value;
				}
				currentType.Members.Add(enumValue);
			}
		}

		public override void VisitCXXRecordDecl(CXXRecordDecl decl, VisitKind visitKind)
		{
			if (visitKind != VisitKind.Enter || !decl.IsCompleteDefinition || decl.Name == null) {
				return;
			}
			if (visitKind == VisitKind.Leave)
				currentType = null;

			BaseNodeType baseNodeType;
			if (baseNodeTypes.TryGetValue(decl.QualifiedName, out baseNodeType)) {
				baseNodeType.Decl = decl;
				baseNodeType.Bind();
				return;
			}

			foreach (var bnt in baseNodeTypes.Values) {
				if (bnt.Decl != null && decl.IsDerivedFrom(bnt.Decl)) {
					bnt.Bind(decl);
					return;
				}
			}
			
			// Some of the api are not inherited from anything
			// They should be start with Urho3D and we should skip Variants         
			if (decl.Attrs.Any(a=> a.Kind == AttrKind.Visibility) && 
				decl.QualifiedName.StartsWith("Urho3D::", StringComparison.CurrentCulture) &&
				decl.Bases.Count() < 1 &&
				extraClasses.Contains(decl.Name))
                
				new BaseNodeType(Bind).Bind(decl);
		}

		//
		// Determines if this is a structure that is part of native interop, so we would
		// keep the layout the same as managed code
		//
		public bool IsStructure(CXXRecordDecl decl)
		{
			// Quick and dirty: it really should use our manually curated list of known value types,
			// but for now, this will do
			var classesNotStructs = new[] {"String", "Skeleton", "XMLElement", "GPUObject", "Frustum", "Polyhedron"};
			if (classesNotStructs.Contains(decl.Name))
				return false;

			if (decl.TagKind == TagDeclKind.Struct || !(decl.IsDerivedFrom(ScanBaseTypes.UrhoRefCounted) || decl == ScanBaseTypes.UrhoRefCounted))
				if (!extraClasses.Contains(decl.Name))
					return true;
			
			return false;
		}

		static readonly string[] TypesToIgnore = { "BackgroundLoader" };
		static readonly string[] TypesWithoutUnsafeKeyword = { "Application" };

		void Bind(CXXRecordDecl baseDecl, CXXRecordDecl decl)
		{
			if (TypesToIgnore.Contains(decl.Name))
				return;

			bool isStruct = IsStructure (decl);

			var modifiers = Modifiers.Partial | Modifiers.Public;
			if (!TypesWithoutUnsafeKeyword.Contains(decl.Name))
				modifiers |= Modifiers.Unsafe;

			PushType(new TypeDeclaration
			{
				Name = RemapTypeName (decl.Name),
				ClassType = isStruct ? ClassType.Struct : ClassType.Class,
				Modifiers = modifiers
			}, StringUtil.GetTypeComments(decl));

			if (extraClasses.Contains(decl.Name) && !decl.Bases.Any())
			{
				//Extra classes who have no any base should contains handle field and property
				var handleField = new FieldDeclaration()
				{
					Modifiers = Modifiers.Private,
					ReturnType = AstType.Create("IntPtr")
				};
				handleField.Variables.Add(new VariableInitializer("handle"));
				currentType.Members.Add(handleField);

				var handleProp = new PropertyDeclaration()
				{
					Modifiers = Modifiers.Public,
					ReturnType = AstType.Create("IntPtr"),
					Name = "Handle",
					Getter = new Accessor()
					{
						Body = new BlockStatement() {
							new ReturnStatement (new IdentifierExpression("handle"))
						}
					}
				};
				currentType.Members.Add(handleProp);
			}

			if (baseDecl != null) {
				foreach (var baseType in decl.Bases) {
					var baseName = baseType.Decl?.Name;
					if (baseName == null)
						continue;

					// WorkItem is a structure, with a RefCount base class, avoid that
					if (IsStructure(decl))
						continue;
					// 
					// Only a (File, MemoryBuffer, VectorBuffer)
					// implement that, and the Serializer class is never
					// surfaced as an API entry point, so we should just inline the methods
					// from those classes into the generated class

					var baseNamesToIgnore = new[] { "Thread", "Octant", "b2Draw", "b2ContactListener", "btIDebugDraw", "btMotionState" };
					if (baseNamesToIgnore.Contains(baseName))
						continue;

					if (currentType.BaseTypes.Count > 0)
						baseName = "I" + baseName;

					currentType.BaseTypes.Add(new SimpleType(RemapTypeName(baseName)));
				}
			}

			// Determines if this is a subclass of RefCounted (but not RefCounted itself)
			bool refCountedSubclass = decl.TagKind == TagDeclKind.Class && decl.QualifiedName != "Urho3D::RefCounted" && decl.IsDerivedFrom(ScanBaseTypes.UrhoRefCounted);
			// Same for Urho3D::Object
			bool objectSubclass = decl.TagKind == TagDeclKind.Class && decl.QualifiedName != "Urho3D::Object" && decl.IsDerivedFrom(ScanBaseTypes.UrhoObjectType);

			var initMethod = new MethodDeclaration
			{
				ReturnType = new PrimitiveType("void"),
				Modifiers = Modifiers.Unsafe | Modifiers.Partial,
				// I have to add "currentType.Name" due to NRefactory bug
				// otherwise it adds "override" keyword even if it's not specified (Modifier.Private can not be used with partial)
				Name = "On" + currentType.Name + "Created"
			};

			currentType.Members.Add(initMethod);

			if (refCountedSubclass) 
			{
				var nativeCtor = new ConstructorDeclaration
				{
					Modifiers = Modifiers.Public,
					Body = new BlockStatement(),
					Initializer = new ConstructorInitializer()
				};

				var initMethodCall = new InvocationExpression(new IdentifierExpression(initMethod.Name), null);

				nativeCtor.Attributes.Add(CreatePreserveAttribute());
				nativeCtor.Parameters.Add(new ParameterDeclaration(new SimpleType(nameof(IntPtr)), "handle"));
				nativeCtor.Initializer.Arguments.Add(new IdentifierExpression("handle"));

				nativeCtor.Body.Add(initMethodCall.Clone());
				currentType.Members.Add(nativeCtor);

				// The construtor with the emtpy chain flag
				nativeCtor = new ConstructorDeclaration
				{
					Modifiers = Modifiers.Protected,
					Body = new BlockStatement(),
					Initializer = new ConstructorInitializer()
				};


				nativeCtor.Attributes.Add(CreatePreserveAttribute());
				nativeCtor.Parameters.Add(new ParameterDeclaration(new SimpleType("UrhoObjectFlag"), "emptyFlag"));
				nativeCtor.Initializer.Arguments.Add(new IdentifierExpression("emptyFlag"));

				nativeCtor.Body.Add(initMethodCall.Clone());
				currentType.Members.Add(nativeCtor);

			} else if (IsStructure(decl)) {
				var serializable = new Attribute()
				{
					Type = new SimpleType("StructLayout")
				};

				serializable.Arguments.Add(new TypeReferenceExpression(new MemberType(new SimpleType("LayoutKind"), "Sequential")));
				var attrs = new AttributeSection();
				attrs.Attributes.Add(serializable);
				currentType.Attributes.Add(attrs);
			}

			if (currentType.BaseTypes.Any(t => ((SimpleType)t).Identifier == "IGPUObject"))
			{
				var pinvoke = new MethodDeclaration {
					Name = currentType.Name + "_CastToGPUObject",
					ReturnType = new SimpleType("IntPtr"),
					Modifiers = Modifiers.Extern | Modifiers.Static | Modifiers.Internal
				};
				pinvoke.Parameters.Add(new ParameterDeclaration(new SimpleType(nameof(IntPtr)), "handle"));
				pinvoke.Attributes.Add(CreateDllImportAttribute());
				currentType.Members.Add(pinvoke);

				var asGpuObjectMethod = new MethodDeclaration {
					ReturnType = new SimpleType("GPUObject"),
					Modifiers = Modifiers.Public,
					Name = "AsGPUObject",
				};

				var handleCastInvocation = new InvocationExpression(new IdentifierExpression(pinvoke.Name), new IdentifierExpression("handle"));
				asGpuObjectMethod.Body = new BlockStatement();
				asGpuObjectMethod.Body.Add(new ReturnStatement(new ObjectCreateExpression(new SimpleType("GPUObject"), handleCastInvocation)));
				currentType.Members.Add(asGpuObjectMethod);

				string cpp = "DllExport GPUObject*\n" +
				  $"{pinvoke.Name}(Urho3D::{currentType.Name} *_target)\n" +
				  "{\n\treturn static_cast<GPUObject*>(_target);\n}\n";

				if (currentType.Name == "ShaderProgram")
					cpp = "#if defined(URHO3D_OPENGL)\n" + cpp + "#endif\n";

				p(cpp);
			}
		}

		public AttributeSection CreatePreserveAttribute()
		{
			var atr = new Attribute { Type = new SimpleType("Preserve") };
			// AllMembers = value ?
			return new AttributeSection(atr);
		}
		
		const string ConstStringReference = "const class Urho3D::String &";

		static bool IsVariantType(QualType qt)
		{
			var ct = CleanType(qt);
			var ctstring = ct.ToString();
			return ctstring == "const class Urho3D::Variant &";
		}

		// Temporary, just to help us get the bindings bootstrapped
		// 
		// This limits which C++ types we can bind, and lets us progressively add more
		static bool IsUnsupportedType(QualType qt, bool returnType = false)
		{
			var ct = CleanType(qt);
			var ctstring = ct.ToString ();

			// String references are hand-bound, so we are going to let those though
			if (ctstring == ConstStringReference || ctstring == "const Urho3D::String &")
				return false;

			switch (ctstring) {
			case "const class Urho3D::Vector3 &":
			case "const class Urho3D::IntRect &":
			case "const class Urho3D::Color &":
			case "const class Urho3D::Vector2 &":
			case "const class Urho3D::Vector4 &":
			case "const class Urho3D::IntVector2 &":
			case "const class Urho3D::Quaternion &":
			case "const class Urho3D::Plane &":
			case "const class Urho3D::Matrix4 &":
			case "const class Urho3D::Matrix3x4 &":
			case "const class Urho3D::BoundingBox &":
			case "const struct Urho3D::BiasParameters &":
			case "const struct Urho3D::FocusParameters &":
			case "const struct Urho3D::CascadeParameters &":
			case "const struct Urho3D::TileMapInfo2D &":
			case "const struct Urho3D::RenderPathCommand &":
			case "const class Urho3D::XMLElement &":
			case "const class Urho3D::Frustum &":
			case "class Urho3D::Frustum &":
			case "class Urho3D::Frustum":
			case "const class Urho3D::Sphere &":
			case "class Urho3D::Sphere &":
			case "class Urho3D::Sphere":
			case "const class Urho3D::Polyhedron &":
			case "class Urho3D::Polyhedron &":
			case "class Urho3D::Polyhedron":
			case "class Urho3D::XMLElement":
			case "class Urho3D::XMLElement &":
			case "struct Urho3D::PhysicsRaycastResult &":
			case "const class Urho3D::Ray &":
			case "class Urho3D::Image &":
			case "const struct Urho3D::CrowdObstacleAvoidanceParams &":
			case "class Urho3D::Serializer &":
			case "class Urho3D::Deserializer &":
			case "const class Urho3D::Variant &":
			case "int &":
			case "float &":
				return false;
			}

			if (returnType) {
				switch (ctstring) {
				case "const Vector<SharedPtr<class Urho3D::Node> > &":
				case "const Vector<SharedPtr<class Urho3D::Component> > &":
				case "const Vector<SharedPtr<class Urho3D::VertexBuffer> > &":
				case "const Vector<SharedPtr<class Urho3D::IndexBuffer> > &":
				case "const Vector<SharedPtr<class Urho3D::UIElement> > &":
				case "const Vector<SharedPtr<class Urho3D::PackageFile> > &":
				case "const Vector<SharedPtr<class Urho3D::Texture2D> > &":
				case "const Vector<SharedPtr<class Urho3D::AnimationState> > &":
					return false;
				}
#if false
				if (ctstring.Contains ("Vector")) {
					if (!displayed.Contains (ctstring)) {
						Console.WriteLine (ctstring);
						displayed.Add (ctstring);
					}
				}
#endif
			}

			if (ctstring.StartsWith("SharedPtr<") && returnType)
				return false;

			var s = ct.Bind().ToString();
			if (s.Contains ("unsupported")) {
				return true;
			}

			// Quick hack, just while we get thigns going
			if (s.Contains("EventHandler**")) {
				return true;
			}
			if (s.Contains("b2") || s.Contains ("bt"))
				return true;
			
			// Candidate for a hand binding (Connection.h)
			if (qt.ToString().Contains("kNet::SharedPtr"))
				return true;
			if (s.Contains("Frustum"))
				return true;
			if (s.Contains("Polyhedron"))
				return true;
			if (s.Contains("XMLElement"))
				return true;
			if (s.Contains ("CollisionGeometryData"))
				return true;
			if (s.Contains ("SDL"))
				return true;
			if (s.Contains("BackgroundLoader"))
				return true;
			return false;
		}

		// 
		// Given a pointer type, returns the underlying type 
		//
		static RecordType GetPointersUnderlyingType(PointerType ptrType)
		{
			return ptrType.PointeeQualType.Type.UnqualifiedDesugaredType as RecordType;
		}

		// Describes how a given type should be mapped from our managed API to the P/Invoke call
		enum WrapKind
		{
			None,				// no wrapping needed
			HandleMember,		// access the .Handle on the parameter
			UrhoObject,			// access the .Handle on the parameter, but the object is known to be an UrhoObject.
			SimpleObject,
			EventHandler,		// 
			StringHash,			// StringHash is handled specially (we surface StringHash, but we always pass an int/receive an int)
			VectorSharedPtr,	// Used to marshal Vector pointers, by using an implementation of a IList<T> 
			RefBlittable,		// Used for blittable value types that are surfaced as reference classes
			MarshalPtrToString,	// Used for strings used as return types (we use IntPtr instead of string to avoid Heap Corruption Exceptions)
			MarshalPtrToStruct
		}
		// 
		// Given a Clang QualType, returns the AstType to use to marshal, both for the 
		// P/Invoke signature and for the high level binding
		//
		// Handles RefCounted objects that we wrap
		//
		void LookupMarshalTypes(QualType qt, 
		                        out AstType lowLevel, out ICSharpCode.NRefactory.CSharp.ParameterModifier lowLevelParameterMod, 
		                        out AstType highLevel, out ICSharpCode.NRefactory.CSharp.ParameterModifier highLevelParameterMod, 
		                        out WrapKind wrapKind, bool isReturn = false)
		{
			wrapKind = WrapKind.None;
			lowLevelParameterMod = ICSharpCode.NRefactory.CSharp.ParameterModifier.None;
			highLevelParameterMod = ICSharpCode.NRefactory.CSharp.ParameterModifier.None;

			var cleanType = CleanType(qt);
			var cleanTypeStr = cleanType.ToString();
			var typeName = cleanTypeStr
					.DropConst()
					.DropClassOrStructPrefix()
					.DropUrhoNamespace();

			bool hasConst = cleanTypeStr.Contains("const ");

			switch (typeName) {
			case "char *":
				lowLevel = new PrimitiveType("string");
				highLevel = new PrimitiveType("string");
				return;
			case "ThreadID":
			// Troublesome because on windows it is a sizeof(unsigned), on unix sizeof(pthread_t), which is 
			// 32 or 64 bits.
			case "void *":
			case "GPUObject *":
				lowLevel = new PrimitiveType(hasConst ? "void*" : nameof(IntPtr));
				highLevel = new PrimitiveType(hasConst ? "void*" : nameof(IntPtr));
				return;
			case "String &":
			case "String":
			case ConstStringReference:
				if (isReturn) {
					lowLevel = new PrimitiveType(nameof(IntPtr));
					highLevel = new PrimitiveType("string");
					wrapKind = WrapKind.MarshalPtrToString;
					return;
				} else {
					lowLevel = new PrimitiveType("string");
					highLevel = new PrimitiveType("string");
					return;
				}
			case "Vector2 &":
			case "Vector3 &":
			case "Vector4 &":
			case "Matrix4 &":
			case "Matrix3x4 &":
			case "Quaternion &":
			case "Plane &":
			case "BoundingBox &":
			case "Color &":
			case "IntVector2 &":
			case "IntVector2":
			case "IntRect &":
			case "TileMapInfo2D &":
			case "RenderPathCommand &":
			case "Ray &":
				var simpleType = NamespaceRegistry.RemapTypeToNamespace (cleanTypeStr.DropConstAndReference().DropClassOrStructPrefix().DropUrhoNamespace().RemapAcronyms());
				highLevel = new SimpleType (simpleType);
				lowLevel = new SimpleType (simpleType);
				lowLevelParameterMod = ICSharpCode.NRefactory.CSharp.ParameterModifier.Ref;
				wrapKind = WrapKind.RefBlittable;
				return;
			case "int &":
			case "float &":
				var primitiveType = cleanTypeStr.DropConstAndReference();
				highLevel = new PrimitiveType(primitiveType);
				lowLevel = new PrimitiveType(primitiveType);
				lowLevelParameterMod = ICSharpCode.NRefactory.CSharp.ParameterModifier.Ref;
				highLevelParameterMod = ICSharpCode.NRefactory.CSharp.ParameterModifier.Ref;
				wrapKind = WrapKind.RefBlittable;
				return;
			case "Image &":
				highLevel = new SimpleType("Image");
				lowLevel = new SimpleType(nameof(IntPtr));
				wrapKind = WrapKind.HandleMember;
				return;
			case "XMLElement &":
			case "XMLElement":
			case "Polyhedron":
			case "Polyhedron &":
			case "Frustum":
			case "Frustum &":
			case "Sphere":
			case "Sphere &":
				highLevel = new SimpleType(typeName.RemapAcronyms().DropConstAndReference());
				lowLevel = new SimpleType (nameof(IntPtr));
				wrapKind = WrapKind.SimpleObject;
				return;
			case "PhysicsRaycastResult &":
				lowLevelParameterMod = ICSharpCode.NRefactory.CSharp.ParameterModifier.Ref;
				highLevelParameterMod = ICSharpCode.NRefactory.CSharp.ParameterModifier.Ref;
				highLevel = new SimpleType ("PhysicsRaycastResult");
				lowLevel = new SimpleType ("PhysicsRaycastResult");
				wrapKind = WrapKind.RefBlittable;
				return;
			case "CrowdObstacleAvoidanceParams &":
			case "BiasParameters &":
			case "FocusParameters &":
			case "CascadeParameters &":
				lowLevelParameterMod = ICSharpCode.NRefactory.CSharp.ParameterModifier.Ref;
				var structName = cleanTypeStr.DropConstAndReference().DropClassOrStructPrefix().DropUrhoNamespace();
				highLevel = new SimpleType (structName);
				lowLevel = new SimpleType (structName);
				wrapKind = WrapKind.RefBlittable;
				return;
			case "Serializer &":
			case "Deserializer &":
				highLevel = new SimpleType ("DeSerializer");
				lowLevel = new SimpleType (nameof(IntPtr));
				wrapKind = WrapKind.HandleMember;
				return;
			case "TouchState *":
				if (isReturn)
				{
					lowLevel = new PrimitiveType(nameof(IntPtr));
					highLevel = new SimpleType("TouchState");
					wrapKind = WrapKind.MarshalPtrToStruct;
					return;
				}
				break;

				// currently "Vector<X> &" are only supported for return values
			case "Vector<SharedPtr<class Urho3D::AnimationState> > &":
			case "Vector<SharedPtr<class Urho3D::Node> > &":
			case "Vector<SharedPtr<class Urho3D::Component> > &":
			case "Vector<SharedPtr<class Urho3D::VertexBuffer> > &":
			case "Vector<SharedPtr<class Urho3D::IndexBuffer> > &":
			case "Vector<SharedPtr<class Urho3D::UIElement> > &":
			case "Vector<SharedPtr<class Urho3D::PackageFile> > &":
			case "Vector<SharedPtr<class Urho3D::Texture2D> > &":
				var sp = cleanTypeStr.IndexOf ("::");
				var ep = cleanTypeStr.IndexOf ("> >");
				string tn = cleanTypeStr.Substring (sp + 2, ep - sp - 2);

				highLevel = csParser.ParseTypeReference ("IReadOnlyList<" + tn + ">");
				lowLevel = new SimpleType (nameof(IntPtr));
				wrapKind = WrapKind.VectorSharedPtr;
				return;
			case "StringHash":
				highLevel = new SimpleType ("StringHash");
				lowLevel = new PrimitiveType ("int");
				wrapKind = WrapKind.StringHash;
				return;
			default:
				//Console.WriteLine (cleanTypeStr);
				break;
			}

			if (isReturn && cleanTypeStr.Contains("SharedPtr<"))
			{
				string type = cleanTypeStr.ExtractGenericParameter().DropClassOrStructPrefix().DropUrhoNamespace();
				highLevel = new SimpleType(RemapTypeName(type));
				if (cleanTypeStr.Contains("class")) //TODO: inspect underlying type instead
				{
					wrapKind = WrapKind.HandleMember;
					lowLevel = new SimpleType(nameof(IntPtr));
				}
				else
				{
					lowLevel = new SimpleType(RemapTypeName(type));
				}
				return;
			}

			if (cleanType.Kind == TypeKind.Pointer) {
				var ptrType = cleanType as PointerType;
				var underlying = GetPointersUnderlyingType(ptrType);

				CXXRecordDecl decl;
				if (underlying != null && ScanBaseTypes.nameToDecl.TryGetValue(underlying.Decl.QualifiedName, out decl)) {
					if (decl.IsDerivedFrom(ScanBaseTypes.UrhoObjectType)) {
						lowLevel = new SimpleType(nameof(IntPtr));
						var remapped = RemapTypeName(decl.Name);
						if (remapped != decl.Name)
							highLevel = csParser.ParseTypeReference(NamespaceRegistry.RemapTypeToNamespace (remapped));
						else
							highLevel = underlying.Bind();
						wrapKind = WrapKind.UrhoObject;
						return;
					}
					if (decl.IsDerivedFrom(ScanBaseTypes.UrhoRefCounted)) {
						lowLevel = new SimpleType(nameof(IntPtr));
						var remapped = RemapTypeName(decl.Name);
						if (remapped != decl.Name)
							highLevel = csParser.ParseTypeReference(NamespaceRegistry.RemapTypeToNamespace(remapped));
						else
							highLevel = underlying.Bind();
						wrapKind = WrapKind.HandleMember;
						return;
					}
					if (decl == ScanBaseTypes.EventHandlerType) {
						wrapKind = WrapKind.EventHandler;
						lowLevel = new SimpleType(nameof(IntPtr));
						highLevel = new SimpleType(nameof(IntPtr));
						return;
					}
					if (decl.Name == "ProfilerBlock") {
						lowLevel = new SimpleType("ProfilerBlock");
						highLevel = new SimpleType("ProfilerBlock");

					}
					if (decl.Name == "Deserializer") {
						lowLevel = new SimpleType(nameof(IntPtr));
						highLevel = new SimpleType("IDeserializer");
						wrapKind = WrapKind.HandleMember;
						return;
					}
					if (decl.Name == "Serializer") {
						lowLevel = new SimpleType(nameof(IntPtr));
						highLevel = new SimpleType("ISerializer");
						wrapKind = WrapKind.HandleMember;
						return;
					}
				}
			}
			lowLevel = cleanType.Bind();
			highLevel = cleanType.Bind();
		}

		//
		// Remaps member names that might clash with other definitions
		// (for example with comment methods in System.Object, for consistencty, or
		// because they clash with the Getter/Setter folding)
		//
		public string RemapMemberName(string type, string name)
		{
			switch (type) {
			case "Node":
				switch (name) {
				case "Scale":
					return "ScaleNode";
				case "Scale2D":
					return "ScaleNode2D";
				default:
					break;
				}
				break;
			case "Engine":
				switch (name) {
				case "Update":
					return "UpdateFrame";
				}
				break;
			default:
				if (name == "GetType")
					return "UrhoGetType";
				if (name == "GetBaseType")
					return "UrhoGetBaseType";
				if (name == "ToString")
					return "ToDebugString";
				break;
			}

			return name.RemapAcronyms();
		}

		public string RemapTypeName(string type)
		{
			switch (type) {
			case "Object": return "UrhoObject";
			case "String": return "UrhoString";
			case "Console": return "UrhoConsole";
			default:
				return type.RemapAcronyms();
			}
		}

		public string RemapVariableName(string name)
		{
			switch (name)
			{
				case "far": return "farValue";
				case "near": return "nearValue";
				default:
					return name;
			}
		}

		static readonly Dictionary<string, string[]> OglSpecificMethodsMap = new Dictionary<string, string[]> {
			{ "ConstantBuffer",		new[] { "OnDeviceReset" } },
			{ "Graphics",			new[] { "CleanupRenderSurface","CleanupShaderPrograms","GetAnisotropySupport","GetDepthTexture","GetForceGL2","GetGL3Support","GetGL3Support","GetOrCreateConstantBuffer","GetShaderProgram","MarkFBODirty","MarkFBODirty","Release","Restore","SetForceGL2","SetTextureForUpdate","SetUBO","SetVBO" } },
			{ "IndexBuffer",		new[] { "OnDeviceReset" } },
			{ "RenderSurface",		new[] { "OnDeviceLost" } },
			{ "ShaderProgram",		new[] { "GetUsedVertexAttributes", "ClearGlobalParameterSource","ClearGlobalParameterSource","ClearParameterSource","ClearParameterSources","ClearParameterSources","GetLinkerOutput","GetParameter","GetPixelShader","GetVertexShader","HasParameter","HasTextureUnit","Link","NeedParameterUpdate","OnDeviceLost","Release" } },
			{ "ShaderVariation",	new[] { "OnDeviceLost" } },
			{ "Texture",			new[] { "GetDataType","GetDataType","GetExternalFormat","GetExternalFormat","GetTarget" } },
			{ "Texture2D",			new[] { "OnDeviceLost","OnDeviceReset" } },
			{ "Texture3D",			new[] { "OnDeviceLost","OnDeviceReset" } },
			{ "TextureCube",		new[] { "OnDeviceLost","OnDeviceReset" } },
			{ "VertexBuffer",		new[] { "OnDeviceReset" } },
		};

		static readonly Dictionary<string, string[]> DxSpecificMethodsMap = new Dictionary<string, string[]> {
			{ "Texture",     new[] { "GetSRVFormat", "GetDSVFormat" } },
		};

		// Avoid generating methods that conflict in their signatures after we turn Urho::String into string
		bool SkipMethod (CXXMethodDecl decl)
		{
			//DEBUG specific method
			//if (currentType.Name == "TileMap2D" && decl.Name == "PositionToTileIndex")
			//	return false;
			//return true;

			// skip OpenGL(ES) specific API: TODO wrap with #ifdef
			if (OglSpecificMethodsMap.ContainsKey(currentType.Name))
			{
				if (OglSpecificMethodsMap[currentType.Name].Contains(decl.Name))
					return true;
			}

			// skip DirectX specific API: TODO wrap with #ifdef
			if (DxSpecificMethodsMap.ContainsKey(currentType.Name))
			{
				if (DxSpecificMethodsMap[currentType.Name].Contains(decl.Name))
					return true;
			}

			switch (currentType.Name) {
			case "Graphics":
				if (decl.Name == "GetShader")
					return decl.Parameters.Skip (1).First ().QualType.ToString () == "const char *";
				if (decl.Name == "SetShaderParameter") //strange method. it has overloads for all basic types and an overload with "Variant"... (it shouldn't have Variant or should have ONLY Variant)
					return decl.Parameters.Any(p => p.QualType.ToString().Contains("Variant"));
				break;
			case "DebugHud":
				if (decl.Name == "SetAppStats") //it has overloads with String and Variant (that also can handle String)
					return decl.Parameters.Any (p => p.QualType.ToString ().Contains ("const class Urho3D::Variant &"));
				break;
			case "Node":
				if (decl.Name == "GetChild")
					return decl.Parameters.First ().QualType.ToString () == "const char *";
				break;
			case "Image":
				if (decl.Name == "SavePNG")
					return decl.Parameters.FirstOrDefault()?.QualType.ToString() == "int *";
				break;
			case "Shader":
				if (decl.Name == "GetVariation")
					return decl.Parameters.Skip (1).First ().QualType.ToString () == "const char *";
				break;
			case "Scene":
				// The following look like internal methods that should not really be surfaced
				// to the user.   If we ever find that we have to surface, then we should rename them
				// in the other method, as they will conflict with the events.
				//
				// These names are bad choices, because they are called internally when something
				// has been done, and they complete the process.   For example "NodeRemoved" should
				// really be "RemoveNode", and "NodeAdded" should really be "AddNode", but that has
				// a different method and implementation on the Scene class (that is, there is
				// already a AddNode method, which is a high-level method)
				switch (decl.Name) {
				case "NodeAdded":
				case "NodeRemoved":
				case "ComponentAdded":
				case "ComponentRemoved":
					return true;
				}
				break;
			case "Application":
				switch (decl.Name) {
				case "Application":
					return decl.Parameters.First ().QualType.ToString ().Contains ("Urho3D::Context");
				case "Setup":
				case "Start":
				case "Stop":
					return true;
				}
				break;
			case "Skeleton":
				switch (decl.Name) {
				case "GetBone":
					
					if (decl.Parameters.First ().QualType.ToString ().Contains ("String &"))
						return true;
					return false;

				}
				
				break;
			}

			switch (decl.Name) {
				case "OnDragMove":
				case "OnDragEnd":
				case "OnDragDropTest":
				case "OnDragDropFinish":
				case "OnDragCancel":
				case "OnDragBegin":
					return true;
			}

			return false;
		}

		// 
		// Determines if we should bind a method that the C++ API scanner found
		//
		bool MethodIsBindable (CXXMethodDecl decl, VisitKind visitKind)
		{
			// We only care about enter visits, not leave
			if (visitKind != VisitKind.Enter)
				return false;

			// Global definitions, not inside a class, skip
			if (currentType == null) 
				return false;

			// Do not bother with constructors in abstract classes
			var isConstructor = decl is CXXConstructorDecl;
			if (isConstructor && decl.Parent.IsAbstract)
				return false;

			// Do not wrap constructors
			if (decl is CXXDestructorDecl)
				return false;

			// Do not wrap deprecated  __declspec(deprecated) [URHO3D_DEPRECATED]
			if (decl.HasAttr<DeprecatedAttr>())
				return false;

			// Not supported in C#
			if (decl.IsCopyAssignmentOperator || decl.IsMoveAssignmentOperator)
				return false;

			// TODO: temporary, do not handle opreators
			if (!isConstructor && decl.Name.StartsWith ("operator", StringComparison.Ordinal))
				return false;

			// Sanity check
			if (RemapTypeName (decl.Parent.Name) != currentType.Name) {
				//Console.WriteLine("For some reason we go t amethod that does not belong here {0}.{1} on {2}", decl.Parent.Name, decl.Name, currentType.Name);
				return false;
			}

			// We only bind the public API
			if (decl.Access != AccessSpecifier.Public)
				return false;

			// Skip blacklisted methods
			if (SkipMethod (decl))
				return false;

			// Temporary: while we add support for other things, just to debug things
			// remove types we do not support
			int variantArgumentsCount = 0;
			foreach (var p in decl.Parameters)
			{
				bool isVariantArgument = IsVariantType(p.QualType);
				if (isVariantArgument)
					variantArgumentsCount++;

				if (IsUnsupportedType(p.QualType, returnType: false) && !isVariantArgument)
				{
					Console.WriteLine($"Bailing out on {p.QualType} from {decl.QualifiedName}");
					return false;
				}
			}

			if (variantArgumentsCount > 1)
				return false; //it won't be easy to handle if it has more than one Variant argument

			if (IsUnsupportedType(decl.ReturnQualType, returnType: true)) {//variant return type is not support yet
				Console.WriteLine($"RETURN Bailing out on {decl.ReturnQualType} from {decl.QualifiedName}");
				return false;
			}
			return true;
		}

		public AttributeSection CreateDllImportAttribute()
		{
			var dllImport = new Attribute { Type = new SimpleType("DllImport") };
			dllImport.Arguments.Add(csParser.ParseExpression("Consts.NativeImport"));
			dllImport.Arguments.Add(new AssignmentExpression(
				new IdentifierExpression("CallingConvention"), 
					csParser.ParseExpression("CallingConvention.Cdecl")));
			return new AttributeSection(dllImport);
		}

		public override void VisitCXXMethodDecl(CXXMethodDecl decl, VisitKind visitKind)
		{
			if (!MethodIsBindable (decl, visitKind))
				return;

			var cmethodBuilder = new StringBuilder();

			AstType pinvokeReturn, methodReturn;
			WrapKind returnIsWrapped;
			ICSharpCode.NRefactory.CSharp.ParameterModifier pinvokeMod, methodMod;

			LookupMarshalTypes(decl.ReturnQualType, out pinvokeReturn, out pinvokeMod, out methodReturn, out methodMod, out returnIsWrapped, isReturn: true);
			var methodReturn2 = methodReturn.Clone();

			var propertyInfo = ScanBaseTypes.GetPropertyInfo(decl);
			if (propertyInfo != null) {
				propertyInfo.HostType = currentType;
				if (decl.Name.StartsWith("Get") || decl.Name.StartsWith("Is"))
					propertyInfo.MethodReturn = methodReturn.Clone();
			}

			var methodName = decl.Name;
			if (currentTypeNames.Contains(methodName))
				methodName += (uniqueMethodName++).ToString();
			currentTypeNames.Add(methodName);

			//
			// PInvoke declaration + C counterpart declaration
			//
			string pinvoke_name = currentType.Name + "_" + methodName;
			var isConstructor = decl is CXXConstructorDecl;

			if (isConstructor) {
				pinvokeReturn = new SimpleType (nameof(IntPtr));

				// Do not bind a default constructor for Skeleton
				if (currentType.Name == "Skeleton")
					return;
			}

			var pinvoke = new MethodDeclaration
			{
				Name = pinvoke_name,
				ReturnType = pinvokeReturn,
				Modifiers = Modifiers.Extern | Modifiers.Static | Modifiers.Internal
			};
			if (!decl.IsStatic && !isConstructor)
				pinvoke.Parameters.Add(new ParameterDeclaration(new SimpleType(nameof(IntPtr)), "handle"));

			pinvoke.Attributes.Add(CreateDllImportAttribute());

			// The C counterpart
			var cinvoke = new StringBuilder();
			string marshalReturn = "{0}";
			string creturnType = CleanTypeCplusplus(decl.ReturnQualType);
			bool creturnIsVariant = creturnType == "const class Urho3D::Variant &";

			switch (creturnType) {
			case "bool":
				creturnType = "int";
				break;
			case "Urho3D::StringHash":
				creturnType = "int";
				marshalReturn = "({0}).Value ()";
				break;
			case "Urho3D::Polyhedron":
			case "Urho3D::Frustum":
			case "Urho3D::XMLElement":
				marshalReturn = "new " + creturnType + " ({0})";
				creturnType = creturnType + " *";
				break;
			case "Urho3D::String":
			case "const Urho3D::String &":
			case "const class Urho3D::String &":
				creturnType = "const char *";
				marshalReturn = "stringdup(({0}).CString ())";
				break;
			case "const struct Urho3D::RenderPathCommand &":
				creturnType = "Urho3D::RenderPathCommand";
				break;
			case "const struct Urho3D::TileMapInfo2D &":
				creturnType = "Urho3D::TileMapInfo2D";
				break;
			case "const struct Urho3D::CrowdObstacleAvoidanceParams &":
				creturnType = "Urho3D::CrowdObstacleAvoidanceParams";
				break;
			case "const class Urho3D::Vector3 &":
			case "const class Urho3D::Matrix4 &":
			case "const class Urho3D::Matrix3x4 &":
			case "const class Urho3D::Vector2 &":
			case "const class Urho3D::Vector4 &":
			case "const class Urho3D::IntRect &":
			case "const class Urho3D::IntVector2 &":
			case "const class Urho3D::Quaternion &":
			case "const class Urho3D::Plane &":
			case "const class Urho3D::BoundingBox &": 
			case "const class Urho3D::Color &":
				
			case "Urho3D::Vector3":
			case "Urho3D::Matrix4":
			case "Urho3D::Matrix3x4":
			case "Urho3D::Vector2":
			case "Urho3D::Vector4":
			case "Urho3D::IntVector2":
			case "Urho3D::IntRect":
			case "Urho3D::Quaternion":
			case "Urho3D::Plane":
			case "Urho3D::BoundingBox":
			case "Urho3D::Color":
				var nsIndex = creturnType.IndexOf ("Urho3D::") + "Urho3D".Length;
				creturnType = "Interop" + creturnType.Remove (0, nsIndex).Trim ('&', ' ') + " ";
				marshalReturn = "*((" + creturnType + " *) &({0}))";
				break;
			}

			if (creturnType.StartsWith("SharedPtr<"))
			{
				creturnType = creturnType.ExtractGenericParameter().DropClassOrStructPrefix() + " *";
				marshalReturn =
					"auto copy = {0};\n" +
					"\tauto plain = copy.Get();\n" +
					"\tcopy.Detach();\n" +
					"\tdelete copy;\n" +
					"\treturn plain;";
			}

			const string methodNameSuffix = "%MethodSuffix%";
			const string variantConverterMask = "%VariantConvertor%";

			if (isConstructor)
				cmethodBuilder.Append($"DllExport void *\n{pinvoke_name}{methodNameSuffix} (");
			else
				cmethodBuilder.Append($"DllExport {creturnType}\n{pinvoke_name}{methodNameSuffix} (");

			if (decl.IsStatic) {
				cinvoke.Append($"{decl.Parent.Name}::{decl.Name} (");

			} else if (isConstructor) {
				cinvoke.Append($"new {decl.Name}(");
			}

			else {
				cmethodBuilder.Append($"Urho3D::{decl.Parent.Name} *_target");
				if (decl.Parameters.Any())
					cmethodBuilder.Append(", ");
				cinvoke.Append($"_target->{decl.Name} (");
			}

			//
			// Method declaration
			//
			MethodDeclaration method = null;
			ConstructorDeclaration constructor = null;

			var remapedName = RemapMemberName(decl.Parent.Name, decl.Name);
			InvocationExpression validateInvocation;
			if (decl.IsStatic || currentType.ClassType == ClassType.Struct || isConstructor)
				validateInvocation = new InvocationExpression(new MemberReferenceExpression(new IdentifierExpression("Runtime"), "Validate"), csParser.ParseExpression($"typeof({currentType.Name})"));
			else if ((currentType.BaseTypes.Any() || currentType.Name == "UrhoObject") && currentType.Name != "RefCounted")
				validateInvocation = new InvocationExpression(new MemberReferenceExpression(new IdentifierExpression("Runtime"), "ValidateRefCounted"), new ThisReferenceExpression());
			else
				validateInvocation = new InvocationExpression(new MemberReferenceExpression(new IdentifierExpression("Runtime"), "ValidateObject"), new ThisReferenceExpression());

			// some cases which should not be validated:
			if (remapedName == "Context" || remapedName == "Run" || remapedName == "GetContext" || currentType.Name == "RefCounted")
				validateInvocation = null;


			if (isConstructor) {
				constructor = new ConstructorDeclaration
				{
					Name = remapedName,

					Modifiers = (decl.IsStatic ? Modifiers.Static : 0) |
						(propertyInfo != null ? Modifiers.Private : Modifiers.Public)  |
						(decl.Name == "ToString" ? Modifiers.Override : 0)
				};
				constructor.Attributes.Add(CreatePreserveAttribute());
				constructor.Body = new BlockStatement();
				if (validateInvocation != null)
					constructor.Body.Add(validateInvocation);
			} else {
				method = new MethodDeclaration
				{
					Name = remapedName,
					ReturnType = methodReturn,
					Modifiers = (decl.IsStatic ? Modifiers.Static : 0) |
						(GetMethodModifier(propertyInfo, currentType.Name, remapedName))
				};
				method.Body = new BlockStatement();
				if (validateInvocation != null)
					method.Body.Add(validateInvocation);
			}

			// 
			// Marshal from C# to C and the C support to call into C++
			//
			var invoke = new InvocationExpression(new IdentifierExpression(pinvoke_name));
			if (!decl.IsStatic && !isConstructor)
				invoke.Arguments.Add(new IdentifierExpression("handle"));
			bool first = true;
			int anonymousParameterNameCount = 1;
			int currentParamCount = -1;
			foreach (var param in decl.Parameters) {
				currentParamCount++;
				AstType pinvokeParameter, parameter;
				WrapKind wrapKind;

				if (!first) {
					cinvoke.Append(", ");
					cmethodBuilder.Append(", ");
				} else
					first = false;

				LookupMarshalTypes(param.QualType, out pinvokeParameter, out pinvokeMod, out parameter, out methodMod, out wrapKind);

				string paramName = param.Name;
				if (string.IsNullOrEmpty(paramName))
					paramName = "param" + (anonymousParameterNameCount++);

				paramName = RemapVariableName(paramName);

				Expression parameterReference = new IdentifierExpression (paramName);
				switch (currentType.Name) {
				case "Input":
					switch (decl.Name) {
					case "GetMouseButtonDown":
					case "GetMouseButtonPress":
						parameter = new SimpleType ("MouseButton");
						parameterReference = new CastExpression (new PrimitiveType ("int"), parameterReference);
						break;
					case "GetKeyPress":
					case "GetKeyDown":
					case "GetScancodeFromKey":
					case "GetKeyName":
						if (currentParamCount == 0 && paramName == "key") {
							parameter = new SimpleType ("Key");
							parameterReference = new CastExpression (new PrimitiveType ("int"), parameterReference);
						}
						break;
					}
					break;
				case "VertexBuffer":
					switch (decl.Name) {
					case "SetSize":
						if (currentParamCount == 1 && paramName == "elementMask") {
							parameter = new SimpleType ("ElementMask");
							parameterReference = new CastExpression (new PrimitiveType ("uint"), parameterReference);
						}
						break;
					case "GetVertexSize":
						if (currentParamCount == 0 && paramName == "elementMask") {
							parameter = new SimpleType ("ElementMask");
							parameterReference = new CastExpression (new PrimitiveType ("uint"), parameterReference);
						}
						break;
					case "GetElementOffset":
						if (currentParamCount == 0 && paramName == "elementMask") {
							parameter = new SimpleType ("ElementMask");
							parameterReference = new CastExpression (new PrimitiveType ("uint"), parameterReference);
						}
						break;
					}
					break;
				case "Log":
					switch (decl.Name) {
					case "Write":
						if (currentParamCount == 0 && paramName == "level") {
							parameter = new SimpleType ("LogLevel");
							parameterReference = new CastExpression (new PrimitiveType ("int"), parameterReference);
						}
						break;
					}
					break;
				}

				var parameterDeclaration = new ParameterDeclaration(parameter, paramName, methodMod);
				parameterDeclaration.DefaultExpression = OptionalParametersParser.Parse(param, csParser);

				if (constructor == null)
					method.Parameters.Add(parameterDeclaration);
				else
					constructor.Parameters.Add(parameterDeclaration);

				pinvoke.Parameters.Add(new ParameterDeclaration(pinvokeParameter, paramName, pinvokeMod));
				switch (wrapKind) {
				case WrapKind.None:
					invoke.Arguments.Add(parameterReference);
					break;
				case WrapKind.SimpleObject:
				case WrapKind.HandleMember:
				case WrapKind.UrhoObject:
					var cond = new ConditionalExpression (new BinaryOperatorExpression (
							new CastExpression (new PrimitiveType ("object"), parameterReference), BinaryOperatorType.Equality, 
							new PrimitiveExpression (null)), csParser.ParseExpression ("IntPtr.Zero"), 
						                                  csParser.ParseExpression (StringUtil.SafeParamName(paramName) + ".Handle"));
					invoke.Arguments.Add (cond);
					break;
				case WrapKind.EventHandler:
					invoke.Arguments.Add(parameterReference);
					break;
				case WrapKind.StringHash:
					invoke.Arguments.Add (csParser.ParseExpression (StringUtil.SafeParamName(paramName) + ".Code"));
					break;
				case WrapKind.RefBlittable:
					invoke.Arguments.Add (new DirectionExpression (FieldDirection.Ref, parameterReference));
					break;
				case WrapKind.VectorSharedPtr:
					throw new NotImplementedException ("Vector marshaling not supported for parameters yet");
				}

				var ctype = CleanTypeCplusplus (param.QualType);
				string paramInvoke = paramName;
				switch (ctype) {
				case "Urho3D::Image &":
					ctype = "Image *";
					paramInvoke = $"*{paramInvoke}";
					break;
				case "Urho3D::IntVector2":
					ctype = "const class Urho3D::IntVector2 &";
					break;
				case "Urho3D::Deserializer &":
				case "Urho3D::Serializer &":
					ctype = "Urho3D::DeSerializer *";
					paramInvoke = $"*{paramInvoke}";
					break;
				case "const class Urho3D::String &":
					ctype = "const char *";
					paramInvoke = $"Urho3D::String({paramInvoke})";
					break;
				case "Urho3D::StringHash":
					ctype = "int";
					paramInvoke = $"Urho3D::StringHash({paramInvoke})";
					break;
				case "const class Urho3D::Variant &":
					paramInvoke = $"{variantConverterMask}({paramInvoke})";
					break;
				}

				cmethodBuilder.Append($"{ctype} {paramName}");
				cinvoke.Append($"{paramInvoke}");
			}
			cinvoke.Append(")");
			cmethodBuilder.Append(")\n{\n\t");

			// if the type has a ctor accepting Context - add a parameterless one that will use "this(Application.CurrentContext)"
			if (isConstructor &&
				decl.Parameters.Count() == 1 &&
				decl.Parameters.ElementAt(0).QualType.ToString() == "class Urho3D::Context *") {
				var ctor = new ConstructorDeclaration {
						Modifiers = Modifiers.Public,
						Body = new BlockStatement(),
						Initializer = new ConstructorInitializer { ConstructorInitializerType = ConstructorInitializerType.This }
					};
				ctor.Attributes.Add(CreatePreserveAttribute());
				ctor.Initializer.Arguments.Add(csParser.ParseExpression("Application.CurrentContext"));
				currentType.Members.Add(ctor);
			}


			if (method != null && methodReturn is Sharpie.Bind.Types.VoidType) {
				method.Body.Add(invoke);
				//	pn ($"fprintf (stderr,\"DEBUG {creturnType} {pinvoke_name} (...)\\n\");");
				cmethodBuilder.AppendLine($"{cinvoke.ToString()};");
			} else {
				ReturnStatement ret = null;
				Expression returnExpression;


				if (!isConstructor)
					ret = new ReturnStatement();

				switch (returnIsWrapped) {
				case WrapKind.SimpleObject:
					returnExpression = new ObjectCreateExpression(new SimpleType(((SimpleType)methodReturn2).Identifier), invoke);
					break;
				case WrapKind.HandleMember:
					returnExpression = new InvocationExpression (new MemberReferenceExpression (new IdentifierExpression ("Runtime"), "LookupRefCounted", methodReturn2), invoke);
					break;
				case WrapKind.UrhoObject:
					returnExpression = new InvocationExpression (new MemberReferenceExpression (new IdentifierExpression ("Runtime"), "LookupObject", methodReturn2), invoke);
					break;
				case WrapKind.EventHandler:
					returnExpression = invoke;
					break;
				case WrapKind.StringHash:
					returnExpression = new ObjectCreateExpression (new SimpleType ("StringHash"), invoke);
					break;
				case WrapKind.MarshalPtrToString:
					returnExpression = new InvocationExpression(new MemberReferenceExpression(new IdentifierExpression("Marshal"), "PtrToStringAnsi"), invoke);
					break;
				case WrapKind.MarshalPtrToStruct:
					returnExpression = new InvocationExpression(new MemberReferenceExpression(new IdentifierExpression("Marshal"), "PtrToStructure"), invoke, new TypeOfExpression(methodReturn2));
					returnExpression = new CastExpression(methodReturn2.Clone(), returnExpression);
					break;
				case WrapKind.VectorSharedPtr:
					var cacheName = "_" + method.Name + "_cache";
					var f = new FieldDeclaration () {
						ReturnType = method.ReturnType.Clone (),
						Modifiers = Modifiers.Private | (method.Modifiers & Modifiers.Static)
					};
					f.Variables.Add (new VariableInitializer (cacheName, null));
					currentType.Members.Add (f);
					
					var sharedPtrType = (methodReturn as SimpleType).TypeArguments.First ().Clone ();
					//TODO: check if UrhoObject
					var create = (sharedPtrType.ToString() == "AnimationState") ? "CreateVectorSharedPtrRefcountedProxy" : "CreateVectorSharedPtrProxy";

					returnExpression = new ConditionalExpression (
						new BinaryOperatorExpression (new IdentifierExpression (cacheName), BinaryOperatorType.InEquality, new PrimitiveExpression (null)),
						new IdentifierExpression (cacheName),
						new AssignmentExpression (
							new IdentifierExpression (cacheName), 
							new InvocationExpression (
								new MemberReferenceExpression (
									new IdentifierExpression ("Runtime"), create, sharedPtrType),
								invoke)));
						
						
					break;
				default:
					returnExpression = invoke;
					break;
				}
				if (ret != null) {
					ret.Expression = returnExpression;
					method.Body.Add(ret);
				} else {
					if (currentType.ClassType == ClassType.Class){
						//usually, the Context is the first object user creates so let's add additional check if engine is inited
						if (currentType.Name == "Context") {
							constructor.Body.Add (new InvocationExpression (new IdentifierExpression ("CheckEngine"), null));
						}
						bool hasBaseTypes = currentType.BaseTypes.Count != 0;
						if (hasBaseTypes) {
							constructor.Initializer = new ConstructorInitializer {
								ConstructorInitializerType = ConstructorInitializerType.Base,
							};
							constructor.Initializer.Arguments.Add(csParser.ParseExpression("UrhoObjectFlag.Empty"));
						}
						var ctorAssign = new AssignmentExpression(new IdentifierExpression("handle"), returnExpression);
						constructor.Body.Add(new ExpressionStatement(ctorAssign));
						if (hasBaseTypes) { 
							constructor.Body.Add (new InvocationExpression (new MemberReferenceExpression (new IdentifierExpression ("Runtime"), "RegisterObject"), new ThisReferenceExpression ()));
						}
						constructor.Body.Add(new InvocationExpression(new IdentifierExpression($"On{currentType.Name}Created"), null));
					}
				}
				var rstr = String.Format(marshalReturn, cinvoke.ToString());
				CXXRecordDecl returnType;
				//Wrap with WeakPtr all RefCounted subclasses constructors
				if (isConstructor) {
					if (ScanBaseTypes.nameToDecl.TryGetValue(decl.Parent.QualifiedName, out returnType) && returnType.IsDerivedFrom(ScanBaseTypes.UrhoRefCounted))
						rstr = $"WeakPtr<{decl.Name}>({rstr})";
				}

				if (!rstr.Contains("\treturn "))
				{
					if (creturnIsVariant)
						cmethodBuilder.AppendLine($"return %ConvertReturn%({rstr}.%VariantToTypeMethod%);");
					else
						cmethodBuilder.AppendLine($"return {rstr};");
				}
				else
					cmethodBuilder.AppendLine(rstr);
			}
			cmethodBuilder.AppendLine("}\n");

			var code = cmethodBuilder.ToString();

			const string variantArgDef = "const class Urho3D::Variant &";

			//if methods contains Variant argument -- replace it with overloads
			if (code.Contains(variantArgDef))
			{
				var variantSupportedTypes = new Dictionary<string, string>
					{
						//C++ - C# types map
						{"const class Urho3D::Vector3 &", "Vector3"},
						{"const class Urho3D::IntRect &", "IntRect"},
						{"const class Urho3D::Color &", "Color"},
						{"const class Urho3D::Vector2 &", "Vector2"},
						{"const class Urho3D::Vector4 &", "Vector4"},
						{"const class Urho3D::IntVector2 &", "IntVector2"},
						{"const class Urho3D::Quaternion &", "Quaternion"},
						{"const class Urho3D::Matrix4 &", "Matrix4"},
						{"const class Urho3D::Matrix3x4 &", "Matrix3x4"},
						{"int", "int"},
						{"float", "float"},
						{"const char *", "string"},
						{"bool", "bool"},
					};

				pn("// Urho3D::Variant overloads begin:");
				int index = -1;
				foreach (var item in variantSupportedTypes)
				{
					index++;
					string cVarReplacedType = item.Key;
					if (cVarReplacedType.Contains("const class") && creturnIsVariant)
						cVarReplacedType = "Interop::" + item.Key.DropConstAndReference().DropClassOrStructPrefix().DropUrhoNamespace();

					bool isString = item.Key == "const char *";
					bool isPrimitive = !item.Key.Contains("class");
					    
					//C:
					p(code
					  .Replace(variantArgDef, cVarReplacedType)
						.Replace(methodNameSuffix, "_" + index.ToString())
					    .Replace("%ConvertReturn%", !isPrimitive ? $"*(({cVarReplacedType} *) &" : (isString ? "stringdup" : ""))
					  	.Replace("%VariantToTypeMethod%", "Get" + item.Value.Capitalize(false) + "()" + (isString ? ".CString()" : "") + (isPrimitive ? "" : ")"))
						.Replace(variantConverterMask, isString ? "Urho3D::String" : string.Empty));
					//methodNameSuffix to avoid error:
					//error C2733: second C linkage of overloaded function 'function name' not allowed.

					if (creturnIsVariant)
						continue;

					//C#:

					AstType argumentType;
					var argumentModifier = ICSharpCode.NRefactory.CSharp.ParameterModifier.None;
					if (!isPrimitive)
					{
						argumentType = new SimpleType(item.Value);
						argumentModifier = ICSharpCode.NRefactory.CSharp.ParameterModifier.Ref;
					}
					else
					{
						argumentType = new PrimitiveType(item.Value);
					}

					var dllImportItem = (MethodDeclaration)pinvoke.Clone();
					var originalEntryPointName = dllImportItem.Name;
					dllImportItem.Name += "_" + index;
					var variantParam = dllImportItem.Parameters.First(p => p.ToString().Contains(variantArgDef));
					variantParam.Type = argumentType.Clone();
					variantParam.ParameterModifier = argumentModifier;
					currentType.Members.Add(dllImportItem);

					var clonedMethod = (MethodDeclaration)method.Clone();
					variantParam = clonedMethod.Parameters.First(p => p.ToString().Contains(variantArgDef));
					variantParam.Type = argumentType.Clone();

					//add 'index' to all EntryPoint invocations inside the method (no mater how complex method body is):
					//and 'ref' keyword for the argument
					clonedMethod.Body.Descendants
						.OfType<InvocationExpression>()
						.Where(ie => ie.Target is IdentifierExpression && ((IdentifierExpression)ie.Target).Identifier == originalEntryPointName)
						.ToList()
						.ForEach(ie =>
							{
								if (!isPrimitive)
								{
									//for multiple argument we should keep the ordering that why we need to copy all arguments once then add them one by one
									//we don't have Insert method in ie.Arguments because it's ICollection 
									//ex: Spline.cs , Spline_SetKnot_0 (handle, ref knot, index);
									var arguments = ie.Arguments.ToList();
									ie.Arguments.Clear();
                            
									foreach (var argument in arguments) {
										if (argument is IdentifierExpression idnArgument && idnArgument.Identifier == variantParam.Name)
										{
											//non-primitive types should be marked with 'ref' keyword
											ie.Arguments.Add(new DirectionExpression(FieldDirection.Ref, argument));
										}
										else
										{
											ie.Arguments.Add(argument);
										}
									}
								}

								var exp = (IdentifierExpression)ie.Target;
								exp.Identifier += "_" + index;
							});

					currentType.Members.Add(clonedMethod);
					Commenter.InsertSummary(clonedMethod, StringUtil.GetMethodComments(decl));
				}
				pn("// Urho3D::Variant overloads end.");
			}
			//method does not have "Variant" arguments
			else
			{
				var unwrapTypes = new List<UnwrapTypeInfo>
				{
					new UnwrapTypeInfo("Urho3D::DeSerializer", "DeSerializer", new string[] { "File", "MemoryBuffer", /*VectorBuffer, NamedPipe, HttpRequest*/ }),
				};
				bool methodHandled = false;
				foreach (var item in unwrapTypes)
				{
					if (code.Contains(item.Item1))
					{
						methodHandled = true;
						for (int i = 0; i < item.Item3.Length; i++)
						{
							var unwrapType = item.Item3[i];
							var postfix = "_" + unwrapType;
							//C:
							pn(code
								.Replace(item.Item1, unwrapType)
								.Replace(methodNameSuffix, postfix)
								.Replace(variantConverterMask, string.Empty));

							var pinvokeClone = pinvoke.Clone() as MethodDeclaration;
							pinvokeClone.Name += postfix;
							currentType.Members.Add(pinvokeClone);

							var clonedMethod = method.Clone() as MethodDeclaration;
							var paramToReplace = clonedMethod.Parameters.First(p => p.Type.ToString() == item.Item2);
							paramToReplace.Type = new SimpleType(unwrapType);

							var exp = clonedMethod.Body.Last();
							var fixedStatements = csParser.ParseStatements(exp.ToString().Replace(pinvoke_name, pinvoke_name + postfix));
							clonedMethod.Body.Last().Remove();
							fixedStatements.ToList().ForEach(s => clonedMethod.Body.Add(s));
							currentType.Members.Add(clonedMethod);
							Commenter.InsertSummary(clonedMethod, StringUtil.GetMethodComments(decl));
						}
					}
				}

				if (methodHandled)
					return;

				//C:
				pn(code
					.Replace(methodNameSuffix, string.Empty)
					.Replace(variantConverterMask, string.Empty));

				//C#:
				currentType.Members.Add(pinvoke);

				if (method == null)
					currentType.Members.Add(constructor);
				else
				{
					currentType.Members.Add(method);
					Commenter.InsertSummary(method, StringUtil.GetMethodComments(decl));
				}
			}

		}

		Modifiers GetMethodModifier(ScanBaseTypes.GetterSetter propertyInfo, string type, string method)
		{
			if (propertyInfo != null && (!propertyInfo.SetMethodPublic || method == propertyInfo.Getter.Name))
				return Modifiers.Private;

			if (type == "Engine" && method == "Exit") return Modifiers.Internal;
			return Modifiers.Public;
		}


		void ScanBases(TypeDeclaration td, Func<TypeDeclaration, bool> cback)
		{
			if (td.BaseTypes.Count() == 0)
				return;
			var j = td.BaseTypes.First();
			var btype = allTypes[RemapTypeName ((j as SimpleType).Identifier)];
			if (cback(btype))
				return;
			ScanBases(btype, cback);
		}

		public void ForAllMembers(Action<TypeDeclaration, EntityDeclaration> handler)
		{
			foreach (var typeDeclaration in allTypes.Values) {
				foreach (var member in typeDeclaration.Members)
					handler(typeDeclaration, member);
			}
		}

		void UpdateMembers(EntityDeclaration baseDeclaration, EntityDeclaration declaration)
		{
			if (declaration.Modifiers.HasFlag(Modifiers.Static)) {
				declaration.Modifiers |= Modifiers.New;
			} else {
				declaration.Modifiers |= Modifiers.Override;
				baseDeclaration.Modifiers |= Modifiers.Virtual;
			}
		}

		public void FixupOverrides()
		{
			ForAllMembers((typeDeclaration, member) =>
			{
				if (member is PropertyDeclaration) {
					var property = member as PropertyDeclaration;
					ScanBases(typeDeclaration, baseType =>
					{
						foreach (var baseProperty in baseType.Members.OfType<PropertyDeclaration>()) {
							if (baseProperty.Name == property.Name && 
							    !(property.Name == "BoundingBox" && ((TypeDeclaration)property.Parent).Name == "Drawable")) {
								UpdateMembers(baseProperty, property);
								return true;
							}
						}
						return false;
					});
				}
				if (member is MethodDeclaration) {
					var method = member as MethodDeclaration;
					if (method.Modifiers.HasFlag(Modifiers.Private))
						return;
					ScanBases(typeDeclaration, baseType =>
					{
						foreach (var baseMethod in baseType.Members.OfType<MethodDeclaration>()) {
							if (baseMethod.Name != method.Name)
								continue;

							if (baseMethod.Parameters.Count() != method.Parameters.Count())
								continue;

							var bpars = baseMethod.Parameters.ToArray();
							var pars = method.Parameters.ToArray();
							bool fail = false;
							for (int i = 0; i < pars.Length; i++) {
								//Console.WriteLine("{0} {1} {2}", bpars[i].Type, pars[i].Type, pars[i].Type);
								if (bpars[i].Type.ToString() != pars[i].Type.ToString()) {
									fail = true;
									break;
								}
							}
							if (!fail) {
								UpdateMembers(baseMethod, method);
								return true;
							}

						}
						return false;
					});
				}
			});

			ForAllMembers((typeDeclaration, member) =>
			{
				if (member.Modifiers.HasFlag(Modifiers.Virtual | Modifiers.Override))
					member.Modifiers = member.Modifiers & ~Modifiers.Virtual;
			});
		}

		public void GenerateProperties()
		{
			foreach (var typeKV in ScanBaseTypes.allProperties) {
				foreach (var propNameKV in typeKV.Value) {
					foreach (var gs in propNameKV.Value.Values) {
						Expression valueReference = new IdentifierExpression ("value");
						Expression invokeGetter = new InvocationExpression (new IdentifierExpression (RemapMemberName (gs.Getter.Parent.Name, gs.Getter.Name)));

						string pname = gs.Name;
						Modifiers mods = 0;
						switch (typeKV.Key) {

						case "UIElement":
							if (pname == "BringToFront")
								pname = "BringToFrontOnFocus";
							if (pname == "BringToBack")
								pname = "BringToBackOnFocus";
							if (pname == "SortChildren")
								pname = "ShouldSortChildren";
							break;
						case "Menu":
							if (pname == "ShowPopup")
								pname = "IsPopupShown";
							break;
						case "File":
							if (pname == "Handle")
								pname = "FileHandle";
							break;
						case "Text":
							if (pname == "Text")
								pname = "Value";
							break;
						case "Sprite":
							switch (pname) {
							case "Position":
								pname = "PositionFloat";
								break;
							default:
								break;
							}
							break;
						case "View":
							#if false
							// if false -> temporarily moved the apis to Application, not RefCounted, so there is currently
							// no conflict

							// View.Graphics is the Urho C++ strong type to GetSubssytem(Graphics)
							if (pname == "Graphics" || pname == "Renderer")
								mods = Modifiers.New;
							#endif
							break;

						case "Camera":
							switch (pname) {
							case "ViewOverrideFlags":
								gs.MethodReturn = new SimpleType ("ViewOverrideFlags");
								valueReference = new CastExpression (new PrimitiveType ("uint"), valueReference);
								invokeGetter = new CastExpression (new SimpleType ("ViewOverrideFlags"), invokeGetter);
								break;
							}
							break;
						case "VertexBuffer":
							switch (pname) {
							case "ElementMask":
								gs.MethodReturn = new SimpleType ("ElementMask");
								valueReference = new CastExpression (new PrimitiveType ("uint"), valueReference);
								invokeGetter = new CastExpression (new SimpleType ("ElementMask"), invokeGetter);
								break;
							}
							break;
						}

						if (gs.HostType?.Name != null && pname == gs.HostType.Name)
						{
							continue;
						}

						var p = new PropertyDeclaration()
						{
							Name = pname,
							ReturnType = gs.MethodReturn,
							Modifiers = Modifiers.Public | (gs.Getter.IsStatic ? Modifiers.Static : 0) | mods
						};

						if (pname == "TypeStatic")
							p.Attributes.Add(CreatePreserveAttribute());

						p.Getter = new Accessor()
						{
							Body = new BlockStatement() {
								new ReturnStatement (invokeGetter)
							}
						};
						if (gs.Setter != null) {
							p.Setter = new Accessor()
							{
								Body = new BlockStatement()
								{
									new InvocationExpression (new IdentifierExpression (gs.Setter.Name), valueReference)
								}
							};
						}
						// We are unable to bind
						if (gs.HostType == null)
							continue;

						gs.HostType.Members.Add(p);
						var comments = StringUtil.GetMethodComments(gs.Getter);
						if (gs.Setter != null)
						{
							var setterComments = StringUtil.GetMethodComments(gs.Setter).ToList();
							if (setterComments.Count > 0)
							{
								setterComments.Insert(0, "Or");
							}
							comments = comments.Concat(setterComments);
						}
						Commenter.InsertSummary(p, comments);
					}
				}
			}
		}

		void p(string fmt, params object[] args)
		{
			if (args.Length == 0)
				cbindingStream.Write(fmt);
			else
				cbindingStream.Write(String.Format(fmt, args));
		}

		void pn(string fmt, params object[] args)
		{
			if (args.Length == 0)
				cbindingStream.WriteLine(fmt);
			else
				cbindingStream.WriteLine(String.Format(fmt, args));
		}
	}
}
