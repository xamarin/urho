<Type Name="Input" FullName="Urho.Input">
  <TypeSignature Language="C#" Value="public class Input : Urho.UrhoObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Input extends Urho.UrhoObject" />
  <AssemblyInfo>
    <AssemblyName>Urho</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Urho.UrhoObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Input subsystem. Converts operating system window messages to input state and events.
            </summary>
    <remarks>
      <para>The Input subsystem provides keyboard, mouse, joystick and touch input both via a polled interface and events. This subsystem is also used for querying whether the application window has input focus or is minimized.</para>
      <para>The subsystem is always instantiated, even in headless mode, but is active only once the application window has been created. Once active, the subsystem takes over the operating system mouse cursor. It will be hidden by default, so the <see cref="T:Urho.Gui.UI" /> should be used to render a software cursor if necessary. For editor-like applications the operating system cursor can be made visible by calling <see cref="M:Urho.Input.SetMouseVisible" />.</para>
      <para>You can subscribe to these events by using one of the SubscribeToXxx methods in UrhoObject:</para>
      <list type="bullet">
        <item>
          <term>MouseButtonUp: a mouse button was released.</term>
        </item>
        <item>
          <term>MouseButtonDown: a mouse button was pressed.</term>
        </item>
        <item>
          <term>MouseMove: the mouse moved.</term>
        </item>
        <item>
          <term>MouseWheel: the mouse wheel moved.</term>
        </item>
        <item>
          <term>KeyUp: a key was released.</term>
        </item>
        <item>
          <term>KeyDown: a key was pressed.</term>
        </item>
        <item>
          <term>TextInput: a string of translated text input in UTF8 format. May contain a single character or several.</term>
        </item>
        <item>
          <term>JoystickConnected: a joystick was plugged in.</term>
        </item>
        <item>
          <term>JoystickDisconnected: a joystick was disconnected.</term>
        </item>
        <item>
          <term>JoystickButtonDown: a joystick button was pressed.</term>
        </item>
        <item>
          <term>JoystickButtonUp: a joystick button was released.</term>
        </item>
        <item>
          <term>JoystickAxisMove: a joystick axis was moved.</term>
        </item>
        <item>
          <term>JoystickHatMove: a joystick POV hat was moved.</term>
        </item>
        <item>
          <term>TouchBegin: a finger touched the screen.</term>
        </item>
        <item>
          <term>TouchEnd: a finger was lifted from the screen.</term>
        </item>
        <item>
          <term>TouchMove: a finger moved on the screen.</term>
        </item>
        <item>
          <term>GestureRecorded : recording a touch gesture is complete.</term>
        </item>
        <item>
          <term>GestureInput : a touch gesture was recognized.</term>
        </item>
        <item>
          <term>MultiGesture : a multi-finger pinch/rotation touch gesture is underway.</term>
        </item>
        <item>
          <term>DropFile : a file was drag-dropped on the application window.</term>
        </item>
        <item>
          <term>InputFocus : application input focus or window minimization state changed.</term>
        </item>
        <item>
          <term>MouseVisibleChanged : the visibility of the operating system mouse cursor was changed.</term>
        </item>
        <item>
          <term>ExitRequested : application exit was requested (eg. with the window close button.)</term>
        </item>
      </list>
      <para>
      </para>
      <format type="text/html">
        <h2>Keyboard and Mouse Input</h2>
      </format>
      <para>
      </para>
      <para>Key events include both the symbolic keycode ("Key") that depends on the keyboard layout, the layout- and operating system-independent SDL scancode ("Scancode"), and the true operating system-specific raw keycode ("Raw").</para>
      <para>The input polling API differentiates between the initiation of a key/mouse button press, and holding the key or button down.  <see cref="M:Urho.Input.GetKeyPress" /> and <see cref="M:Urho.Input.GetMouseButtonPress" /> return true only for one frame (the initiation) while <see cref="M:Urho.Input.GetKeyDown" /> and <see cref="M:Urho.Input.GetMouseButtonDown" /> return true as long as the key or button is held down. To check whether keys are down or pressed by scancode, use <see cref="M:Urho.Input.GetScancodeDown" /> and <see cref="M:Urho.Input.GetScancodePress" />. Functions also exist for converting keycodes to scancodes or vice versa, or getting key names. See for example <see cref="M:Urho.Input.GetKeyName" /> and <see cref="M:Urho.Input.GetKeyFromScancode" />.</para>
      <para>Mouse motion since the last frame can be accessed with <see cref="M:Urho.Input.GetMouseMove" />. The cursor position within the window can be queried with <see cref="M:Urho.Input.GetMousePosition" />.</para>
      <para>
      </para>
      <format type="text/html">
        <h2>Mouse modes</h2>
      </format>
      <para>The operating system mouse cursor can be used in four modes which can be switched with <see cref="P:Urho.Input.MouseMode" />:</para>
      <list type="bullet">
        <item>
          <term>Absolute: is the default behaviour, allowing the toggling of operating system cursor visibility and allowing the cursor to escape the window when visible. When the operating system cursor is invisible in absolute mouse mode, the mouse is confined to the window. If the operating system and UI cursors are both invisible, interaction with the user interface will be limited (for example, drag move and drag end events will not trigger).    Setting this value to Absolute will call SetMouseGrabbed(false).</term>
        </item>
      </list>
      <list type="bullet">
        <item>
          <term>Relative: sets the operating system cursor to invisible and confines the cursor to the window. The operating system cursor cannot be set to be visible in this mode via SetMouseVisible(), however changes are tracked and will be restored when another mouse mode is set. When the virtual cursor is also invisible, UI interaction will still function as normal (eg: drag events will trigger). Setting this will call SetMouseGrabbed(true).</term>
        </item>
      </list>
      <para>
      </para>
      <list type="bullet">
        <item>
          <term>Wrap: grabs the mouse from the operating system and confines the operating system cursor to the window, wrapping the cursor when it is near the edges. Setting this will call SetMouseGrabbed(true).</term>
        </item>
      </list>
      <list type="bullet">
        <item>
          <term>Free: does not grab/confine the mouse cursor even when it is hidden. This can be used for cases where the cursor should render using the operating system outside the window, and perform custom rendering (with SetMouseVisible(false)) inside.</term>
        </item>
      </list>
      <para>
      </para>
      <format type="text/html">
        <h2>Joystick input</h2>
      </format>
      <para>Plugged in joysticks will begin sending input events automatically. Each joystick will be assigned a joystick ID which will be used in subsequent joystick events, as well as for retrieving the joystick state. Use <see cref="M:Urho.Input.GetJoystick" /> to retrieve the joystick state by ID. In case you do not have the ID, you can also use <see cref="M:Urho.Input.GetJoystickByIndex" /> which uses a zero-based index; see <see cref="P:Urho.Input.NumJoystick" /> for the number of currently connected joysticks. The ID, as well as the joystick name, can be looked up from the joystick state.</para>
      <para>If the joystick model is recognized by SDL as a game controller the buttons and axes mappings utilize known constants such as CONTROLLER_BUTTON_A or CONTROLLER_AXIS_LEFTX without having to guess them. Use <see cref="IsController()" /> to distinguish between a game controller and an unrecognized joystick.</para>
      <para>
      </para>
      <para>On platforms that support the accelerometer, it will appear as a "virtual" joystick.</para>
      <para>
      </para>
      <format type="text/html">
        <h2>Touch input</h2>
      </format>
      <para>On platforms where touch input is available, touch begin/end/move events will be sent, as well as multi-gesture events with pinch/rotation delta values when more than one finger is pressed down. The current finger touches can also be accessed via a polling API: <see cref="P:Urho.Input.NumTouches" /> and <see cref="M:Urho.Input.GetTouch." /></para>
      <para>Touch gestures can be recorded using SDL's inbuilt $1 gesture recognition system. Use <see cref="M:Urho.Input.RecordGesture" /> to start recording. The following finger movements will be recorded until the finger is lifted, at which point the recording ends and the GestureRecorded event is sent with the hash ID of the new gesture. The current in-memory gesture(s) can be saved or loaded as binary data.</para>
      <para>
      </para>
      <para>Whenever a recognized gesture is entered by the user, the GestureInput event will be sent. In addition to the ID of the best matched gesture, it contains the center position and an error metric (lower = better) to help filter out false gestures.</para>
      <para>Note that all recorded (whether saved or not) and loaded gestures are held in-memory. Two additional functions are available to clear them: <see cref="M:Urho.Input.RemoveGesture" /> to selectively clear a gesture by its ID and <see cref="M:Urho.Input.RemoveAllGestures" /> to clear them all.</para>
      <para>Touch input can also emulate a virtual joystick by displaying on-screen buttons. See the function <see cref="M:Urho.Input.AddScreenJoystick" />.</para>
      <para>Touch emulation can be used to test mobile applications on a desktop machine without a touch screen. See <see cref="P:Urho.Input.TouchEmulation" />. When touch emulation is enabled, actual mouse events are no longer sent and the operating system mouse cursor is forced visible. The left mouse button acts as a moving finger, while the rest of the mouse buttons act as stationary fingers for multi-finger gestures. For example pressing down both left and right mouse buttons, then dragging the mouse with the buttons still pressed would emulate a two-finger pinch zoom-in gesture.</para>
      <para>
      </para>
      <format type="text/html">
        <h2>Platform-specific details</h2>
      </format>
      <para>On platforms that support it (such as Android) an on-screen virtual keyboard can be shown or hidden. When shown, keypresses from the virtual keyboard will be sent as text input events just as if typed from an actual keyboard. Show or hide it by calling <see cref="S" />etScreenKeyboardVisible. The <see cref="T:Urho.Gui.UI" /> subsystem can also automatically show the virtual keyboard when a line editing element is focused, and hide it when defocused. This behavior can be controlled by calling SetUseScreenKeyboard.</para>
      <para>On Windows the user must first touch the screen once before touch input is activated. Trying to record or load touch gestures will fail before that.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Input ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <para>Constructs a new instance of Urho.Input which is tied to the <see cref="P:Urho.Application.CurrentContext" />.</para>
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Input (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer to the raw unmanaged Urho object.</param>
        <summary>Constructs a new instance of Urho.Input, given a raw pointer to an unmanaged object</summary>
        <remarks>
          <para>This creates a new managed wrapper for the type using the raw pointer to an unmanaged object.</para>
          <para>Objects that are created in this fashion get registered with the UrhoSharp runtime.</para>
          <para>This is intended to be used by the UrhoSharp runtime, and is not intended to be used by users.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Input (Urho.Context context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Urho.Context context) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="context" Type="Urho.Context" />
      </Parameters>
      <Docs>
        <param name="context">The context that this object will be attached to.</param>
        <summary>
          <para>Constructs a new instance of Urho.Input linked to a specific <see cref="T:Urho.Context" />.</para>
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Input (Urho.UrhoObjectFlag emptyFlag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype Urho.UrhoObjectFlag emptyFlag) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="emptyFlag" Type="Urho.UrhoObjectFlag" />
      </Parameters>
      <Docs>
        <param name="emptyFlag">Pass UrhoObjectFlag.Empty.</param>
        <summary>Empty constructor, chain to this constructor when you provide your own constructor that sets the handle field.</summary>
        <remarks>
          <para>This constructor should be invoked by your code if you provide your own constructor that sets the handle field.</para>
          <para>This essentially circumvents the default path that creates a new object and sets the handle and does not call RegisterObject on the target, you must do this on your own constructor.</para>
          <para>You would typically chain to this constructor from your own, and then set the handle to the unmanaged object from your code, and then register your object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddScreenJoystick">
      <MemberSignature Language="C#" Value="public int AddScreenJoystick (Urho.Resources.XmlFile layoutFile, Urho.Resources.XmlFile styleFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 AddScreenJoystick(class Urho.Resources.XmlFile layoutFile, class Urho.Resources.XmlFile styleFile) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutFile" Type="Urho.Resources.XmlFile" />
        <Parameter Name="styleFile" Type="Urho.Resources.XmlFile" />
      </Parameters>
      <Docs>
        <param name="layoutFile">To be added.</param>
        <param name="styleFile">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterMousePosition">
      <MemberSignature Language="C#" Value="public void CenterMousePosition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CenterMousePosition() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DropFile">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.DropFileEventArgs&gt; DropFile;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.DropFileEventArgs&gt; DropFile" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.DropFileEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToDropFile" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls whether input is enabled or disabled.</summary>
        <value>The current input enabled status, defaults to <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitRequested">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.ExitRequestedEventArgs&gt; ExitRequested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.ExitRequestedEventArgs&gt; ExitRequested" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.ExitRequestedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToExitRequested" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GestureInput">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.GestureInputEventArgs&gt; GestureInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.GestureInputEventArgs&gt; GestureInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.GestureInputEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToGestureInput" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GestureRecorded">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.GestureRecordedEventArgs&gt; GestureRecorded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.GestureRecordedEventArgs&gt; GestureRecorded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.GestureRecordedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToGestureRecorded" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetJoystick">
      <MemberSignature Language="C#" Value="public Urho.JoystickState* GetJoystick (int id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Urho.JoystickState* GetJoystick(int32 id) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.JoystickState*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">To be added.</param>
        <summary>
            Return joystick state by ID, or null if does not exist.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetJoystickByIndex">
      <MemberSignature Language="C#" Value="public Urho.JoystickState* GetJoystickByIndex (uint index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Urho.JoystickState* GetJoystickByIndex(unsigned int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.JoystickState*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>
            Return joystick state by index, or null if does not exist. 0 = first connected joystick.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetJoystickByName">
      <MemberSignature Language="C#" Value="public Urho.JoystickState* GetJoystickByName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Urho.JoystickState* GetJoystickByName(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.JoystickState*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKeyDown">
      <MemberSignature Language="C#" Value="public bool GetKeyDown (Urho.Key key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetKeyDown(valuetype Urho.Key key) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Urho.Key" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>
            Check if a key is held down.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKeyFromName">
      <MemberSignature Language="C#" Value="public int GetKeyFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetKeyFromName(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
            Return keycode from key name.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKeyFromScancode">
      <MemberSignature Language="C#" Value="public int GetKeyFromScancode (int scancode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetKeyFromScancode(int32 scancode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scancode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="scancode">To be added.</param>
        <summary>
            Return keycode from scancode.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKeyName">
      <MemberSignature Language="C#" Value="public string GetKeyName (Urho.Key key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetKeyName(valuetype Urho.Key key) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Urho.Key" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>
            Return name of key from keycode.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKeyPress">
      <MemberSignature Language="C#" Value="public bool GetKeyPress (Urho.Key key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetKeyPress(valuetype Urho.Key key) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Urho.Key" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>
            Check if a key has been pressed on this frame.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMouseButtonDown">
      <MemberSignature Language="C#" Value="public bool GetMouseButtonDown (Urho.MouseButton button);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMouseButtonDown(valuetype Urho.MouseButton button) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="button" Type="Urho.MouseButton" />
      </Parameters>
      <Docs>
        <param name="button">To be added.</param>
        <summary>
            Check if a mouse button is held down.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMouseButtonPress">
      <MemberSignature Language="C#" Value="public bool GetMouseButtonPress (Urho.MouseButton button);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMouseButtonPress(valuetype Urho.MouseButton button) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="button" Type="Urho.MouseButton" />
      </Parameters>
      <Docs>
        <param name="button">To be added.</param>
        <summary>
            Check if a mouse button has been pressed on this frame.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetQualifierDown">
      <MemberSignature Language="C#" Value="public bool GetQualifierDown (int qualifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetQualifierDown(int32 qualifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifier" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="qualifier">To be added.</param>
        <summary>
            Check if a qualifier key is held down.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetQualifierPress">
      <MemberSignature Language="C#" Value="public bool GetQualifierPress (int qualifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetQualifierPress(int32 qualifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifier" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="qualifier">To be added.</param>
        <summary>
            Check if a qualifier key has been pressed on this frame.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScancodeDown">
      <MemberSignature Language="C#" Value="public bool GetScancodeDown (int scancode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetScancodeDown(int32 scancode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scancode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="scancode">To be added.</param>
        <summary>
            Check if a key is held down by scancode.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScancodeFromKey">
      <MemberSignature Language="C#" Value="public int GetScancodeFromKey (Urho.Key key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetScancodeFromKey(valuetype Urho.Key key) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="Urho.Key" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>
            Return scancode from keycode.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScancodeFromName">
      <MemberSignature Language="C#" Value="public int GetScancodeFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetScancodeFromName(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <summary>
            Return scancode from key name.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScancodeName">
      <MemberSignature Language="C#" Value="public string GetScancodeName (int scancode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetScancodeName(int32 scancode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scancode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="scancode">To be added.</param>
        <summary>
            Return name of key from scancode.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScancodePress">
      <MemberSignature Language="C#" Value="public bool GetScancodePress (int scancode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetScancodePress(int32 scancode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scancode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="scancode">To be added.</param>
        <summary>
            Check if a key has been pressed on this frame by scancode.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTouch">
      <MemberSignature Language="C#" Value="public Urho.TouchState GetTouch (uint index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Urho.TouchState GetTouch(unsigned int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.TouchState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>
            Return active finger touch by index.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasFocus">
      <MemberSignature Language="C#" Value="public bool HasFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasFocus() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Return whether application window has input focus.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputFocus">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.InputFocusEventArgs&gt; InputFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.InputFocusEventArgs&gt; InputFocus" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.InputFocusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToInputFocus" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsScreenJoystickVisible">
      <MemberSignature Language="C#" Value="public bool IsScreenJoystickVisible (int id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsScreenJoystickVisible(int32 id) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">To be added.</param>
        <summary>
            Return whether a virtual joystick is visible.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="JoystickAxisMove">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.JoystickAxisMoveEventArgs&gt; JoystickAxisMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.JoystickAxisMoveEventArgs&gt; JoystickAxisMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.JoystickAxisMoveEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToJoystickAxisMove" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JoystickButtonDown">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.JoystickButtonDownEventArgs&gt; JoystickButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.JoystickButtonDownEventArgs&gt; JoystickButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.JoystickButtonDownEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToJoystickButtonDown" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JoystickButtonUp">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.JoystickButtonUpEventArgs&gt; JoystickButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.JoystickButtonUpEventArgs&gt; JoystickButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.JoystickButtonUpEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToJoystickButtonUp" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JoystickConnected">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.JoystickConnectedEventArgs&gt; JoystickConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.JoystickConnectedEventArgs&gt; JoystickConnected" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.JoystickConnectedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToJoystickConnected" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JoystickDisconnected">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.JoystickDisconnectedEventArgs&gt; JoystickDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.JoystickDisconnectedEventArgs&gt; JoystickDisconnected" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.JoystickDisconnectedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToJoystickDisconnected" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JoystickHatMove">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.JoystickHatMoveEventArgs&gt; JoystickHatMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.JoystickHatMoveEventArgs&gt; JoystickHatMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.JoystickHatMoveEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToJoystickHatMove" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.KeyDownEventArgs&gt; KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.KeyDownEventArgs&gt; KeyDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.KeyDownEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToKeyDown" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.KeyUpEventArgs&gt; KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.KeyUpEventArgs&gt; KeyUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.KeyUpEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToKeyUp" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadGestures">
      <MemberSignature Language="C#" Value="public uint LoadGestures (Urho.IO.File source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int32 LoadGestures(class Urho.IO.File source) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Urho.IO.File" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Minimized">
      <MemberSignature Language="C#" Value="public bool Minimized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Minimized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return whether application window is minimized.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseButtonDown">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.MouseButtonDownEventArgs&gt; MouseButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.MouseButtonDownEventArgs&gt; MouseButtonDown" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.MouseButtonDownEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToMouseButtonDown" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseButtonUp">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.MouseButtonUpEventArgs&gt; MouseButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.MouseButtonUpEventArgs&gt; MouseButtonUp" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.MouseButtonUpEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToMouseButtonUp" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseGrabbed">
      <MemberSignature Language="C#" Value="public bool MouseGrabbed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MouseGrabbed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return whether the mouse is currently being grabbed by an operation.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLocked">
      <MemberSignature Language="C#" Value="public bool MouseLocked { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MouseLocked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMode">
      <MemberSignature Language="C#" Value="public Urho.MouseMode MouseMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Urho.MouseMode MouseMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.MouseMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return the mouse mode.
            Or
            Set the mouse mode. </summary>
        <value>
          <para />
        </value>
        <remarks>
          <para>See the <see cref="T:Urho.MouseMode" /> enumeration for detais on the meaning of the MouseMode.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseModeChanged">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.MouseModeChangedEventArgs&gt; MouseModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.MouseModeChangedEventArgs&gt; MouseModeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.MouseModeChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToMouseModeChanged" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public Urho.IntVector2 MouseMove { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Urho.IntVector2 MouseMove" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.IntVector2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return mouse movement since last frame.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoved">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.MouseMovedEventArgs&gt; MouseMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.MouseMovedEventArgs&gt; MouseMoved" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.MouseMovedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToMouseMoved" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveWheel">
      <MemberSignature Language="C#" Value="public int MouseMoveWheel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MouseMoveWheel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return mouse wheel movement since last frame.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveX">
      <MemberSignature Language="C#" Value="public int MouseMoveX { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MouseMoveX" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return horizontal mouse movement since last frame.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveY">
      <MemberSignature Language="C#" Value="public int MouseMoveY { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MouseMoveY" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return vertical mouse movement since last frame.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MousePosition">
      <MemberSignature Language="C#" Value="public Urho.IntVector2 MousePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Urho.IntVector2 MousePosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.IntVector2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return mouse position within window. Should only be used with a visible mouse cursor.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseVisible">
      <MemberSignature Language="C#" Value="public bool MouseVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MouseVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return whether the operating system mouse cursor is visible.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseVisibleChanged">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.MouseVisibleChangedEventArgs&gt; MouseVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.MouseVisibleChangedEventArgs&gt; MouseVisibleChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.MouseVisibleChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToMouseVisibleChanged" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.MouseWheelEventArgs&gt; MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.MouseWheelEventArgs&gt; MouseWheel" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.MouseWheelEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToMouseWheel" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiGesture">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.MultiGestureEventArgs&gt; MultiGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.MultiGestureEventArgs&gt; MultiGesture" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.MultiGestureEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToMultiGesture" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NumJoysticks">
      <MemberSignature Language="C#" Value="public uint NumJoysticks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int32 NumJoysticks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return number of connected joysticks.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NumTouches">
      <MemberSignature Language="C#" Value="public uint NumTouches { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int32 NumTouches" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return number of active finger touches.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Qualifiers">
      <MemberSignature Language="C#" Value="public int Qualifiers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Qualifiers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return the currently held down qualifiers.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RecordGesture">
      <MemberSignature Language="C#" Value="public bool RecordGesture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RecordGesture() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Begin recording a touch gesture. Return true if successful. The E_GESTURERECORDED event (which contains the ID for the new gesture) will be sent when recording finishes.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAllGestures">
      <MemberSignature Language="C#" Value="public void RemoveAllGestures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAllGestures() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Remove all in-memory gestures.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGesture">
      <MemberSignature Language="C#" Value="public bool RemoveGesture (uint gestureID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveGesture(unsigned int32 gestureID) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureID" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="gestureID">To be added.</param>
        <summary>
            Remove an in-memory gesture by ID. Return true if was found.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveScreenJoystick">
      <MemberSignature Language="C#" Value="public bool RemoveScreenJoystick (int id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveScreenJoystick(int32 id) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">To be added.</param>
        <summary>
            Remove screen joystick by instance ID.
            Return true if successful.
            This method should only be called in main thread.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseGrabbed">
      <MemberSignature Language="C#" Value="public void ResetMouseGrabbed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetMouseGrabbed() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseMode">
      <MemberSignature Language="C#" Value="public void ResetMouseMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetMouseMode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseVisible">
      <MemberSignature Language="C#" Value="public void ResetMouseVisible ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetMouseVisible() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Reset last mouse visibility that was not suppressed in SetMouseVisible.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveGesture">
      <MemberSignature Language="C#" Value="public bool SaveGesture (Urho.IO.File dest, uint gestureID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SaveGesture(class Urho.IO.File dest, unsigned int32 gestureID) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dest" Type="Urho.IO.File" />
        <Parameter Name="gestureID" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="dest">To be added.</param>
        <param name="gestureID">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveGestures">
      <MemberSignature Language="C#" Value="public bool SaveGestures (Urho.IO.File dest);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SaveGestures(class Urho.IO.File dest) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dest" Type="Urho.IO.File" />
      </Parameters>
      <Docs>
        <param name="dest">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScreenKeyboardSupport">
      <MemberSignature Language="C#" Value="public bool ScreenKeyboardSupport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScreenKeyboardSupport" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return whether on-screen keyboard is supported.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScreenKeyboardVisible">
      <MemberSignature Language="C#" Value="public bool ScreenKeyboardVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScreenKeyboardVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return whether on-screen keyboard is being shown;  On platform that support it, setting this property displays the on-screen keyboard.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMouseGrabbed">
      <MemberSignature Language="C#" Value="public void SetMouseGrabbed (bool grab, bool suppressEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMouseGrabbed(bool grab, bool suppressEvent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="grab" Type="System.Boolean" />
        <Parameter Name="suppressEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="grab">To be added.</param>
        <param name="suppressEvent">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMouseMode">
      <MemberSignature Language="C#" Value="public void SetMouseMode (Urho.MouseMode mode, bool suppressEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMouseMode(valuetype Urho.MouseMode mode, bool suppressEvent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="Urho.MouseMode" />
        <Parameter Name="suppressEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">To be added.</param>
        <param name="suppressEvent">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMousePosition">
      <MemberSignature Language="C#" Value="public void SetMousePosition (Urho.IntVector2 position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMousePosition(valuetype Urho.IntVector2 position) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="Urho.IntVector2" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMouseVisible">
      <MemberSignature Language="C#" Value="public void SetMouseVisible (bool enable, bool suppressEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMouseVisible(bool enable, bool suppressEvent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enable" Type="System.Boolean" />
        <Parameter Name="suppressEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enable">To be added.</param>
        <param name="suppressEvent">To be added.</param>
        <summary>
            Set whether the operating system mouse cursor is visible. When not visible (default), is kept centered to prevent leaving the window. Mouse visibility event can be suppressed-- this also recalls any unsuppressed SetMouseVisible which can be returned by ResetMouseVisible().
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetScreenJoystickVisible">
      <MemberSignature Language="C#" Value="public void SetScreenJoystickVisible (int id, bool enable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetScreenJoystickVisible(int32 id, bool enable) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="enable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="id">To be added.</param>
        <param name="enable">To be added.</param>
        <summary>
            Set whether the virtual joystick is visible.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToDropFile">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToDropFile (Action&lt;Urho.DropFileEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToDropFile(class System.Action`1&lt;valuetype Urho.DropFileEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.DropFileEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the DropFile event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.DropFile" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToExitRequested">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToExitRequested (Action&lt;Urho.ExitRequestedEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToExitRequested(class System.Action`1&lt;valuetype Urho.ExitRequestedEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.ExitRequestedEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the ExitRequested event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.ExitRequested" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToGestureInput">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToGestureInput (Action&lt;Urho.GestureInputEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToGestureInput(class System.Action`1&lt;valuetype Urho.GestureInputEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.GestureInputEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the GestureInput event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.GestureInput" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToGestureRecorded">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToGestureRecorded (Action&lt;Urho.GestureRecordedEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToGestureRecorded(class System.Action`1&lt;valuetype Urho.GestureRecordedEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.GestureRecordedEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the GestureRecorded event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.GestureRecorded" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToInputFocus">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToInputFocus (Action&lt;Urho.InputFocusEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToInputFocus(class System.Action`1&lt;valuetype Urho.InputFocusEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.InputFocusEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the InputFocus event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.InputFocus" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToJoystickAxisMove">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToJoystickAxisMove (Action&lt;Urho.JoystickAxisMoveEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToJoystickAxisMove(class System.Action`1&lt;valuetype Urho.JoystickAxisMoveEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.JoystickAxisMoveEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the JoystickAxisMove event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.JoystickAxisMove" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToJoystickButtonDown">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToJoystickButtonDown (Action&lt;Urho.JoystickButtonDownEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToJoystickButtonDown(class System.Action`1&lt;valuetype Urho.JoystickButtonDownEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.JoystickButtonDownEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the JoystickButtonDown event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.JoystickButtonDown" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToJoystickButtonUp">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToJoystickButtonUp (Action&lt;Urho.JoystickButtonUpEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToJoystickButtonUp(class System.Action`1&lt;valuetype Urho.JoystickButtonUpEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.JoystickButtonUpEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the JoystickButtonUp event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.JoystickButtonUp" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToJoystickConnected">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToJoystickConnected (Action&lt;Urho.JoystickConnectedEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToJoystickConnected(class System.Action`1&lt;valuetype Urho.JoystickConnectedEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.JoystickConnectedEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the JoystickConnected event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.JoystickConnected" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToJoystickDisconnected">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToJoystickDisconnected (Action&lt;Urho.JoystickDisconnectedEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToJoystickDisconnected(class System.Action`1&lt;valuetype Urho.JoystickDisconnectedEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.JoystickDisconnectedEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the JoystickDisconnected event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.JoystickDisconnected" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToJoystickHatMove">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToJoystickHatMove (Action&lt;Urho.JoystickHatMoveEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToJoystickHatMove(class System.Action`1&lt;valuetype Urho.JoystickHatMoveEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.JoystickHatMoveEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the JoystickHatMove event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.JoystickHatMove" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToKeyDown">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToKeyDown (Action&lt;Urho.KeyDownEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToKeyDown(class System.Action`1&lt;valuetype Urho.KeyDownEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.KeyDownEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the KeyDown event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.KeyDown" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToKeyUp">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToKeyUp (Action&lt;Urho.KeyUpEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToKeyUp(class System.Action`1&lt;valuetype Urho.KeyUpEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.KeyUpEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the KeyUp event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.KeyUp" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToMouseButtonDown">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToMouseButtonDown (Action&lt;Urho.MouseButtonDownEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToMouseButtonDown(class System.Action`1&lt;valuetype Urho.MouseButtonDownEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.MouseButtonDownEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the MouseButtonDown event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.MouseButtonDown" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToMouseButtonUp">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToMouseButtonUp (Action&lt;Urho.MouseButtonUpEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToMouseButtonUp(class System.Action`1&lt;valuetype Urho.MouseButtonUpEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.MouseButtonUpEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the MouseButtonUp event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.MouseButtonUp" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToMouseModeChanged">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToMouseModeChanged (Action&lt;Urho.MouseModeChangedEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToMouseModeChanged(class System.Action`1&lt;valuetype Urho.MouseModeChangedEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.MouseModeChangedEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the MouseModeChanged event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.MouseModeChanged" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToMouseMoved">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToMouseMoved (Action&lt;Urho.MouseMovedEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToMouseMoved(class System.Action`1&lt;valuetype Urho.MouseMovedEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.MouseMovedEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the MouseMoved event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.MouseMoved" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToMouseVisibleChanged">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToMouseVisibleChanged (Action&lt;Urho.MouseVisibleChangedEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToMouseVisibleChanged(class System.Action`1&lt;valuetype Urho.MouseVisibleChangedEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.MouseVisibleChangedEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the MouseVisibleChanged event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.MouseVisibleChanged" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToMouseWheel">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToMouseWheel (Action&lt;Urho.MouseWheelEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToMouseWheel(class System.Action`1&lt;valuetype Urho.MouseWheelEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.MouseWheelEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the MouseWheel event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.MouseWheel" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToMultiGesture">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToMultiGesture (Action&lt;Urho.MultiGestureEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToMultiGesture(class System.Action`1&lt;valuetype Urho.MultiGestureEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.MultiGestureEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the MultiGesture event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.MultiGesture" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToTextInput">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToTextInput (Action&lt;Urho.TextInputEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToTextInput(class System.Action`1&lt;valuetype Urho.TextInputEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.TextInputEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the TextInput event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.TextInput" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToTouchBegin">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToTouchBegin (Action&lt;Urho.TouchBeginEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToTouchBegin(class System.Action`1&lt;valuetype Urho.TouchBeginEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.TouchBeginEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the TouchBegin event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.TouchBegin" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToTouchEnd">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToTouchEnd (Action&lt;Urho.TouchEndEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToTouchEnd(class System.Action`1&lt;valuetype Urho.TouchEndEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.TouchEndEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the TouchEnd event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.TouchEnd" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubscribeToTouchMove">
      <MemberSignature Language="C#" Value="public Urho.Subscription SubscribeToTouchMove (Action&lt;Urho.TouchMoveEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Urho.Subscription SubscribeToTouchMove(class System.Action`1&lt;valuetype Urho.TouchMoveEventArgs&gt; handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.Subscription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Action&lt;Urho.TouchMoveEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">The handler to invoke when this event is raised.</param>
        <summary>Subscribes to the TouchMove event raised by the Input.</summary>
        <returns>Returns an Urho.Subscription that can be used to cancel the subscription.</returns>
        <remarks>
          <para>This method will override any prior subscription, including those assigned to on event handlers.</para>
          <para>This has the advantage that it does a straight connection and returns a handle that is easy to unsubscribe from.</para>
          <para>For a more event-like approach, use the <see cref="E:Urho.Input.TouchMove" /> event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.TextInputEventArgs&gt; TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.TextInputEventArgs&gt; TextInput" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.TextInputEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToTextInput" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleFullscreen">
      <MemberSignature Language="C#" Value="public bool ToggleFullscreen { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ToggleFullscreen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return whether fullscreen toggle is enabled.
            Or
            Set whether ALT-ENTER fullscreen toggle is enabled.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchBegin">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.TouchBeginEventArgs&gt; TouchBegin;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.TouchBeginEventArgs&gt; TouchBegin" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.TouchBeginEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToTouchBegin" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEmulation">
      <MemberSignature Language="C#" Value="public bool TouchEmulation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TouchEmulation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Return whether touch emulation is enabled.
            Or
            Set touch emulation by mouse. Only available on desktop platforms. When enabled, actual mouse events are no longer sent and the mouse cursor is forced visible.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnd">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.TouchEndEventArgs&gt; TouchEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.TouchEndEventArgs&gt; TouchEnd" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.TouchEndEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToTouchEnd" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event Action&lt;Urho.TouchMoveEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;valuetype Urho.TouchMoveEventArgs&gt; TouchMove" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;Urho.TouchMoveEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>
          <para>The event can register multiple callbacks and invoke all of them.   If this is not desired, and you only need a single shot callback, you can use the <see cref="M:Urho.SubscribeToTouchMove" /> method.   That one will force that callback and will ignore any previously set events here.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetJoystickState">
      <MemberSignature Language="C#" Value="public bool TryGetJoystickState (uint idx, out Urho.JoystickState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetJoystickState(unsigned int32 idx, valuetype Urho.JoystickState state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="idx" Type="System.UInt32" />
        <Parameter Name="state" Type="Urho.JoystickState&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="idx">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public override Urho.StringHash Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Urho.StringHash Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.StringHash</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Urho's type system type.</summary>
        <value>StringHash representing the type for this C# type.</value>
        <remarks>This returns the Urho's type and is surfaced for low-level Urho code.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeName">
      <MemberSignature Language="C#" Value="public override string TypeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TypeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Urho's low-level type name.</summary>
        <value>Stringified low-level type name.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeNameStatic">
      <MemberSignature Language="C#" Value="public static string TypeNameStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string TypeNameStatic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Urho's low-level type name, accessible as a static method.</summary>
        <value>Stringified low-level type name.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeStatic">
      <MemberSignature Language="C#" Value="public static Urho.StringHash TypeStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype Urho.StringHash TypeStatic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Urho.StringHash</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Urho's low-level type, accessible as a static method.</summary>
        <value>This returns the Urho's type and is surface for the low-level Urho code.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Poll for window messages. Called by HandleBeginFrame().
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
